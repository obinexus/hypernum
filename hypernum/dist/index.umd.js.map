{"version":3,"file":"index.umd.js","sources":["../src/utils/validation.ts","../src/utils/precision.ts","../src/core/config.ts","../src/core/constants.ts","../src/core/errors.ts","../src/operations/arithmetic.ts","../src/operations/bitwise.ts","../src/operations/power.ts","../src/storage/Heap.ts","../src/structures/ackermann.ts","../src/structures/big-array.ts","../src/structures/number-tree.ts","../src/structures/power-tower.ts","../src/utils/formatting.ts","../src/core/hypernum.ts","../src/operations/comparison.ts","../src/operations/conversion.ts","../src/operations/factorial.ts","../src/index.ts"],"sourcesContent":["/**\n * Validation utilities for Hypernum library\n * Provides type checking and validation functions for large number operations\n */\n\n// Custom error types for validation\nexport class ValidationError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'ValidationError';\n    }\n  }\n  \n  export class OverflowError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'OverflowError';\n    }\n  }\n  \n  // Type guards\n  export const isBigInt = (value: unknown): value is bigint => {\n    return typeof value === 'bigint';\n  };\n  \n  export const isValidNumberString = (value: string): boolean => {\n    return /^-?\\d+$/.test(value);\n  };\n  \n  export const isValidNumber = (value: unknown): value is number => {\n    return typeof value === 'number' && !isNaN(value) && isFinite(value);\n  };\n  \n  // Type conversions with validation\n  export const toBigInt = (value: unknown): bigint => {\n    if (isBigInt(value)) {\n      return value;\n    }\n    \n    if (typeof value === 'string') {\n      if (!isValidNumberString(value)) {\n        throw new ValidationError(`Invalid number string: ${value}`);\n      }\n      return BigInt(value);\n    }\n    \n    if (isValidNumber(value)) {\n      if (!Number.isInteger(value)) {\n        throw new ValidationError('Cannot convert non-integer number to BigInt');\n      }\n      return BigInt(value);\n    }\n    \n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`);\n  };\n  \n  // Range validation\n  export const validateRange = (value: bigint, min?: bigint, max?: bigint): void => {\n    if (min !== undefined && value < min) {\n      throw new ValidationError(`Value ${value} is below minimum ${min}`);\n    }\n    if (max !== undefined && value > max) {\n      throw new ValidationError(`Value ${value} exceeds maximum ${max}`);\n    }\n  };\n  \n  // Operation safety checks\n  export const checkAdditionOverflow = (a: bigint, b: bigint): void => {\n    // Check if addition would overflow\n    if (b > 0 && a > BigInt(Number.MAX_SAFE_INTEGER) - b) {\n      throw new OverflowError('Addition would overflow');\n    }\n    if (b < 0 && a < BigInt(Number.MIN_SAFE_INTEGER) - b) {\n      throw new OverflowError('Addition would underflow');\n    }\n  };\n  \n  export const checkMultiplicationOverflow = (a: bigint, b: bigint): void => {\n    // Check if multiplication would overflow\n    if (a !== BigInt(0) && b !== BigInt(0)) {\n      const maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n      const minValue = BigInt(Number.MIN_SAFE_INTEGER);\n      \n      if (a > maxValue / b || a < minValue / b) {\n        throw new OverflowError('Multiplication would overflow');\n      }\n    }\n  };\n  \n  export const checkPowerOverflow = (base: bigint, exponent: bigint): void => {\n    // Basic overflow checks for exponentiation\n    if (exponent < BigInt(0)) {\n      throw new ValidationError('Negative exponents not supported for integers');\n    }\n    \n    if (base === BigInt(0) && exponent === BigInt(0)) {\n      throw new ValidationError('Zero raised to zero is undefined');\n    }\n    \n    if (exponent > BigInt(1000)) {\n      throw new OverflowError('Exponent too large, computation would overflow');\n    }\n  };\n  \n  // Array and data structure validation\n  export const validateArrayLength = (length: number): void => {\n    if (!Number.isInteger(length) || length < 0) {\n      throw new ValidationError('Array length must be a non-negative integer');\n    }\n    if (length > Number.MAX_SAFE_INTEGER) {\n      throw new ValidationError('Array length exceeds maximum safe integer');\n    }\n  };\n  \n  export const validateArrayIndex = (index: number, length: number): void => {\n    if (!Number.isInteger(index)) {\n      throw new ValidationError('Array index must be an integer');\n    }\n    if (index < 0 || index >= length) {\n      throw new ValidationError('Array index out of bounds');\n    }\n  };\n  \n  // Tree validation\n  export const validateTreeNode = (value: unknown): void => {\n    try {\n      toBigInt(value);\n    } catch (error) {\n      throw new ValidationError('Invalid tree node value');\n    }\n  };\n  \n  // Heap validation\n  export const validateHeapProperty = <T>(\n    value: T,\n    parent: T | undefined,\n    comparator: (a: T, b: T) => -1 | 0 | 1,\n    isMinHeap: boolean\n  ): void => {\n    if (!parent) return;\n    \n    const comparison = comparator(value, parent);\n    if (isMinHeap && comparison < 0) {\n      throw new ValidationError('Min heap property violated');\n    }\n    if (!isMinHeap && comparison > 0) {\n      throw new ValidationError('Max heap property violated');\n    }\n  };\n  \n  // Ackermann function validation\n  export const validateAckermannInput = (m: number, n: number): void => {\n    if (!Number.isInteger(m) || !Number.isInteger(n)) {\n      throw new ValidationError('Ackermann inputs must be integers');\n    }\n    if (m < 0 || n < 0) {\n      throw new ValidationError('Ackermann inputs must be non-negative');\n    }\n    if (m > 4) {\n      throw new ValidationError('First Ackermann parameter too large for computation');\n    }\n  };\n  \n  // General numeric validation utilities\n  export const isInRange = (value: bigint, min: bigint, max: bigint): boolean => {\n    return value >= min && value <= max;\n  };\n  \n  export const isPowerOfTwo = (value: bigint): boolean => {\n    return value > BigInt(0) && (value & (value - BigInt(1))) === BigInt(0);\n  };\n  \n  export const validatePositive = (value: bigint): void => {\n    if (value <= BigInt(0)) {\n      throw new ValidationError('Value must be positive');\n    }\n  };\n  \n  export const validateNonNegative = (value: bigint): void => {\n    if (value < BigInt(0)) {\n      throw new ValidationError('Value must be non-negative');\n    }\n  };","/**\n * Precision utilities for Hypernum library\n * Provides functions for handling decimal precision and rounding operations\n */\n\nimport { ValidationError } from './validation';\n\n/**\n * Rounding modes for decimal operations\n */\nexport enum RoundingMode {\n  FLOOR = 'FLOOR',           // Round towards negative infinity\n  CEIL = 'CEIL',             // Round towards positive infinity\n  DOWN = 'DOWN',             // Round towards zero\n  UP = 'UP',                 // Round away from zero\n  HALF_EVEN = 'HALF_EVEN',   // Round to nearest even number when tied (Banker's rounding)\n  HALF_UP = 'HALF_UP',       // Round up when tied\n  HALF_DOWN = 'HALF_DOWN',   // Round down when tied\n}\n\n/**\n * Scale a bigint by a power of 10\n */\nexport const scaleByPowerOfTen = (value: bigint, power: number): bigint => {\n  if (power === 0) return value;\n  if (power > 0) {\n    return value * (BigInt(10) ** BigInt(power));\n  }\n  return value / (BigInt(10) ** BigInt(-power));\n};\n\n/**\n * Round a number according to specified mode and precision\n */\nexport const round = (\n  value: bigint,\n  precision: number = 0,\n  mode: RoundingMode = RoundingMode.HALF_EVEN\n): bigint => {\n  if (precision < 0) {\n    throw new ValidationError('Precision must be non-negative');\n  }\n\n  if (precision === 0) {\n    return value;\n  }\n\n  const scale = BigInt(10) ** BigInt(precision);\n  const scaled = value / scale;\n  const remainder = value % scale;\n\n  switch (mode) {\n    case RoundingMode.FLOOR:\n      return scaled * scale;\n\n    case RoundingMode.CEIL:\n      return remainder > 0n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.DOWN:\n      return value >= 0n ? scaled * scale : (scaled - 1n) * scale;\n\n    case RoundingMode.UP:\n      return value >= 0n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.HALF_UP:\n      return remainder >= scale / 2n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.HALF_DOWN:\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.HALF_EVEN:\n      if (remainder === scale / 2n) {\n        return scaled % 2n === 0n ? scaled * scale : (scaled + 1n) * scale;\n      }\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\n\n    default:\n      throw new ValidationError('Invalid rounding mode');\n  }\n};\n\n/**\n * Calculate precision required to represent a number without loss\n */\nexport const calculateRequiredPrecision = (value: bigint): number => {\n  if (value === 0n) return 0;\n  \n  const str = value.toString();\n  const nonZeroIndex = str.split('').reverse().findIndex(char => char !== '0');\n  return nonZeroIndex === -1 ? 0 : nonZeroIndex;\n};\n\n/**\n * Normalize two numbers to the same precision\n */\nexport const normalizePrecision = (\n  a: bigint,\n  b: bigint,\n  precisionA: number,\n  precisionB: number\n): [bigint, bigint] => {\n  const targetPrecision = Math.max(precisionA, precisionB);\n  \n  const scaledA = scaleByPowerOfTen(a, targetPrecision - precisionA);\n  const scaledB = scaleByPowerOfTen(b, targetPrecision - precisionB);\n  \n  return [scaledA, scaledB];\n};\n\n/**\n * Scale a division operation to achieve desired precision\n */\nexport const scaledDivision = (\n  numerator: bigint,\n  denominator: bigint,\n  precision: number,\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\n): bigint => {\n  if (denominator === 0n) {\n    throw new ValidationError('Division by zero');\n  }\n\n  if (precision < 0) {\n    throw new ValidationError('Precision must be non-negative');\n  }\n\n  // Scale up numerator to handle desired precision\n  const scaledNumerator = scaleByPowerOfTen(numerator, precision);\n  const quotient = scaledNumerator / denominator;\n  \n  return round(quotient, 0, roundingMode);\n};\n\n/**\n * Calculate the number of significant digits\n */\nexport const significantDigits = (value: bigint): number => {\n  const nonZeroPattern = /[1-9]/;\n  const str = value.toString();\n  const firstSignificant = str.search(nonZeroPattern);\n  if (firstSignificant === -1) return 0;\n  \n  const lastSignificant = str.split('').reverse().findIndex(char => char !== '0');\n  return str.length - firstSignificant - (lastSignificant === -1 ? 0 : lastSignificant);\n};\n\n/**\n * Truncate to specified number of significant digits\n */\nexport const truncateToSignificantDigits = (\n  value: bigint,\n  digits: number,\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\n): bigint => {\n  if (digits <= 0) {\n    throw new ValidationError('Number of significant digits must be positive');\n  }\n\n  const currentDigits = significantDigits(value);\n  \n  if (currentDigits <= digits) {\n    return value;\n  }\n\n  const scale = currentDigits - digits;\n  return round(value, scale, roundingMode);\n};\n\n/**\n * Check if two numbers are equal within a specified precision\n */\nexport const equalWithinPrecision = (\n  a: bigint,\n  b: bigint,\n  precision: number\n): boolean => {\n  const diff = a - b;\n  const tolerance = BigInt(10) ** BigInt(precision);\n  return diff.toString().length <= tolerance.toString().length;\n};\n\n/**\n * Get the fractional part of a number at a given precision\n */\nexport const getFractionalPart = (\n  value: bigint,\n  precision: number\n): bigint => {\n  if (precision <= 0) return 0n;\n  \n  const scale = BigInt(10) ** BigInt(precision);\n  return value % scale;\n};\n\n/**\n * Format a number with exact precision (no rounding)\n */\nexport const toExactPrecision = (value: bigint, precision: number): string => {\n  if (precision < 0) {\n    throw new ValidationError('Precision must be non-negative');\n  }\n\n  let str = value.toString();\n  const isNegative = str.startsWith('-');\n  if (isNegative) {\n    str = str.slice(1);\n  }\n\n  while (str.length <= precision) {\n    str = '0' + str;\n  }\n\n  const integerPart = str.slice(0, -precision) || '0';\n  const fractionalPart = str.slice(-precision);\n\n  return `${isNegative ? '-' : ''}${integerPart}.${fractionalPart}`;\n};","/**\n * Configuration type definitions for Hypernum library\n * Defines all configuration options and their default values\n */\n\nimport { RoundingMode } from '../utils/precision';\nimport { \n  FormatOptions,\n  DebugConfig,\n  CacheConfig,\n  MathConstantsConfig\n} from './common';\n\n/**\n * Basic configuration options for simple usage\n */\nexport interface BasicConfig {\n  /** Decimal precision for operations */\n  precision?: number;\n  /** Rounding mode for decimal operations */\n  roundingMode?: RoundingMode;\n  /** Whether to check for overflow */\n  checkOverflow?: boolean;\n  /** Maximum allowed computation steps */\n  maxSteps?: number;\n  /** Enable debug mode */\n  debug?: boolean;\n}\n\n/**\n * Configuration for arithmetic operations\n */\nexport interface ArithmeticConfig {\n  /** Default precision for decimal operations */\n  defaultPrecision: number;\n  /** Default rounding mode */\n  defaultRoundingMode: RoundingMode;\n  /** Whether to check for overflow by default */\n  checkOverflow: boolean;\n  /** Maximum steps for iterative calculations */\n  maxComputationSteps: number;\n  /** Configure automatic precision adjustment */\n  autoPrecision: {\n    enabled: boolean;\n    maxPrecision: number;\n    minPrecision: number;\n  };\n  /** Constants calculation configuration */\n  constants: MathConstantsConfig;\n}\n\n/**\n * Configuration for data structures\n */\nexport interface DataStructuresConfig {\n  /** Array configuration */\n  array: {\n    initialCapacity: number;\n    growthFactor: number;\n    maxSize: number;\n  };\n  /** Tree configuration */\n  tree: {\n    maxDepth: number;\n    autoBalance: boolean;\n    nodeLimit: number;\n  };\n  /** Heap configuration */\n  heap: {\n    initialCapacity: number;\n    growthPolicy: 'double' | 'linear' | 'fibonacci';\n    validatePropertyOnOperation: boolean;\n  };\n  /** Cache configuration */\n  cache: CacheConfig & {\n    enabled: boolean;\n    persistToDisk: boolean;\n    compressionEnabled: boolean;\n  };\n}\n\n/**\n * Configuration for number formatting\n */\nexport interface FormattingConfig extends FormatOptions {\n  /** Scientific notation configuration */\n  scientific: {\n    /** Minimum exponent to trigger scientific notation */\n    minExponent: number;\n    /** Maximum significant digits */\n    maxSignificantDigits: number;\n    /** Exponent separator character */\n    exponentSeparator: string;\n  };\n  /** Engineering notation configuration */\n  engineering: {\n    /** Use SI prefixes */\n    useSIPrefixes: boolean;\n    /** Custom unit definitions */\n    customUnits?: Map<number, string>;\n  };\n  /** Localization settings */\n  localization: {\n    /** Locale identifier */\n    locale: string;\n    /** Custom number formatting */\n    numberFormat?: Intl.NumberFormatOptions;\n    /** Use locale-specific grouping */\n    useLocaleGrouping: boolean;\n  };\n}\n\n/**\n * Configuration for performance monitoring\n */\nexport interface PerformanceConfig {\n  /** Enable performance tracking */\n  enableTracking: boolean;\n  /** Sampling rate for metrics (0-1) */\n  samplingRate: number;\n  /** Performance thresholds */\n  thresholds: {\n    /** Warning threshold in milliseconds */\n    warnThresholdMs: number;\n    /** Error threshold in milliseconds */\n    errorThresholdMs: number;\n    /** Maximum allowed memory usage in bytes */\n    maxMemoryBytes: number;\n  };\n  /** Metrics collection configuration */\n  metrics: {\n    /** Enable detailed operation timing */\n    timing: boolean;\n    /** Track memory usage */\n    memory: boolean;\n    /** Track cache performance */\n    cache: boolean;\n    /** Custom metrics to track */\n    custom?: Map<string, (operation: any) => number>;\n  };\n}\n\n/**\n * Feature flags for optional functionality\n */\nexport interface FeatureFlags {\n  /** Enable experimental features */\n  experimentalFeatures: boolean;\n  /** Use WebAssembly implementations when available */\n  useWasm: boolean;\n  /** Enable worker thread support */\n  workerThreads: boolean;\n  /** Enable SharedArrayBuffer support */\n  sharedArrayBuffer: boolean;\n  /** Enable BigInt64Array support */\n  bigIntTypedArrays: boolean;\n}\n\n/**\n * Full configuration interface with all options\n */\nexport interface FullConfig {\n  /** Arithmetic operation configuration */\n  arithmetic: ArithmeticConfig;\n  /** Data structure configuration */\n  dataStructures: DataStructuresConfig;\n  /** Formatting configuration */\n  formatting: FormattingConfig;\n  /** Performance configuration */\n  performance: PerformanceConfig;\n  /** Debug configuration */\n  debug: DebugConfig;\n  /** Feature flags */\n  features: FeatureFlags;\n  /** Custom configuration options */\n  custom?: Map<string, any>;\n}\n\n/**\n * Converts FullConfig to BasicConfig if necessary\n */\nexport function convertToBasicConfig(config: HypernumConfig): BasicConfig {\n  if (isBasicConfig(config)) {\n    return config;\n  }\n  return {\n    precision: config.arithmetic.defaultPrecision,\n    roundingMode: config.arithmetic.defaultRoundingMode,\n    checkOverflow: config.arithmetic.checkOverflow,\n    maxSteps: config.arithmetic.maxComputationSteps,\n    debug: config.debug.verbose\n  };\n}\n\n/**\n * Combined configuration type that can be either basic or full\n */\nexport type HypernumConfig = BasicConfig | FullConfig;\n\n/**\n * Default configuration values for basic config\n */\nexport const DEFAULT_BASIC_CONFIG: Required<BasicConfig> = {\n  precision: 0,\n  roundingMode: RoundingMode.HALF_EVEN,\n  checkOverflow: true,\n  maxSteps: 1000,\n  debug: false\n};\n\n/**\n * Full default configuration values\n */\nexport const DEFAULT_FULL_CONFIG: FullConfig = {\n  arithmetic: {\n    defaultPrecision: 0,\n    defaultRoundingMode: RoundingMode.HALF_EVEN,\n    checkOverflow: true,\n    maxComputationSteps: 1000,\n    autoPrecision: {\n      enabled: true,\n      maxPrecision: 100,\n      minPrecision: 0\n    },\n    constants: {\n      precision: 50,\n      cache: true,\n      algorithm: 'series'\n    }\n  },\n  dataStructures: {\n    array: {\n      initialCapacity: 16,\n      growthFactor: 2,\n      maxSize: 1_000_000\n    },\n    tree: {\n      maxDepth: 1000,\n      autoBalance: true,\n      nodeLimit: 1_000_000\n    },\n    heap: {\n      initialCapacity: 16,\n      growthPolicy: 'double',\n      validatePropertyOnOperation: true\n    },\n    cache: {\n      enabled: true,\n      maxSize: 1000,\n      ttl: 3600000, // 1 hour\n      evictionPolicy: 'LRU',\n      persistToDisk: false,\n      compressionEnabled: false\n    }\n  },\n  formatting: {\n    notation: 'standard',\n    precision: 0,\n    grouping: true,\n    groupSize: 3,\n    decimalSeparator: '.',\n    groupSeparator: ',',\n    uppercase: false,\n    scientific: {\n      minExponent: 6,\n      maxSignificantDigits: 6,\n      exponentSeparator: 'e'\n    },\n    engineering: {\n      useSIPrefixes: true\n    },\n    localization: {\n      locale: 'en-US',\n      useLocaleGrouping: false\n    }\n  },\n  performance: {\n    enableTracking: false,\n    samplingRate: 0.1,\n    thresholds: {\n      warnThresholdMs: 100,\n      errorThresholdMs: 1000,\n      maxMemoryBytes: 1024 * 1024 * 1024 // 1GB\n    },\n    metrics: {\n      timing: true,\n      memory: true,\n      cache: true\n    }\n  },\n  debug: {\n    verbose: false,\n    trackPerformance: false,\n    logLevel: 'error'\n  },\n  features: {\n    experimentalFeatures: false,\n    useWasm: false,\n    workerThreads: false,\n    sharedArrayBuffer: false,\n    bigIntTypedArrays: true\n  }\n};\n\n/**\n * Type guard to check if config is a full configuration\n */\nexport function isFullConfig(config: HypernumConfig): config is FullConfig {\n  return 'arithmetic' in config && 'dataStructures' in config;\n}\n\n/**\n * Type guard to check if config is a basic configuration\n */\nexport function isBasicConfig(config: HypernumConfig): config is BasicConfig {\n  return !isFullConfig(config);\n}\n\n/**\n * Validates configuration values\n */\nexport function validateConfig(config: HypernumConfig): void {\n  if (isFullConfig(config)) {\n    validateFullConfig(config);\n  } else {\n    validateBasicConfig(config);\n  }\n}\n\n/**\n * Validates basic configuration values\n */\nfunction validateBasicConfig(config: BasicConfig): void {\n  if (config.precision !== undefined && config.precision < 0) {\n    throw new Error('Precision cannot be negative');\n  }\n  if (config.maxSteps !== undefined && config.maxSteps <= 0) {\n    throw new Error('Maximum steps must be positive');\n  }\n  if (config.debug !== undefined && typeof config.debug !== 'boolean') {\n    throw new Error('Debug flag must be a boolean');\n  }\n}\n\n/**\n * Validates full configuration values\n */\nfunction validateFullConfig(config: FullConfig): void {\n  if (config.arithmetic.defaultPrecision < 0) {\n    throw new Error('Default precision cannot be negative');\n  }\n  if (config.arithmetic.maxComputationSteps <= 0) {\n    throw new Error('Max computation steps must be positive');\n  }\n  if (config.dataStructures.array.initialCapacity <= 0) {\n    throw new Error('Initial capacity must be positive');\n  }\n  if (config.dataStructures.array.growthFactor <= 1) {\n    throw new Error('Growth factor must be greater than 1');\n  }\n  if (config.performance.samplingRate < 0 || config.performance.samplingRate > 1) {\n    throw new Error('Sampling rate must be between 0 and 1');\n  }\n}\n\n/**\n * Merges configuration with appropriate defaults\n */\nexport function mergeConfig(custom: Partial<HypernumConfig> = {}): HypernumConfig {\n  if (isFullConfig(custom  as FullConfig)) {\n    const fullConfig = custom as FullConfig;\n    return {\n      ...DEFAULT_FULL_CONFIG,\n      ...fullConfig,\n      arithmetic: { ...DEFAULT_FULL_CONFIG.arithmetic, ...fullConfig.arithmetic },\n      dataStructures: { ...DEFAULT_FULL_CONFIG.dataStructures, ...fullConfig.dataStructures },\n      formatting: { ...DEFAULT_FULL_CONFIG.formatting, ...fullConfig.formatting },\n      performance: { ...DEFAULT_FULL_CONFIG.performance, ...fullConfig.performance },\n      debug: { ...DEFAULT_FULL_CONFIG.debug, ...fullConfig.debug },\n      features: { ...DEFAULT_FULL_CONFIG.features, ...fullConfig.features }\n    };\n  }\n  \n  const basicConfig: BasicConfig = {\n    precision: (custom as Partial<BasicConfig>).precision ?? DEFAULT_BASIC_CONFIG.precision,\n    roundingMode: (custom as Partial<BasicConfig>).roundingMode ?? DEFAULT_BASIC_CONFIG.roundingMode,\n    checkOverflow: (custom as Partial<BasicConfig>).checkOverflow ?? DEFAULT_BASIC_CONFIG.checkOverflow,\n    maxSteps: (custom as Partial<BasicConfig>).maxSteps ?? DEFAULT_BASIC_CONFIG.maxSteps,\n    debug: (custom as Partial<BasicConfig>).debug ?? DEFAULT_BASIC_CONFIG.debug\n  };\n\n  return basicConfig;\n}","/**\n * Core constants for Hypernum library\n * Defines fundamental values and limits used across the library\n */\n\n// Numerical limits\nexport const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\nexport const MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\nexport const MAX_PRECISION = 100;\nexport const MAX_COMPUTATION_STEPS = 1000;\nexport const MAX_BITS = 1024;\n\n// Commonly used values\nexport const ZERO = BigInt(0);\nexport const ONE = BigInt(1);\nexport const TWO = BigInt(2);\nexport const TEN = BigInt(10);\nexport const NEGATIVE_ONE = BigInt(-1);\n\n// Power operation limits\nexport const MAX_POWER_BASE = BigInt(2) ** BigInt(53);\nexport const MAX_POWER_EXPONENT = BigInt(1000);\nexport const MAX_TETRATION_HEIGHT = BigInt(4);\nexport const MAX_FACTORIAL_INPUT = BigInt(1000);\n\n// Tree and heap configuration\nexport const DEFAULT_TREE_MAX_DEPTH = 1000;\nexport const DEFAULT_HEAP_INITIAL_CAPACITY = 16;\nexport const DEFAULT_ARRAY_GROWTH_FACTOR = 2;\nexport const MIN_ARRAY_CAPACITY = 16;\n\n// Formatting configuration\nexport const DEFAULT_DECIMAL_SEPARATOR = '.';\nexport const DEFAULT_GROUP_SEPARATOR = ',';\nexport const DEFAULT_GROUP_SIZE = 3;\nexport const MAX_GROUP_SIZE = 10;\n\n// Roman numeral limits\nexport const MIN_ROMAN_VALUE = 1;\nexport const MAX_ROMAN_VALUE = 3999;\n\n// Ackermann function limits\nexport const MAX_ACKERMANN_M = 4;\nexport const MAX_ACKERMANN_N = 1000;\n\n// Cache configuration\nexport const DEFAULT_CACHE_SIZE = 1000;\nexport const MAX_CACHE_SIZE = 10000;\n\n// Error messages\nexport const ERROR_MESSAGES = {\n  OVERFLOW: 'Operation would result in overflow',\n  UNDERFLOW: 'Operation would result in underflow',\n  NEGATIVE_ROOT: 'Cannot compute root of negative number',\n  NEGATIVE_EXPONENT: 'Negative exponents not supported for integers',\n  DIVISION_BY_ZERO: 'Division by zero',\n  INVALID_PRECISION: 'Precision must be non-negative and not exceed MAX_PRECISION',\n  INVALID_BASE: 'Base must be a positive integer',\n  INVALID_ROMAN: 'Invalid Roman numeral',\n  COMPUTATION_LIMIT: 'Computation exceeded maximum allowed steps',\n  NEGATIVE_INDEX: 'Array index cannot be negative',\n  TREE_DEPTH_EXCEEDED: 'Maximum tree depth exceeded',\n  INVALID_HEAP_PROPERTY: 'Heap property violation detected'\n} as const;\n\n// Feature flags for optional functionality\nexport const FEATURES = {\n  OVERFLOW_CHECKING: true,\n  AUTOMATIC_PRECISION: true,\n  MEMOIZATION: true,\n  TREE_BALANCING: true,\n  DEBUG_MODE: false\n} as const;\n\n// Default options for various operations\nexport const DEFAULT_OPTIONS = {\n  precision: 0,\n  roundingMode: 'HALF_EVEN',\n  checkOverflow: true,\n  maxSteps: MAX_COMPUTATION_STEPS,\n  grouping: true,\n  uppercase: false,\n  cache: true\n} as const;\n\n// Units for number formatting (powers of 1000)\nexport const NUMBER_UNITS = [\n  { value: 1n, symbol: '' },\n  { value: 1000n, symbol: 'K' },\n  { value: 1000000n, symbol: 'M' },\n  { value: 1000000000n, symbol: 'B' },\n  { value: 1000000000000n, symbol: 'T' },\n  { value: 1000000000000000n, symbol: 'Q' }\n] as const;\n\n// Performance monitoring thresholds\nexport const PERFORMANCE = {\n  WARN_THRESHOLD_MS: 100,\n  ERROR_THRESHOLD_MS: 1000,\n  MAX_ARRAY_SIZE: 1000000,\n  MAX_TREE_SIZE: 1000000\n} as const;","/**\n * Custom error types for Hypernum library\n * Provides specific error classes for different types of errors that can occur\n * during mathematical operations and data structure manipulations\n */\n\nimport { ERROR_MESSAGES } from './constants';\n\n/**\n * Base error class for Hypernum library\n * All other error classes inherit from this\n */\nexport class HypernumError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'HypernumError';\n    Object.setPrototypeOf(this, HypernumError.prototype);\n  }\n}\n\n/**\n * Error for validation failures\n */\nexport class ValidationError extends HypernumError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n\n/**\n * Error for arithmetic overflow conditions\n */\nexport class OverflowError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.OVERFLOW) {\n    super(message);\n    this.name = 'OverflowError';\n    Object.setPrototypeOf(this, OverflowError.prototype);\n  }\n}\n\n/**\n * Error for arithmetic underflow conditions\n */\nexport class UnderflowError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.UNDERFLOW) {\n    super(message);\n    this.name = 'UnderflowError';\n    Object.setPrototypeOf(this, UnderflowError.prototype);\n  }\n}\n\n/**\n * Error for division by zero\n */\nexport class DivisionByZeroError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.DIVISION_BY_ZERO) {\n    super(message);\n    this.name = 'DivisionByZeroError';\n    Object.setPrototypeOf(this, DivisionByZeroError.prototype);\n  }\n}\n\n/**\n * Error for precision-related issues\n */\nexport class PrecisionError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.INVALID_PRECISION) {\n    super(message);\n    this.name = 'PrecisionError';\n    Object.setPrototypeOf(this, PrecisionError.prototype);\n  }\n}\n\n/**\n * Error for computation limits exceeded\n */\nexport class ComputationLimitError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.COMPUTATION_LIMIT) {\n    super(message);\n    this.name = 'ComputationLimitError';\n    Object.setPrototypeOf(this, ComputationLimitError.prototype);\n  }\n}\n\n/**\n * Error for invalid operations on data structures\n */\nexport class DataStructureError extends HypernumError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DataStructureError';\n    Object.setPrototypeOf(this, DataStructureError.prototype);\n  }\n}\n\n/**\n * Error for heap property violations\n */\nexport class HeapPropertyError extends DataStructureError {\n  constructor(message: string = ERROR_MESSAGES.INVALID_HEAP_PROPERTY) {\n    super(message);\n    this.name = 'HeapPropertyError';\n    Object.setPrototypeOf(this, HeapPropertyError.prototype);\n  }\n}\n\n/**\n * Error for tree-related issues\n */\nexport class TreeError extends DataStructureError {\n  constructor(message: string = ERROR_MESSAGES.TREE_DEPTH_EXCEEDED) {\n    super(message);\n    this.name = 'TreeError';\n    Object.setPrototypeOf(this, TreeError.prototype);\n  }\n}\n\n/**\n * Error for array index out of bounds\n */\nexport class IndexError extends DataStructureError {\n  constructor(message: string = ERROR_MESSAGES.NEGATIVE_INDEX) {\n    super(message);\n    this.name = 'IndexError';\n    Object.setPrototypeOf(this, IndexError.prototype);\n  }\n}\n\n/**\n * Error for invalid number format or conversion\n */\nexport class FormatError extends HypernumError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FormatError';\n    Object.setPrototypeOf(this, FormatError.prototype);\n  }\n}\n\n/**\n * Error for invalid Roman numeral operations\n */\nexport class RomanNumeralError extends FormatError {\n  constructor(message: string = ERROR_MESSAGES.INVALID_ROMAN) {\n    super(message);\n    this.name = 'RomanNumeralError';\n    Object.setPrototypeOf(this, RomanNumeralError.prototype);\n  }\n}\n\n/**\n * Type guard to check if an error is a Hypernum error\n */\nexport function isHypernumError(error: unknown): error is HypernumError {\n  return error instanceof HypernumError;\n}\n\n/**\n * Helper function to wrap unknown errors into HypernumError\n */\nexport function wrapError(error: unknown): HypernumError {\n  if (isHypernumError(error)) {\n    return error;\n  }\n  if (error instanceof Error) {\n    return new HypernumError(error.message);\n  }\n  return new HypernumError('An unknown error occurred');\n}\n\n/**\n * Helper function to create an appropriate error from a message and optional type\n */\nexport function createError(message: string, type?: string): HypernumError {\n  switch (type) {\n    case 'validation':\n      return new ValidationError(message);\n    case 'overflow':\n      return new OverflowError(message);\n    case 'underflow':\n      return new UnderflowError(message);\n    case 'division':\n      return new DivisionByZeroError(message);\n    case 'precision':\n      return new PrecisionError(message);\n    case 'computation':\n      return new ComputationLimitError(message);\n    case 'heap':\n      return new HeapPropertyError(message);\n    case 'tree':\n      return new TreeError(message);\n    case 'index':\n      return new IndexError(message);\n    case 'format':\n      return new FormatError(message);\n    case 'roman':\n      return new RomanNumeralError(message);\n    default:\n      return new HypernumError(message);\n  }\n}","/**\n * Arithmetic operations module for Hypernum library\n * Provides high-precision arithmetic operations with BigInt support\n */\n\nimport {\n    validateNonNegative,\n    toBigInt,\n    checkAdditionOverflow,\n    checkMultiplicationOverflow,\n    checkPowerOverflow,\n    ValidationError,\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n    round,\n    scaledDivision,\n    normalizePrecision,\n  } from '../utils/precision';\n  \n  /**\n   * Options for arithmetic operations\n   */\n  export interface ArithmeticOptions {\n    precision?: number;\n    roundingMode?: RoundingMode;\n    checkOverflow?: boolean;\n  }\n  \n  const DEFAULT_OPTIONS: Required<ArithmeticOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    checkOverflow: true\n  };\n  \n  /**\n   * Adds two numbers with optional precision and overflow checking\n   */\n  export function add(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.checkOverflow) {\n      checkAdditionOverflow(bigA, bigB);\n    }\n  \n    if (opts.precision === 0) {\n      return bigA + bigB;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    const result = scaledA + scaledB;\n    \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Subtracts two numbers with optional precision and overflow checking\n   */\n  export function subtract(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.checkOverflow) {\n      checkAdditionOverflow(bigA, -bigB);\n    }\n  \n    if (opts.precision === 0) {\n      return bigA - bigB;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    const result = scaledA - scaledB;\n    \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Multiplies two numbers with optional precision and overflow checking\n   */\n  export function multiply(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.checkOverflow) {\n      checkMultiplicationOverflow(bigA, bigB);\n    }\n  \n    const result = bigA * bigB;\n    if (opts.precision === 0) {\n      return result;\n    }\n  \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Divides two numbers with specified precision and rounding\n   */\n  export function divide(\n    numerator: bigint | string | number,\n    denominator: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigNumerator = toBigInt(numerator);\n    const bigDenominator = toBigInt(denominator);\n  \n    if (bigDenominator === BigInt(0)) {\n      throw new ValidationError('Division by zero');\n    }\n  \n    return scaledDivision(\n      bigNumerator,\n      bigDenominator,\n      opts.precision,\n      opts.roundingMode\n    );\n  }\n  \n  /**\n   * Calculates remainder with optional precision\n   */\n  export function remainder(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (bigB === BigInt(0)) {\n      throw new ValidationError('Division by zero in remainder operation');\n    }\n  \n    if (opts.precision === 0) {\n      return bigA % bigB;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    const result = scaledA % scaledB;\n    \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Raises a number to a power with optional precision\n   */\n  export function power(\n    base: bigint | string | number,\n    exponent: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigBase = toBigInt(base);\n    const bigExponent = toBigInt(exponent);\n  \n    if (opts.checkOverflow) {\n      checkPowerOverflow(bigBase, bigExponent);\n    }\n  \n    validateNonNegative(bigExponent);\n  \n    if (bigExponent === BigInt(0)) {\n      return BigInt(1);\n    }\n  \n    if (bigExponent === BigInt(1)) {\n      return bigBase;\n    }\n  \n    let result = bigBase;\n    let remaining = bigExponent - BigInt(1);\n  \n    while (remaining > BigInt(0)) {\n      if (opts.checkOverflow) {\n        checkMultiplicationOverflow(result, bigBase);\n      }\n      result *= bigBase;\n      remaining--;\n    }\n  \n    if (opts.precision > 0) {\n      return round(result, opts.precision, opts.roundingMode);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates the square root with specified precision\n   */\n  export function sqrt(\n    value: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    validateNonNegative(bigValue);\n  \n    if (bigValue === BigInt(0)) {\n      return BigInt(0);\n    }\n  \n    // Scale up for precision\n    const scaleFactor = BigInt(10) ** BigInt(opts.precision * 2);\n    const scaled = bigValue * scaleFactor;\n  \n    // Newton's method for square root\n    let x = scaled;\n    let y = (x + scaled / x) >> BigInt(1);\n  \n    while (y < x) {\n      x = y;\n      y = (x + scaled / x) >> BigInt(1);\n    }\n  \n    return round(x, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Calculates the absolute value\n   */\n  export function abs(value: bigint | string | number): bigint {\n    const bigValue = toBigInt(value);\n    return bigValue < BigInt(0) ? -bigValue : bigValue;\n  }\n  \n  /**\n   * Returns the sign of a number (-1, 0, or 1)\n   */\n  export function sign(value: bigint | string | number): bigint {\n    const bigValue = toBigInt(value);\n    if (bigValue < BigInt(0)) return BigInt(-1);\n    if (bigValue > BigInt(0)) return BigInt(1);\n    return BigInt(0);\n  }\n  \n  /**\n   * Calculates the greatest common divisor of two numbers\n   */\n  export function gcd(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    let bigA = abs(toBigInt(a));\n    let bigB = abs(toBigInt(b));\n  \n    while (bigB !== BigInt(0)) {\n      const temp = bigB;\n      bigB = bigA % bigB;\n      bigA = temp;\n    }\n  \n    return bigA;\n  }\n  \n  /**\n   * Calculates the least common multiple of two numbers\n   */\n  export function lcm(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = abs(toBigInt(a));\n    const bigB = abs(toBigInt(b));\n    \n    if (bigA === BigInt(0) || bigB === BigInt(0)) {\n      return BigInt(0);\n    }\n  \n    return abs(bigA * bigB) / gcd(bigA, bigB);\n  }\n  \n  // /**\n  //  * Calculates factorial of a number\n  //  */\n  // export function factorial(value: bigint | string | number): bigint {\n  //   const bigValue = toBigInt(value);\n  //   validateNonNegative(bigValue);\n  \n  //   if (bigValue > BigInt(1000)) {\n  //     throw new OverflowError('Factorial input too large');\n  //   }\n  \n  //   if (bigValue <= BigInt(1)) {\n  //     return BigInt(1);\n  //   }\n  \n  //   let result = BigInt(1);\n  //   let current = BigInt(2);\n  \n  //   while (current <= bigValue) {\n  //     result *= current;\n  //     current++;\n  //   }\n  \n  //   return result;\n  // }\n  \n  export default {\n    add,\n    subtract,\n    multiply,\n    divide,\n    remainder,\n    power,\n    sqrt,\n    abs,\n    sign,\n    gcd,\n    lcm, \n    // factorial\n    };\n\n  ","/**\n * Bitwise operations module for Hypernum library\n * Provides functions for bit-level manipulations of large numbers\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n    validateNonNegative\n  } from '../utils/validation';\n  \n  /**\n   * Options for bitwise operations\n   */\n  export interface BitwiseOptions {\n    /** Maximum bits to consider in operations */\n    maxBits?: number;\n    /** Whether to throw on overflow */\n    strict?: boolean;\n  }\n  \n  const DEFAULT_OPTIONS: Required<BitwiseOptions> = {\n    maxBits: 1024,\n    strict: true\n  };\n  \n  /**\n   * Validates shift amount is within reasonable bounds\n   */\n  function validateShift(shift: bigint, options: Required<BitwiseOptions>): void {\n    if (shift < 0n) {\n      throw new ValidationError('Shift amount cannot be negative');\n    }\n    if (options.strict && shift >= BigInt(options.maxBits)) {\n      throw new ValidationError(`Shift amount exceeds maximum of ${options.maxBits} bits`);\n    }\n  }\n  \n  /**\n   * Performs bitwise AND operation\n   */\n  export function and(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n\n    return bigA & bigB;\n  }\n  \n  /**\n   * Performs bitwise OR operation\n   */\n  export function or(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n    \n    return bigA | bigB;\n  }\n  \n  /**\n   * Performs bitwise XOR operation\n   */\n  export function xor(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n    \n    return bigA ^ bigB;\n  }\n  \n  /**\n   * Performs bitwise NOT operation\n   */\n  export function not(\n    value: bigint | string | number\n  ): bigint {\n    const bigValue = toBigInt(value);\n    \n    return ~bigValue;\n  }\n  \n  /**\n   * Performs left shift operation\n   */\n  export function leftShift(\n    value: bigint | string | number,\n    shift: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigShift = toBigInt(shift);\n    \n    validateShift(bigShift, opts);\n    return bigValue << bigShift;\n  }\n  \n  /**\n   * Performs right shift operation\n   */\n  export function rightShift(\n    value: bigint | string | number,\n    shift: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigShift = toBigInt(shift);\n    \n    validateShift(bigShift, opts);\n    return bigValue >> bigShift;\n  }\n  \n  /**\n   * Performs unsigned right shift operation\n   * Note: BigInt doesn't have >>> operator, so we implement it manually\n   */\n  export function unsignedRightShift(\n    value: bigint | string | number,\n    shift: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigShift = toBigInt(shift);\n    \n    validateShift(bigShift, opts);\n    \n    if (bigValue >= 0n) {\n      return bigValue >> bigShift;\n    }\n    \n    // Handle negative numbers by first converting to positive\n    const mask = (1n << BigInt(opts.maxBits)) - 1n;\n    return (bigValue & mask) >> bigShift;\n  }\n  \n  /**\n   * Rotates bits left by specified amount\n   */\n  export function rotateLeft(\n    value: bigint | string | number,\n    rotation: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    let bigRotation = toBigInt(rotation);\n    \n    validateNonNegative(bigRotation);\n    \n    // Normalize rotation to be within maxBits\n    if (bigRotation >= BigInt(opts.maxBits)) {\n      bigRotation = bigRotation % BigInt(opts.maxBits);\n    }\n    \n    if (bigRotation === 0n) {\n      return bigValue;\n    }\n    \n    const leftPart = leftShift(bigValue, bigRotation, opts);\n    const rightPart = unsignedRightShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\n    \n    return leftPart | rightPart;\n  }\n  \n  /**\n   * Rotates bits right by specified amount\n   */\n  export function rotateRight(\n    value: bigint | string | number,\n    rotation: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    let bigRotation = toBigInt(rotation);\n    \n    validateNonNegative(bigRotation);\n    \n    // Normalize rotation to be within maxBits\n    if (bigRotation >= BigInt(opts.maxBits)) {\n      bigRotation = bigRotation % BigInt(opts.maxBits);\n    }\n    \n    if (bigRotation === 0n) {\n      return bigValue;\n    }\n    \n    const rightPart = unsignedRightShift(bigValue, bigRotation, opts);\n    const leftPart = leftShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\n    \n    return leftPart | rightPart;\n  }\n  \n  /**\n   * Counts number of set bits (1s)\n   */\n  export function popCount(\n    value: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    let bigValue = toBigInt(value);\n    \n    let count = 0n;\n    while (bigValue !== 0n) {\n      count += bigValue & 1n;\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\n    }\n    \n    return count;\n  }\n  \n  /**\n   * Returns number of trailing zero bits\n   */\n  export function trailingZeros(\n    value: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    let bigValue = toBigInt(value);\n    \n    if (bigValue === 0n) {\n      return BigInt(opts.maxBits);\n    }\n    \n    let count = 0n;\n    while ((bigValue & 1n) === 0n) {\n      count++;\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\n    }\n    \n    return count;\n  }\n  \n  /**\n   * Returns number of leading zero bits\n   */\n  export function leadingZeros(\n    value: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    let bigValue = toBigInt(value);\n    \n    if (bigValue === 0n) {\n      return BigInt(opts.maxBits);\n    }\n    \n    let count = 0n;\n    const msb = 1n << BigInt(opts.maxBits - 1);\n    \n    while ((bigValue & msb) === 0n && count < BigInt(opts.maxBits)) {\n      count++;\n      bigValue = leftShift(bigValue, 1n, opts);\n    }\n    \n    return count;\n  }\n  \n  /**\n   * Returns bit at specified position\n   */\n  export function getBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): boolean {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return (bigValue & (1n << bigPosition)) !== 0n;\n  }\n  \n  /**\n   * Sets bit at specified position\n   */\n  export function setBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return bigValue | (1n << bigPosition);\n  }\n  \n  /**\n   * Clears bit at specified position\n   */\n  export function clearBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return bigValue & ~(1n << bigPosition);\n  }\n  \n  /**\n   * Toggles bit at specified position\n   */\n  export function toggleBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return bigValue ^ (1n << bigPosition);\n  }\n  \n  export default {\n    and,\n    or,\n    xor,\n    not,\n    leftShift,\n    rightShift,\n    unsignedRightShift,\n    rotateLeft,\n    rotateRight,\n    popCount,\n    trailingZeros,\n    leadingZeros,\n    getBit,\n    setBit,\n    clearBit,\n    toggleBit\n  };","/**\n * Power operations module for Hypernum library\n * Provides efficient implementations for exponentiation and related operations\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n    OverflowError,\n    validateNonNegative,\n    checkPowerOverflow\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n    round,\n  } from '../utils/precision';\n  \n  /**\n   * Options for power operations\n   */\n  export interface PowerOptions {\n    /** Precision for decimal operations */\n    precision?: number;\n    /** Rounding mode for decimal operations */\n    roundingMode?: RoundingMode;\n    /** Whether to check for overflow */\n    checkOverflow?: boolean;\n    /** Maximum allowed computation steps */\n    maxSteps?: number;\n  }\n  \n  const DEFAULT_OPTIONS: Required<PowerOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    checkOverflow: true,\n    maxSteps: 1000\n  };\n  \n  /**\n   * Raises a number to an integer power using binary exponentiation\n   */\n  export function power(\n    baseValue: bigint | string | number,\n    exponentValue: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigBase = toBigInt(baseValue);\n    const bigExponent = toBigInt(exponentValue);\n  \n    // Handle special cases\n    if (bigExponent === 0n) {\n      return 1n;\n    }\n    if (bigExponent === 1n) {\n      return bigBase;\n    }\n    if (bigBase === 0n && bigExponent < 0n) {\n      throw new ValidationError('Zero cannot be raised to a negative power');\n    }\n    if (bigBase === 0n) {\n      return 0n;\n    }\n    if (bigBase === 1n) {\n      return 1n;\n    }\n    if (bigBase === -1n) {\n      return bigExponent % 2n === 0n ? 1n : -1n;\n    }\n  \n    // Validate inputs\n    if (bigExponent < 0n) {\n      throw new ValidationError('Negative exponents not supported for integer power');\n    }\n  \n    if (opts.checkOverflow) {\n      checkPowerOverflow(bigBase, bigExponent);\n    }\n  \n    // Binary exponentiation algorithm\n    let result = 1n;\n    let base = bigBase;\n    let exponent = bigExponent;\n    let steps = 0;\n  \n    while (exponent > 0n) {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Power operation exceeded maximum computation steps');\n      }\n  \n      if (exponent & 1n) {\n        result *= base;\n      }\n      base *= base;\n      exponent >>= 1n;\n    }\n  \n    if (opts.precision > 0) {\n      return round(result, opts.precision, opts.roundingMode);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates square root using Newton's method\n   */\n  export function sqrt(\n    value: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n  \n    validateNonNegative(bigValue);\n  \n    if (bigValue === 0n) {\n      return 0n;\n    }\n    if (bigValue === 1n) {\n      return 1n;\n    }\n  \n    // Newton's method for square root\n    let guess = bigValue >> 1n;\n    let lastGuess: bigint;\n    let steps = 0;\n  \n    do {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Square root operation exceeded maximum computation steps');\n      }\n  \n      lastGuess = guess;\n      guess = (guess + bigValue / guess) >> 1n;\n    } while (guess < lastGuess);\n  \n    if (opts.precision > 0) {\n      return round(lastGuess, opts.precision, opts.roundingMode);\n    }\n  \n    return lastGuess;\n  }\n  \n  /**\n   * Calculates nth root using Newton's method\n   */\n  export function nthRoot(\n    value: bigint | string | number,\n    n: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigN = toBigInt(n);\n  \n    validateNonNegative(bigValue);\n    if (bigN <= 0n) {\n      throw new ValidationError('Root index must be positive');\n    }\n  \n    if (bigValue === 0n) {\n      return 0n;\n    }\n    if (bigValue === 1n) {\n      return 1n;\n    }\n    if (bigN === 1n) {\n      return bigValue;\n    }\n    if (bigN === 2n) {\n      return sqrt(bigValue, opts);\n    }\n  \n    // Newton's method for nth root\n    let guess = bigValue >> 1n;\n    let lastGuess: bigint;\n    let steps = 0;\n  \n    const nMinus1 = bigN - 1n;\n  \n    do {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Nth root operation exceeded maximum computation steps');\n      }\n  \n      lastGuess = guess;\n      const powered = power(guess, nMinus1, opts);\n      guess = ((nMinus1 * guess) + (bigValue / powered)) / bigN;\n    } while (guess < lastGuess);\n  \n    if (opts.precision > 0) {\n      return round(lastGuess, opts.precision, opts.roundingMode);\n    }\n  \n    return lastGuess;\n  }\n  \n  /**\n   * Calculates tetration (repeated exponentiation)\n   * an = a^(a^(a^...)) (n times)\n   */\n  export function tetration(\n    base: bigint | string | number,\n    height: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigBase = toBigInt(base);\n    const bigHeight = toBigInt(height);\n  \n    validateNonNegative(bigHeight);\n  \n    if (bigHeight === 0n) {\n      return 1n;\n    }\n    if (bigHeight === 1n) {\n      return bigBase;\n    }\n    if (bigBase === 0n) {\n      return bigHeight % 2n === 0n ? 1n : 0n;\n    }\n    if (bigBase === 1n) {\n      return 1n;\n    }\n    if (bigBase === 2n && bigHeight > 4n) {\n      throw new OverflowError('Tetration would overflow for base 2 and height > 4');\n    }\n  \n    let result = bigBase;\n    let steps = 0;\n  \n    for (let i = 1n; i < bigHeight; i++) {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Tetration operation exceeded maximum computation steps');\n      }\n  \n      result = power(bigBase, result, opts);\n    }\n  \n    if (opts.precision > 0) {\n      return round(result, opts.precision, opts.roundingMode);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates super-root (inverse tetration)\n   * Finds x where xn = value\n   */\n  export function superRoot(\n    value: bigint | string | number,\n    height: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigHeight = toBigInt(height);\n  \n    validateNonNegative(bigHeight);\n    if (bigHeight === 0n) {\n      throw new ValidationError('Height cannot be zero for super-root');\n    }\n    if (bigValue < 1n) {\n      throw new ValidationError('Value must be at least 1 for super-root');\n    }\n  \n    if (bigValue === 1n) {\n      return 1n;\n    }\n    if (bigHeight === 1n) {\n      return bigValue;\n    }\n  \n    // Binary search for super-root\n    let left = 1n;\n    let right = bigValue;\n    let steps = 0;\n  \n    while (left <= right) {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Super-root operation exceeded maximum computation steps');\n      }\n  \n      const mid = (left + right) >> 1n;\n      try {\n        const test = tetration(mid, bigHeight, opts);\n        if (test === bigValue) {\n          return mid;\n        }\n        if (test < bigValue) {\n          left = mid + 1n;\n        } else {\n          right = mid - 1n;\n        }\n      } catch (error) {\n        right = mid - 1n;\n      }\n    }\n  \n    if (opts.precision > 0) {\n      return round(right, opts.precision, opts.roundingMode);\n    }\n  \n    return right;\n  }\n  \n  export default {\n    power,\n    sqrt,\n    nthRoot,\n    tetration,\n    superRoot\n  };","\n/**\n * Represents the result of a comparison operation\n * -1: first value is less than second value\n *  0: values are equal\n *  1: first value is greater than second value\n */\nexport type ComparisonResult = -1 | 0 | 1;\n\n/**\n * Generic comparator function type for heap elements\n */\nexport type Comparator<T> = (a: T, b: T) => ComparisonResult;\n\n/**\n * Abstract base heap class implementing common heap operations\n */\nabstract class Heap<T> {\n  protected heap: T[];\n  protected readonly compare: Comparator<T>;\n\n  constructor(comparator: Comparator<T>) {\n    this.heap = [];\n    this.compare = comparator;\n  }\n\n  /**\n   * Gets the size of the heap\n   */\n  public size(): number {\n    return this.heap.length;\n  }\n\n  /**\n   * Checks if the heap is empty\n   */\n  public isEmpty(): boolean {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Peeks at the root element without removing it\n   */\n  public peek(): T | undefined {\n    return this.heap[0];\n  }\n\n  /**\n   * Inserts a new element into the heap\n   */\n  public push(value: T): void {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1);\n  }\n\n  /**\n   * Removes and returns the root element\n   */\n  public pop(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const root = this.heap[0];\n    const last = this.heap.pop()!;\n\n    if (!this.isEmpty()) {\n      this.heap[0] = last;\n      this.siftDown(0);\n    }\n\n    return root;\n  }\n\n  /**\n   * Removes all elements from the heap\n   */\n  public clear(): void {\n    this.heap = [];\n  }\n\n  /**\n   * Creates a heap from an array of elements\n   */\n  public static heapify<T extends {}>(array: T[], comparator: Comparator<T>): Heap<T> {\n    const heap = this instanceof MinHeap ? new MinHeap(comparator) : new MaxHeap(comparator);\n    array.forEach(item => heap.push(item));\n    return heap;\n  }\n\n  /**\n   * Gets the parent index of a node\n   */\n  protected getParentIndex(index: number): number {\n    return Math.floor((index - 1) / 2);\n  }\n\n  /**\n   * Gets the left child index of a node\n   */\n  protected getLeftChildIndex(index: number): number {\n    return 2 * index + 1;\n  }\n\n  /**\n   * Gets the right child index of a node\n   */\n  protected getRightChildIndex(index: number): number {\n    return 2 * index + 2;\n  }\n\n  /**\n   * Swaps two elements in the heap\n   */\n  protected swap(i: number, j: number): void {\n    const temp = this.heap[i]!;\n    this.heap[i] = this.heap[j]!;\n    this.heap[j] = temp;\n  }\n\n  /**\n   * Moves an element up the heap until heap property is satisfied\n   */\n  protected abstract siftUp(index: number): void;\n\n  /**\n   * Moves an element down the heap until heap property is satisfied\n   */\n  protected abstract siftDown(index: number): void;\n}\n\n/**\n * MinHeap implementation where the root is the smallest element\n */\nexport class MinHeap<T> extends Heap<T> {\n  constructor(comparator: Comparator<T>) {\n    super(comparator);\n  }\n\n  protected siftUp(index: number): void {\n    while (index > 0) {\n      const parentIndex = this.getParentIndex(index);\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) >= 0) {\n        break;\n      }\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  protected siftDown(index: number): void {\n    const size = this.heap.length;\n    \n    while (true) {\n      let smallest = index;\n      const left = this.getLeftChildIndex(index);\n      const right = this.getRightChildIndex(index);\n\n      if (left < size && this.compare(this.heap[left]!, this.heap[smallest]!) < 0) {\n        smallest = left;\n      }\n\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right] as T, this.heap[smallest] as T) < 0) {\n        smallest = right;\n      }\n\n      if (smallest === index) {\n        break;\n      }\n\n      this.swap(index, smallest);\n      index = smallest;\n    }\n  }\n}\n\n/**\n * MaxHeap implementation where the root is the largest element\n */\nexport class MaxHeap<T> extends Heap<T> {\n  constructor(comparator: Comparator<T>) {\n    super(comparator);\n  }\n\n  protected siftUp(index: number): void {\n    while (index > 0) {\n      const parentIndex = this.getParentIndex(index);\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) <= 0) {\n        break;\n      }\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  protected siftDown(index: number): void {\n    const size = this.heap.length;\n    \n    while (true) {\n      let largest = index;\n      const left = this.getLeftChildIndex(index);\n      const right = this.getRightChildIndex(index);\n\n      if (left < size && this.heap[left] !== undefined && this.compare(this.heap[left]!, this.heap[largest]!) > 0) {\n        largest = left;\n      }\n\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right]!, this.heap[largest]!) > 0) {\n        largest = right;\n      }\n\n      if (largest === index) {\n        break;\n      }\n\n      this.swap(index, largest);\n      index = largest;\n    }\n  }\n}\n\n// Type Guards\nexport const isMinHeap = <T>(heap: Heap<T>): heap is MinHeap<T> => {\n  return heap instanceof MinHeap;\n};\n\nexport const isMaxHeap = <T>(heap: Heap<T>): heap is MaxHeap<T> => {\n  return heap instanceof MaxHeap;\n};\n\n/**\n * Custom comparator for large numbers\n */\nexport function createLargeNumberComparator(): (a: bigint, b: bigint) => number {\n  return (a, b) => {\n    return a > b ? 1 : a < b ? -1 : 0;\n  };\n}","import { Comparator } from \"..\";\nimport { MaxHeap, createLargeNumberComparator } from \"../storage/Heap\";\n\n  /**\n   * Interface representing an Ackermann node in the computation structure\n   */\n  interface IAckermannNode {\n    m: number;\n    n: number;\n    value: bigint;\n    prevM?: IAckermannNode;  // Link to A(m-1, n)\n    prevN?: IAckermannNode;  // Link to A(m, n-1)\n    nextM?: IAckermannNode;  // Link to A(m+1, n)\n    nextN?: IAckermannNode;  // Link to A(m, n+1)\n  }\n  \n  /**\n   * Type for Ackermann computation path step\n   */\n  type ComputationStep = {\n    m: number;\n    n: number;\n    value: bigint;\n  };\n  \n  /**\n   * Type for growth rate analysis\n   */\n  type GrowthAnalysis = {\n    value: bigint;\n    increase: bigint;\n    multiplier: bigint;\n  };\n  \n  /**\n   * Class representing the Ackermann function computation structure\n   * Implements caching and relationship tracking between values\n   */\n  export class AckermannStructure {\n    private nodes: Map<string, IAckermannNode>;\n    private maxComputedM: number;\n    private maxComputedN: number;\n    private heap: MaxHeap<bigint>;\n  \n    constructor() {\n      this.nodes = new Map();\n      this.maxComputedM = -1;\n      this.maxComputedN = -1;\n      this.heap = new MaxHeap<bigint>(createLargeNumberComparator() as Comparator<bigint>);\n    }\n  \n    /**\n     * Generates a unique key for node storage\n     */\n    private static getNodeKey(m: number, n: number): string {\n      return `${m},${n}`;\n    }\n  \n    /**\n     * Computes the Ackermann function value\n     * Uses recursion with memoization\n     */\n    private computeAckermann(m: number, n: number): bigint {\n      // Handle invalid inputs\n      if (m < 0 || n < 0) {\n        throw new Error('Ackermann function undefined for negative numbers');\n      }\n  \n      // Check if already computed\n      const key = AckermannStructure.getNodeKey(m, n);\n      const existing = this.nodes.get(key);\n      if (existing) {\n        return existing.value;\n      }\n  \n      // Compute based on Ackermann function definition\n      let value: bigint;\n      try {\n        if (m === 0) {\n          value = BigInt(n + 1);\n        } else if (n === 0) {\n          value = this.computeAckermann(m - 1, 1);\n        } else {\n          const inner = this.computeAckermann(m, n - 1);\n          // Convert bigint to number for recursion, being careful about size\n          const innerNum = inner <= BigInt(Number.MAX_SAFE_INTEGER) \n            ? Number(inner) \n            : Number.MAX_SAFE_INTEGER;\n          value = this.computeAckermann(m - 1, innerNum);\n        }\n      } catch (error) {\n        // Handle stack overflow or computation limits\n        if (error instanceof RangeError) {\n          return BigInt(Number.MAX_SAFE_INTEGER);\n        }\n        throw error;\n      }\n  \n      return value;\n    }\n  \n    /**\n     * Adds a new node to the structure\n     */\n    public addNode(m: number, n: number): IAckermannNode {\n      const key = AckermannStructure.getNodeKey(m, n);\n      if (this.nodes.has(key)) {\n        return this.nodes.get(key)!;\n      }\n  \n      // Create new node\n      const value = this.computeAckermann(m, n);\n      const node: IAckermannNode = { m, n, value };\n      this.nodes.set(key, node);\n  \n      // Link to existing nodes\n      const prevMKey = AckermannStructure.getNodeKey(m - 1, n);\n      const prevNKey = AckermannStructure.getNodeKey(m, n - 1);\n  \n      if (this.nodes.has(prevMKey)) {\n        const prevM = this.nodes.get(prevMKey)!;\n        node.prevM = prevM;\n        prevM.nextM = node;\n      }\n  \n      if (this.nodes.has(prevNKey)) {\n        const prevN = this.nodes.get(prevNKey)!;\n        node.prevN = prevN;\n        prevN.nextN = node;\n      }\n  \n      // Update tracking\n      this.maxComputedM = Math.max(this.maxComputedM, m);\n      this.maxComputedN = Math.max(this.maxComputedN, n);\n      this.heap.push(value);\n  \n      return node;\n    }\n  \n    /**\n     * Builds nodes for a range of m and n values\n     */\n    public buildRange(mRange: number, nRange: number): void {\n      for (let m = 0; m <= mRange; m++) {\n        for (let n = 0; n <= nRange; n++) {\n          this.addNode(m, n);\n        }\n      }\n    }\n  \n    /**\n     * Gets the computation path to reach A(m,n)\n     */\n    public getComputationPath(m: number, n: number): ComputationStep[] {\n      const path: ComputationStep[] = [];\n      const key = AckermannStructure.getNodeKey(m, n);\n      let current = this.nodes.get(key);\n  \n      while (current) {\n        path.push({\n          m: current.m,\n          n: current.n,\n          value: current.value\n        });\n  \n        // Follow computation path backwards\n        if (current.m === 0) {\n          break;\n        } else if (current.n === 0) {\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, 1));\n        } else {\n          const prevN = this.nodes.get(AckermannStructure.getNodeKey(current.m, current.n - 1));\n          if (prevN) {\n            path.push({\n              m: prevN.m,\n              n: prevN.n,\n              value: prevN.value\n            });\n          }\n          // Convert bigint to number safely for the next lookup\n          const nextValue = prevN?.value ?? BigInt(0);\n          const safeNextValue = nextValue <= BigInt(Number.MAX_SAFE_INTEGER)\n            ? Number(nextValue)\n            : Number.MAX_SAFE_INTEGER;\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, safeNextValue));\n        }\n      }\n  \n      return path.reverse();\n    }\n  \n    /**\n     * Analyzes growth rate for a fixed m value\n     */\n    public analyzeGrowthRate(m: number): Map<number, GrowthAnalysis> {\n      const growth = new Map<number, GrowthAnalysis>();\n      let prevValue = BigInt(1);\n  \n      for (let n = 0; n <= this.maxComputedN; n++) {\n        const key = AckermannStructure.getNodeKey(m, n);\n        const node = this.nodes.get(key);\n        if (!node || node.value >= BigInt(Number.MAX_SAFE_INTEGER)) {\n          break;\n        }\n  \n        growth.set(n, {\n          value: node.value,\n          increase: node.value - prevValue,\n          multiplier: prevValue === BigInt(0) ? BigInt(0) : node.value / prevValue\n        });\n  \n        prevValue = node.value;\n      }\n  \n      return growth;\n    }\n  \n    /**\n     * Gets the largest computed value\n     */\n    public getLargestValue(): bigint {\n      return this.heap.peek() ?? BigInt(0);\n    }\n  \n    /**\n     * Gets a specific Ackermann value if it exists\n     */\n    public getValue(m: number, n: number): bigint | undefined {\n      return this.nodes.get(AckermannStructure.getNodeKey(m, n))?.value;\n    }\n  }\n  \n  export default AckermannStructure;","import { Comparator } from '@/core';\nimport { MinHeap, MaxHeap } from '../storage/Heap';\n\n/**\n * Interface for segment tree node operations\n */\nexport interface SegmentTreeNode<T> {  value: T;\n  lazy?: T;\n  start: number;\n  end: number;\n}\n\n/**\n * Type for BigArray operation result\n */\nexport type OperationResult<T> = {\n  success: boolean;\n  value?: T;\n  error?: string;\n};\n\n/**\n * Options for BigArray initialization\n */\nexport interface BigArrayOptions<T> {\n  initialCapacity?: number;\n  growthFactor?: number;\n  comparator?: Comparator<T>;\n}\n\n/**\n * A specialized array implementation for handling large numbers and providing\n * efficient operations with segment tree support\n */\nexport class BigArray<T> {\n  private data: T[];\n  private segmentTree: Array<SegmentTreeNode<T> | null>;\n  private readonly growthFactor: number;\n  private readonly comparator: Comparator<T>;\n  private size: number;\n  private capacity: number;\n\n  constructor(options: BigArrayOptions<T> = {}) {\n    const {\n      initialCapacity = 16,\n      growthFactor = 2,\n      comparator = ((a: T, b: T): -1 | 0 | 1 => {\n        if (a < b) return -1;\n        if (a > b) return 1;\n        return 0;\n      }) as Comparator<T>\n    } = options;\n\n    this.capacity = initialCapacity;\n    this.growthFactor = growthFactor;\n    this.comparator = comparator;\n    this.size = 0;\n    this.data = new Array(this.capacity);\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\n  }\n\n  /**\n   * Gets the current size of the array\n   */\n  public getSize(): number {\n    return this.size;\n  }\n\n  /**\n   * Gets the current capacity of the array\n   */\n  public getCapacity(): number {\n    return this.capacity;\n  }\n\n  /**\n   * Resizes the internal array when needed\n   */\n  private resize(newCapacity: number): void {\n    const newData = new Array(newCapacity);\n    for (let i = 0; i < this.size; i++) {\n      newData[i] = this.data[i];\n    }\n    this.data = newData;\n    this.capacity = newCapacity;\n    this.rebuildSegmentTree();\n  }\n\n  /**\n   * Appends an element to the end of the array\n   */\n  public push(value: T): OperationResult<number> {\n    try {\n      if (this.size >= this.capacity) {\n        this.resize(this.capacity * this.growthFactor);\n      }\n      this.data[this.size] = value;\n      this.updateSegmentTree(0, this.size, value);\n      this.size++;\n      return { success: true, value: this.size - 1 };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error during push'\n      };\n    }\n  }\n\n  /**\n   * Removes and returns the last element\n   */\n  public pop(): OperationResult<T> {\n    if (this.size === 0) {\n      return { success: false, error: 'Array is empty' };\n    }\n\n    const value = this.data[this.size - 1];\n    this.size--;\n    \n    // Shrink array if it's too sparse\n    if (this.size < this.capacity / (this.growthFactor * 2)) {\n      this.resize(Math.max(16, Math.floor(this.capacity / this.growthFactor)));\n    }\n\n    return { success: true, value };\n  }\n\n  /**\n   * Gets element at specified index\n   */\n  public get(index: number): OperationResult<T> {\n    if (index < 0 || index >= this.size) {\n      return { success: false, error: 'Index out of bounds' };\n    }\n    return { success: true, value: this.data[index] };\n  }\n\n  /**\n   * Sets element at specified index\n   */\n  public set(index: number, value: T): OperationResult<T> {\n    if (index < 0 || index >= this.size) {\n      return { success: false, error: 'Index out of bounds' };\n    }\n    \n    const oldValue = this.data[index];\n    this.data[index] = value;\n    this.updateSegmentTree(0, index, value);\n    \n    return { success: true, value: oldValue };\n  }\n\n  /**\n   * Rebuilds the segment tree after major changes\n   */\n  private rebuildSegmentTree(): void {\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\n    if (this.size > 0) {\n      this.buildSegmentTree(0, 0, this.size - 1);\n    }\n  }\n\n  /**\n   * Builds a segment tree node recursively\n   */\n  private buildSegmentTree(node: number, start: number, end: number): void {\n    if (start === end) {\n      this.segmentTree[node] = {\n        value: this.data[start] as T,\n        start,\n        end\n      };\n      return;\n    }\n\n    const mid = Math.floor((start + end) / 2);\n    this.buildSegmentTree(2 * node + 1, start, mid);\n    this.buildSegmentTree(2 * node + 2, mid + 1, end);\n\n    const leftNode = this.segmentTree[2 * node + 1];\n    const rightNode = this.segmentTree[2 * node + 2];\n\n    if (leftNode && rightNode) {\n      this.segmentTree[node] = {\n        value: this.comparator(leftNode.value, rightNode.value) >= 0 \n          ? leftNode.value \n          : rightNode.value,\n        start,\n        end\n      };\n    }\n  }\n\n  /**\n   * Updates the segment tree after a value change\n   */\n  private updateSegmentTree(node: number, index: number, value: T): void {\n    if (!this.segmentTree[node]) {\n      return;\n    }\n\n    const currentNode = this.segmentTree[node]!;\n    if (currentNode.start === currentNode.end) {\n      currentNode.value = value;\n      return;\n    }\n\n    const mid = Math.floor((currentNode.start + currentNode.end) / 2);\n    if (index <= mid) {\n      this.updateSegmentTree(2 * node + 1, index, value);\n    } else {\n      this.updateSegmentTree(2 * node + 2, index, value);\n    }\n\n    const leftNode = this.segmentTree[2 * node + 1];\n    const rightNode = this.segmentTree[2 * node + 2];\n\n    if (leftNode && rightNode) {\n      currentNode.value = this.comparator(leftNode.value, rightNode.value) >= 0 \n        ? leftNode.value \n        : rightNode.value;\n    }\n  }\n\n  /**\n   * Queries the maximum value in a range\n   */\n  public queryRange(start: number, end: number): OperationResult<T> {\n    if (start < 0 || end >= this.size || start > end) {\n      return { success: false, error: 'Invalid range' };\n    }\n\n    const result = this.querySegmentTree(0, start, end);\n    return result \n      ? { success: true, value: result }\n      : { success: false, error: 'Range query failed' };\n  }\n\n  /**\n   * Recursively queries the segment tree\n   */\n  private querySegmentTree(node: number, queryStart: number, queryEnd: number): T | null {\n    const currentNode = this.segmentTree[node];\n    if (!currentNode) {\n      return null;\n    }\n\n    if (queryStart <= currentNode.start && queryEnd >= currentNode.end) {\n      return currentNode.value;\n    }\n\n    if (queryEnd < currentNode.start || queryStart > currentNode.end) {\n      return null;\n    }\n\n    const leftResult = this.querySegmentTree(2 * node + 1, queryStart, queryEnd);\n    const rightResult = this.querySegmentTree(2 * node + 2, queryStart, queryEnd);\n\n    if (leftResult === null) return rightResult;\n    if (rightResult === null) return leftResult;\n\n    return this.comparator(leftResult, rightResult) >= 0 ? leftResult : rightResult;\n  }\n\n  /**\n   * Creates a heap from the current array\n   */\n  public toHeap(isMin: boolean = true): MinHeap<T> | MaxHeap<T> {\n    const heap = isMin \n      ? new MinHeap<T>(this.comparator)\n      : new MaxHeap<T>(this.comparator);\n      \n    for (let i = 0; i < this.size; i++) {\n      if (this.data[i] !== undefined) {\n        if (this.data[i] !== undefined) {\n          heap.push(this.data[i] as T);\n        }\n      }\n    }\n    \n    return heap;\n  }\n\n  /**\n   * Sorts the array in-place\n   */\n  public sort(ascending: boolean = true): void {\n    const heap = this.toHeap(!ascending);\n    for (let i = this.size - 1; i >= 0; i--) {\n      const value = heap.pop();\n      if (value !== undefined) {\n        this.data[i] = value;\n      }\n    }\n    this.rebuildSegmentTree();\n  }\n\n  /**\n   * Returns array as native array\n   */\n  public toArray(): T[] {\n    return this.data.slice(0, this.size);\n  }\n}\n\nexport default BigArray;","import { Comparator } from \"@/core\";\n\n/**\n * Interface for tree node statistics\n */\ninterface NodeStats {\n  height: number;\n  size: number;\n  sum: bigint;\n  min: bigint;\n  max: bigint;\n}\n\n/**\n * Interface for tree traversal configuration\n */\ninterface TraversalConfig {\n  includeStats?: boolean;\n  skipSubtrees?: boolean;\n  maxDepth?: number;\n}\n\n/**\n * Class representing a node in the number tree\n */\nclass NumberNode {\n  value: bigint;\n  left: NumberNode | null;\n  right: NumberNode | null;\n  parent: NumberNode | null;\n  height: number;\n  size: number;\n  sum: bigint;\n\n  constructor(value: bigint | string | number) {\n    this.value = typeof value === 'bigint' ? value : BigInt(value);\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n    this.height = 1;\n    this.size = 1;\n    this.sum = this.value;\n  }\n\n  /**\n   * Updates node statistics based on children\n   */\n  updateStats(): void {\n    this.height = 1 + Math.max(\n      this.left?.height ?? 0,\n      this.right?.height ?? 0\n    );\n    this.size = 1 + (this.left?.size ?? 0) + (this.right?.size ?? 0);\n    this.sum = this.value + \n      (this.left?.sum ?? BigInt(0)) + \n      (this.right?.sum ?? BigInt(0));\n  }\n\n  /**\n   * Gets balance factor of the node\n   */\n  getBalance(): number {\n    return (this.left?.height ?? 0) - (this.right?.height ?? 0);\n  }\n\n  /**\n   * Gets complete statistics for the node and its subtree\n   */\n  getStats(): NodeStats {\n    return {\n      height: this.height,\n      size: this.size,\n      sum: this.sum,\n      min: this.findMin().value,\n      max: this.findMax().value\n    };\n  }\n\n  /**\n   * Finds minimum value node in the subtree\n   */\n  findMin(): NumberNode {\n    let current: NumberNode = this;\n    while (current.left) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  /**\n   * Finds maximum value node in the subtree\n   */\n  findMax(): NumberNode {\n    let current: NumberNode = this;\n    while (current.right) {\n      current = current.right;\n    }\n    return current;\n  }\n}\n\n/**\n * AVL Tree implementation specialized for handling large numbers\n */\nexport class NumberTree {\n  private root: NumberNode | null;\n  private readonly comparator: Comparator<bigint>;\n\n  constructor(comparator?: Comparator<bigint>) {\n    this.root = null;\n    this.comparator = comparator ?? ((a: bigint, b: bigint): -1 | 0 | 1 => {\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    });\n  }\n\n  /**\n   * Gets the root node if it exists\n   */\n  public getRoot(): NumberNode | null {\n    return this.root;\n  }\n\n  /**\n   * Inserts a new value into the tree\n   */\n  public insert(value: bigint | string | number): NumberNode {\n    const newValue = typeof value === 'bigint' ? value : BigInt(value);\n    this.root = this.insertNode(this.root, newValue);\n    return this.find(newValue)!;\n  }\n\n  /**\n   * Recursively inserts a new node\n   */\n  private insertNode(node: NumberNode | null, value: bigint): NumberNode {\n    if (!node) {\n      return new NumberNode(value);\n    }\n\n    const compareResult = this.comparator(value, node.value);\n    if (compareResult < 0) {\n      node.left = this.insertNode(node.left, value);\n      node.left.parent = node;\n    } else if (compareResult > 0) {\n      node.right = this.insertNode(node.right, value);\n      node.right.parent = node;\n    } else {\n      return node; // Duplicate value, return existing node\n    }\n\n    node.updateStats();\n    return this.balance(node);\n  }\n\n  /**\n   * Balances a node using AVL rotations\n   */\n  private balance(node: NumberNode): NumberNode {\n    const balance = node.getBalance();\n\n    // Left heavy\n    if (balance > 1) {\n      if (node.left && node.left.getBalance() < 0) {\n        node.left = this.rotateLeft(node.left);\n      }\n      return this.rotateRight(node);\n    }\n\n    // Right heavy\n    if (balance < -1) {\n      if (node.right && node.right.getBalance() > 0) {\n        node.right = this.rotateRight(node.right);\n      }\n      return this.rotateLeft(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Performs left rotation\n   */\n  private rotateLeft(node: NumberNode): NumberNode {\n    const rightChild = node.right!;\n    const rightLeftChild = rightChild.left;\n\n    rightChild.left = node;\n    node.right = rightLeftChild;\n\n    if (rightLeftChild) {\n      rightLeftChild.parent = node;\n    }\n    rightChild.parent = node.parent;\n    node.parent = rightChild;\n\n    node.updateStats();\n    rightChild.updateStats();\n\n    return rightChild;\n  }\n\n  /**\n   * Performs right rotation\n   */\n  private rotateRight(node: NumberNode): NumberNode {\n    const leftChild = node.left!;\n    const leftRightChild = leftChild.right;\n\n    leftChild.right = node;\n    node.left = leftRightChild;\n\n    if (leftRightChild) {\n      leftRightChild.parent = node;\n    }\n    leftChild.parent = node.parent;\n    node.parent = leftChild;\n\n    node.updateStats();\n    leftChild.updateStats();\n\n    return leftChild;\n  }\n\n  /**\n   * Removes a value from the tree\n   */\n  public remove(value: bigint | string | number): boolean {\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\n    const nodeToRemove = this.find(searchValue);\n    \n    if (!nodeToRemove) {\n      return false;\n    }\n\n    this.root = this.removeNode(this.root, searchValue);\n    return true;\n  }\n\n  /**\n   * Recursively removes a node\n   */\n  private removeNode(node: NumberNode | null, value: bigint): NumberNode | null {\n    if (!node) {\n      return null;\n    }\n\n    const compareResult = this.comparator(value, node.value);\n    if (compareResult < 0) {\n      node.left = this.removeNode(node.left, value);\n      if (node.left) {\n        node.left.parent = node;\n      }\n    } else if (compareResult > 0) {\n      node.right = this.removeNode(node.right, value);\n      if (node.right) {\n        node.right.parent = node;\n      }\n    } else {\n      // Node to delete found\n      if (!node.left) {\n        return node.right;\n      }\n      if (!node.right) {\n        return node.left;\n      }\n\n      // Node has two children\n      const successor = node.right.findMin();\n      node.value = successor.value;\n      node.right = this.removeNode(node.right, successor.value);\n      if (node.right) {\n        node.right.parent = node;\n      }\n    }\n\n    node.updateStats();\n    return this.balance(node);\n  }\n\n  /**\n   * Finds a node by value\n   */\n  public find(value: bigint | string | number): NumberNode | null {\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\n    let current = this.root;\n\n    while (current) {\n      const compareResult = this.comparator(searchValue, current.value);\n      if (compareResult === 0) {\n        return current;\n      }\n      current = compareResult < 0 ? current.left : current.right;\n    }\n\n    return null;\n  }\n\n  /**\n   * Traverses the tree in specified order and returns values\n   */\n  public traverse(order: 'inOrder' | 'preOrder' | 'postOrder' = 'inOrder', \n                 config: TraversalConfig = {}): bigint[] {\n    const result: bigint[] = [];\n    \n    const traverse = (node: NumberNode | null, depth: number = 0): void => {\n      if (!node || (config.maxDepth !== undefined && depth >= config.maxDepth)) {\n        return;\n      }\n\n      if (order === 'preOrder') {\n        result.push(node.value);\n      }\n\n      if (!config.skipSubtrees) {\n        traverse(node.left, depth + 1);\n      }\n\n      if (order === 'inOrder') {\n        result.push(node.value);\n      }\n\n      if (!config.skipSubtrees) {\n        traverse(node.right, depth + 1);\n      }\n\n      if (order === 'postOrder') {\n        result.push(node.value);\n      }\n    };\n\n    traverse(this.root);\n    return result;\n  }\n\n  /**\n   * Gets overall tree statistics\n   */\n  public getTreeStats(): NodeStats | null {\n    return this.root?.getStats() ?? null;\n  }\n\n  /**\n   * Gets the nth smallest value in the tree\n   */\n  public getNthValue(n: number): bigint | null {\n    if (!this.root || n < 1 || n > this.root.size) {\n      return null;\n    }\n\n    const findNth = (node: NumberNode | null, position: number): bigint | null => {\n      if (!node) {\n        return null;\n      }\n\n      const leftSize = node.left?.size ?? 0;\n      \n      if (position === leftSize + 1) {\n        return node.value;\n      }\n      \n      if (position <= leftSize) {\n        return findNth(node.left, position);\n      }\n      \n      return findNth(node.right, position - leftSize - 1);\n    };\n\n    return findNth(this.root, n);\n  }\n\n  /**\n   * Gets a range of values between start and end (inclusive)\n   */\n  public getRange(start: bigint | string | number, \n                 end: bigint | string | number): bigint[] {\n    const startValue = typeof start === 'bigint' ? start : BigInt(start);\n    const endValue = typeof end === 'bigint' ? end : BigInt(end);\n    const result: bigint[] = [];\n\n    const collectRange = (node: NumberNode | null): void => {\n      if (!node) {\n        return;\n      }\n\n      if (this.comparator(node.value, startValue) >= 0 && \n          this.comparator(node.value, endValue) <= 0) {\n        collectRange(node.left);\n        result.push(node.value);\n        collectRange(node.right);\n      } else if (this.comparator(node.value, startValue) > 0) {\n        collectRange(node.left);\n      } else {\n        collectRange(node.right);\n      }\n    };\n\n    collectRange(this.root);\n    return result;\n  }\n}\n\nexport default NumberTree;","import { validateNonNegative, ValidationError, OverflowError } from '../utils/validation';\n\n/**\n * Interface for power tower computation options\n */\ninterface PowerTowerOptions {\n  maxHeight?: number;\n  maxValue?: bigint;\n  checkOverflow?: boolean;\n  precision?: number;\n}\n\n/**\n * Interface for power tower node to track computation state\n */\ninterface PowerTowerNode {\n  value: bigint;\n  height: number;\n  evaluated: boolean;\n  previous: PowerTowerNode | null;\n  next: PowerTowerNode | null;\n}\n\n/**\n * Default options for power tower computations\n */\nconst DEFAULT_OPTIONS: Required<PowerTowerOptions> = {\n  maxHeight: 100,\n  maxValue: BigInt(Number.MAX_SAFE_INTEGER),\n  checkOverflow: true,\n  precision: 0\n};\n\n/**\n * Class representing a power tower (tetration) computation structure\n * Handles expressions of the form: ab = a^(a^(a^...)) (b times)\n */\nexport class PowerTower {\n  private readonly options: Required<PowerTowerOptions>;\n  private head: PowerTowerNode | null;\n  private tail: PowerTowerNode | null;\n  private size: number;\n\n  constructor(options: PowerTowerOptions = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  /**\n   * Creates a new power tower node\n   */\n  private createNode(value: bigint, height: number): PowerTowerNode {\n    return {\n      value,\n      height,\n      evaluated: false,\n      previous: null,\n      next: null\n    };\n  }\n\n  /**\n   * Validates power tower height\n   */\n  private validateHeight(height: number): void {\n    if (height < 0) {\n      throw new ValidationError('Height cannot be negative');\n    }\n    if (height > this.options.maxHeight) {\n      throw new ValidationError(`Height exceeds maximum of ${this.options.maxHeight}`);\n    }\n  }\n\n  /**\n   * Validates value for computation\n   */\n  private validateValue(value: bigint): void {\n    validateNonNegative(value);\n    if (this.options.checkOverflow && value > this.options.maxValue) {\n      throw new OverflowError(`Value exceeds maximum of ${this.options.maxValue}`);\n    }\n  }\n\n  /**\n   * Computes power with overflow checking\n   */\n  private computePower(base: bigint, exponent: bigint): bigint {\n    if (exponent === BigInt(0)) {\n      return BigInt(1);\n    }\n    if (exponent === BigInt(1)) {\n      return base;\n    }\n\n    let result = base;\n    for (let i = BigInt(1); i < exponent; i++) {\n      if (this.options.checkOverflow) {\n        // Check if next multiplication would overflow\n        const next = result * base;\n        if (next > this.options.maxValue) {\n          throw new OverflowError('Power computation would overflow');\n        }\n        result = next;\n      } else {\n        result *= base;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Builds a power tower of specified height with given base\n   */\n  public build(base: bigint | number | string, height: number): void {\n    this.validateHeight(height);\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\n    this.validateValue(baseValue);\n\n    this.clear(); // Clear existing tower\n\n    for (let i = 0; i < height; i++) {\n      const node = this.createNode(baseValue, i + 1);\n      if (!this.head) {\n        this.head = node;\n        this.tail = node;\n      } else {\n        node.previous = this.tail;\n        this.tail!.next = node;\n        this.tail = node;\n      }\n      this.size++;\n    }\n  }\n\n  /**\n   * Evaluates the power tower up to specified height\n   */\n  public evaluate(height?: number): bigint {\n    if (!this.head) {\n      return BigInt(1); // Empty tower evaluates to 1\n    }\n\n    const targetHeight = height ?? this.size;\n    this.validateHeight(targetHeight);\n\n    let current = this.head;\n    let result = current.value;\n    let currentHeight = 1;\n\n    try {\n      while (current.next && currentHeight < targetHeight) {\n        result = this.computePower(current.next.value, result);\n        current.evaluated = true;\n        current = current.next;\n        currentHeight++;\n      }\n      current.evaluated = true;\n      return result;\n    } catch (error) {\n      if (error instanceof OverflowError) {\n        // Mark nodes up to current height as evaluated\n        let node = this.head;\n        while (node !== current) {\n          node.evaluated = true;\n          node = node.next!;\n        }\n        throw error;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the current height of the power tower\n   */\n  public getHeight(): number {\n    return this.size;\n  }\n\n  /**\n   * Checks if the tower can be evaluated to a given height\n   */\n  public isComputable(height?: number): boolean {\n    try {\n      const targetHeight = height ?? this.size;\n      this.validateHeight(targetHeight);\n      \n      // Check first few levels without full computation\n      let current = this.head;\n      let currentHeight = 0;\n      \n      while (current && currentHeight < targetHeight) {\n        // Quick check for obvious overflow conditions\n        if (current.value > BigInt(4) && currentHeight > 3) {\n          return false;\n        }\n        current = current.next;\n        currentHeight++;\n      }\n      \n      // Try actual computation with a lower overflow threshold\n      const safeOptions = { ...this.options, maxValue: this.options.maxValue >> BigInt(1) };\n      const safeTower = new PowerTower(safeOptions);\n      safeTower.build(this.head!.value, targetHeight);\n      safeTower.evaluate();\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the computation state at each level\n   */\n  public getState(): { height: number; value: bigint; evaluated: boolean }[] {\n    const state = [];\n    let current = this.head;\n    \n    while (current) {\n      state.push({\n        height: current.height,\n        value: current.value,\n        evaluated: current.evaluated\n      });\n      current = current.next;\n    }\n    \n    return state;\n  }\n\n  /**\n   * Clears the power tower\n   */\n  public clear(): void {\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  /**\n   * Gets the maximum computationally feasible height for a given base\n   */\n  public static getMaxFeasibleHeight(base: bigint | number | string): number {\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\n    validateNonNegative(baseValue);\n\n    if (baseValue === BigInt(0)) return 0;\n    if (baseValue === BigInt(1)) return Infinity;\n    if (baseValue === BigInt(2)) return 4; // 24 is already enormous\n    if (baseValue === BigInt(3)) return 3; // 33 is already astronomical\n    if (baseValue === BigInt(4)) return 2;\n    return 1; // For bases > 4, only height 1 is reliably computable\n  }\n\n  /**\n   * Creates a string representation of the power tower\n   */\n  public toString(): string {\n    if (!this.head) {\n      return \"Empty Tower\";\n    }\n\n    let result = this.head.value.toString();\n    let current = this.head;\n    \n    while (current.next) {\n      result = `${current.next.value}^(${result})`;\n      current = current.next;\n    }\n    \n    return result;\n  }\n}\n\nexport default PowerTower;","/**\n * Formatting utilities for Hypernum library\n * Provides functions for formatting large numbers and converting between different representations\n */\n\nimport { ValidationError } from './validation';\n\n// Types for formatting options\nexport interface FormatOptions {\n  notation?: 'standard' | 'scientific' | 'engineering' | 'compact';\n  precision?: number;\n  grouping?: boolean;\n  groupSize?: number;\n  decimalSeparator?: string;\n  groupSeparator?: string;\n}\n\nexport interface ScientificNotation {\n  coefficient: string;\n  exponent: number;\n}\n\nexport interface ScientificNotation {\n  coefficient: string;\n  exponent: number;\n}\n\n// Default formatting options\nconst DEFAULT_OPTIONS: Required<FormatOptions> = {\n  notation: 'standard',\n  precision: 0,\n  grouping: true,\n  groupSize: 3,\n  decimalSeparator: '.',\n  groupSeparator: ',',\n};\n\n/**\n * Formats a BigInt value according to specified options\n */\nexport const formatBigInt = (value: bigint, options: FormatOptions = {}): string => {\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\n  \n  // Handle negative numbers\n  const isNegative = value < BigInt(0);\n  const absValue = isNegative ? -value : value;\n  \n  let result: string;\n  switch (opts.notation) {\n    case 'scientific':\n      result = formatScientific(absValue, opts).coefficient + 'e' + \n               formatScientific(absValue, opts).exponent;\n      break;\n    case 'engineering':\n      result = formatEngineering(absValue, opts);\n      break;\n    case 'compact':\n      result = formatCompact(absValue, opts);\n      break;\n    default:\n      result = formatStandard(absValue, opts);\n  }\n  \n  return isNegative ? '-' + result : result;\n};\n\n/**\n * Formats a number in standard notation with grouping\n */\nconst formatStandard = (value: bigint, options: Required<FormatOptions>): string => {\n  let str = value.toString();\n  \n  if (!options.grouping) {\n    return str;\n  }\n  \n  // Apply grouping from the right\n  const result: string[] = [];\n  let position = str.length;\n  \n  while (position > 0) {\n    const start = Math.max(0, position - options.groupSize);\n    result.unshift(str.slice(start, position));\n    position = start;\n  }\n  \n  return result.join(options.groupSeparator);\n};\n\n/**\n * Converts a number to scientific notation\n */\nconst formatScientific = (value: bigint, options: Required<FormatOptions>): ScientificNotation => {\n  if (value === BigInt(0)) {\n    return { coefficient: '0', exponent: 0 };\n  }\n  \n  const str = value.toString();\n  const exponent = str.length - 1;\n  \n  let coefficient = str[0] || '';\n  coefficient += options.decimalSeparator + str.slice(1, options.precision + 1);\n  \n  return {\n    coefficient: coefficient,\n    exponent: exponent,\n  };\n};\n\n/**\n * Formats a number in engineering notation (exponents divisible by 3)\n */\nconst formatEngineering = (value: bigint, options: Required<FormatOptions>): string => {\n  if (value === BigInt(0)) {\n    return '0';\n  }\n  \n  const str = value.toString();\n  const len = str.length;\n  const exponent = Math.floor((len - 1) / 3) * 3;\n  \n  let coefficient = '';\n  const digitsBeforePoint = len - exponent;\n  \n  for (let i = 0; i < Math.min(len, digitsBeforePoint + options.precision); i++) {\n    if (i === digitsBeforePoint && i < len) {\n      coefficient += options.decimalSeparator;\n    }\n    coefficient += str[i];\n  }\n  \n  return `${coefficient}e${exponent}`;\n};\n\n/**\n * Formats a number in compact notation (K, M, B, T)\n */\nconst formatCompact = (value: bigint, options: Required<FormatOptions>): string => {\n  const suffixes = ['', 'K', 'M', 'B', 'T', 'Q'];\n  const str = value.toString();\n  const len = str.length;\n  \n  if (len <= 3) {\n    return formatStandard(value, options);\n  }\n  \n  const suffixIndex = Math.min(Math.floor((len - 1) / 3), suffixes.length - 1);\n  const suffix = suffixes[suffixIndex];\n  \n  const scale = BigInt(10) ** BigInt(suffixIndex * 3);\n  const scaledValue = value / scale;\n  \n  let result = scaledValue.toString();\n  if (options.precision > 0) {\n    const remainder = value % scale;\n    if (remainder > BigInt(0)) {\n      const decimalPart = remainder.toString().padStart(3, '0').slice(0, options.precision);\n      result += options.decimalSeparator + decimalPart;\n    }\n  }\n  \n  return result + suffix;\n};\n\n/**\n * Parses a formatted string back to BigInt\n */\nexport const parseBigIntString = (str: string, options: FormatOptions = {}): bigint => {\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\n  \n  // Remove grouping separators\n  let cleanStr = str.replace(new RegExp(`\\\\${opts.groupSeparator}`, 'g'), '');\n  \n  // Handle scientific notation\n  if (cleanStr.toLowerCase().includes('e')) {\n    const [coefficient, exponent] = cleanStr.toLowerCase().split('e');\n    const base = BigInt(10);\n    const exp = BigInt(exponent || '0');\n    return BigInt(Math.floor(Number(coefficient))) * (base ** exp);\n  }\n  \n  // Handle suffixes\n  const suffixMap = new Map([\n    ['k', BigInt(1000)],\n    ['m', BigInt(1000000)],\n    ['b', BigInt(1000000000)],\n    ['t', BigInt(1000000000000)],\n    ['q', BigInt(1000000000000000)],\n  ]);\n  \n  const suffix = cleanStr.slice(-1).toLowerCase();\n  const multiplier = suffixMap.get(suffix);\n  if (multiplier) {\n    cleanStr = cleanStr.slice(0, -1);\n    const value = BigInt(Math.floor(Number(cleanStr)));\n    return value * multiplier;\n  }\n  \n  // Handle regular numbers\n  return BigInt(cleanStr);\n};\n\n/**\n * Normalizes a string representation for comparison\n */\nexport const normalizeNumberString = (str: string): string => {\n  // Remove all spaces and separators\n  str = str.replace(/[\\s,]/g, '');\n  \n  // Handle scientific notation\n  if (str.toLowerCase().includes('e')) {\n    const [coefficient, exponent] = str.toLowerCase().split('e');\n    const exp = parseInt(exponent || '0');\n    const coef = parseFloat(coefficient || '0');\n    return (coef * Math.pow(10, exp)).toString();\n  }\n  \n  return str;\n};\n\n/**\n * Formats a number for display in a tree structure\n */\nexport const formatTreeValue = (value: bigint, depth: number = 0): string => {\n  const indent = '  '.repeat(depth);\n  return `${indent}${formatBigInt(value, { notation: 'compact' })}`;\n};\n\n/**\n * Formats a range of numbers for display\n */\nexport const formatRange = (start: bigint, end: bigint, options: FormatOptions = {}): string => {\n  return `[${formatBigInt(start, options)} ... ${formatBigInt(end, options)}]`;\n};\n\n/**\n * Formats a percentage\n */\nexport const formatPercentage = (value: bigint, total: bigint, precision: number = 2): string => {\n  if (total === BigInt(0)) {\n    throw new ValidationError('Cannot calculate percentage with zero total');\n  }\n  \n  const percentage = (Number(value) * 100) / Number(total);\n  return `${percentage.toFixed(precision)}%`;\n};","/**\n * Main Hypernum class that provides a high-level interface to all library functionality\n */\n\n\nimport {\n  DEFAULT_OPTIONS,\n  FEATURES,\n  MAX_PRECISION,\n  MAX_COMPUTATION_STEPS\n} from './constants';\nimport { \n  HypernumError, \n  ValidationError, \n  OverflowError \n} from './errors';\n\n\n// Import all operations and structures\nimport * as arithmetic from '../operations/arithmetic';\nimport * as bitwise from '../operations/bitwise';\nimport * as power from '../operations/power';\nimport { BigArray, NumberTree, AckermannStructure } from '../structures';\nimport * as formatting from '../utils/formatting';\nimport * as validation from '../utils/validation';\nimport * as precision from '../utils/precision';\nimport { MinHeap, MaxHeap } from '@/storage';\n/**\n * Configuration options for Hypernum instance\n */\nexport interface HypernumConfig {\n  precision?: number;\n  roundingMode?: precision.RoundingMode;\n  checkOverflow?: boolean;\n  maxSteps?: number;\n  debug?: boolean;\n}\n\nexport class Hypernum {\n  private readonly config: Required<HypernumConfig>;\n  private readonly structures: {\n    arrays: Map<string, BigArray<bigint>>;\n    trees: Map<string, NumberTree>;\n    heaps: Map<string, MinHeap<bigint> | MaxHeap<bigint>>;\n  };\n\n  constructor(config: HypernumConfig = {}) {\n    this.config = {\n      precision: config.precision ?? DEFAULT_OPTIONS.precision,\n      roundingMode: config.roundingMode ?? DEFAULT_OPTIONS.roundingMode as precision.RoundingMode,\n      checkOverflow: config.checkOverflow ?? DEFAULT_OPTIONS.checkOverflow,\n      maxSteps: config.maxSteps ?? DEFAULT_OPTIONS.maxSteps,\n      debug: config.debug ?? FEATURES.DEBUG_MODE\n    };\n\n    // Validate configuration\n    if (this.config.precision < 0 || this.config.precision > MAX_PRECISION) {\n      throw new ValidationError(`Precision must be between 0 and ${MAX_PRECISION}`);\n    }\n    if (this.config.maxSteps < 1 || this.config.maxSteps > MAX_COMPUTATION_STEPS) {\n      throw new ValidationError(`Max steps must be between 1 and ${MAX_COMPUTATION_STEPS}`);\n    }\n\n    // Initialize data structure storage\n    this.structures = {\n      arrays: new Map(),\n      trees: new Map(),\n      heaps: new Map()\n    };\n  }\n\n  // Arithmetic Operations\n  public add(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.add(a, b, this.config);\n  }\n\n  public subtract(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.subtract(a, b, this.config);\n  }\n\n  public multiply(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.multiply(a, b, this.config);\n  }\n\n  public divide(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.divide(a, b, this.config);\n  }\n\n  public mod(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.remainder(a, b, this.config);\n  }\n\n  // Power Operations\n  public power(base: bigint | string | number, exponent: bigint | string | number): bigint {\n    return power.power(base, exponent, this.config);\n  }\n\n  public sqrt(value: bigint | string | number): bigint {\n    return power.sqrt(value, this.config);\n  }\n\n  public nthRoot(value: bigint | string | number, n: bigint | string | number): bigint {\n    return power.nthRoot(value, n, this.config);\n  }\n\n  // Bitwise Operations\n  public and(a: bigint | string | number, b: bigint | string | number): bigint {\n    return bitwise.and(a, b);\n  }\n\n  public or(a: bigint | string | number, b: bigint | string | number): bigint {\n    return bitwise.or(a, b);\n  }\n\n  public xor(a: bigint | string | number, b: bigint | string | number): bigint {\n    return bitwise.xor(a, b);\n  }\n\n  public not(value: bigint | string | number): bigint {\n    return bitwise.not(value);\n  }\n /**\n   * Calculates the greatest common divisor of two numbers\n   */\n public gcd(a: bigint | string | number, b: bigint | string | number): bigint {\n  return arithmetic.gcd(a, b);\n}\n\n/**\n * Calculates the least common multiple of two numbers\n */\npublic lcm(a: bigint | string | number, b: bigint | string | number): bigint {\n  return arithmetic.lcm(a, b);\n}\n  // Data Structure Management\n  public createArray(id: string): BigArray<bigint> {\n    if (this.structures.arrays.has(id)) {\n      throw new ValidationError(`Array with id '${id}' already exists`);\n    }\n    const array = new BigArray<bigint>();\n    this.structures.arrays.set(id, array);\n    return array;\n  }\n\n  public getArray(id: string): BigArray<bigint> {\n    const array = this.structures.arrays.get(id);\n    if (!array) {\n      throw new ValidationError(`Array with id '${id}' not found`);\n    }\n    return array;\n  }\n\n  public createTree(id: string): NumberTree {\n    if (this.structures.trees.has(id)) {\n      throw new ValidationError(`Tree with id '${id}' already exists`);\n    }\n    const tree = new NumberTree();\n    this.structures.trees.set(id, tree);\n    return tree;\n  }\n\n  public getTree(id: string): NumberTree {\n    const tree = this.structures.trees.get(id);\n    if (!tree) {\n      throw new ValidationError(`Tree with id '${id}' not found`);\n    }\n    return tree;\n  }\n\n  public createHeap(id: string, isMinHeap: boolean = true): MinHeap<bigint> | MaxHeap<bigint> {\n    if (this.structures.heaps.has(id)) {\n      throw new ValidationError(`Heap with id '${id}' already exists`);\n    }\n    const heap = isMinHeap ? new MinHeap<bigint>(this.compareValues) : new MaxHeap<bigint>(this.compareValues);\n    this.structures.heaps.set(id, heap);\n    return heap;\n  }\n\n  public getHeap(id: string): MinHeap<bigint> | MaxHeap<bigint> {\n    const heap = this.structures.heaps.get(id);\n    if (!heap) {\n      throw new ValidationError(`Heap with id '${id}' not found`);\n    }\n    return heap;\n  }\n\n  // Special Functions\n  public createAckermannStructure(): AckermannStructure {\n    return new AckermannStructure();\n  }\n\n  // Formatting and Validation\n  public format(value: bigint | string | number, options?: formatting.FormatOptions): string {\n    const bigValue = validation.toBigInt(value);\n    return formatting.formatBigInt(bigValue, options);\n  }\n\n  public validate(value: unknown): boolean {\n    try {\n      validation.toBigInt(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  // Configuration Management\n  public updateConfig(newConfig: Partial<HypernumConfig>): void {\n    Object.assign(this.config, newConfig);\n  }\n\n  public getConfig(): Readonly<Required<HypernumConfig>> {\n    return { ...this.config };\n  }\n\n  // Utility Functions\n  private compareValues(a: bigint, b: bigint): -1 | 0 | 1 {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  }\n\n  // Cleanup\n  public dispose(): void {\n    this.structures.arrays.clear();\n    this.structures.trees.clear();\n    this.structures.heaps.clear();\n  }\n}\n\n// Export additional types and utilities\nexport {\n  HypernumError,\n  ValidationError,\n  OverflowError,\n  precision,\n  formatting,\n  validation\n};\n\nexport default Hypernum;","/**\n * Comparison operations module for Hypernum library\n * Provides functions for comparing large numbers with precision support\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n    normalizePrecision,\n  } from '../utils/precision';\n  \n  /**\n   * Options for comparison operations\n   */\n  export interface ComparisonOptions {\n    precision?: number;\n    roundingMode?: RoundingMode;\n    tolerance?: number;\n  }\n  \n  const DEFAULT_OPTIONS: Required<ComparisonOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    tolerance: 0\n  };\n  \n  /**\n   * Result type for comparison operations\n   * -1: first value is less than second value\n   *  0: values are equal\n   *  1: first value is greater than second value\n   */\n  export type ComparisonResult = -1 | 0 | 1;\n  \n  /**\n   * Compares two numbers with optional precision\n   */\n  export function compare(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): ComparisonResult {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.precision === 0 && opts.tolerance === 0) {\n      if (bigA < bigB) return -1;\n      if (bigA > bigB) return 1;\n      return 0;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    \n    if (opts.tolerance > 0) {\n      const diff = scaledA - scaledB;\n      const toleranceValue = BigInt(10) ** BigInt(opts.tolerance);\n      \n      if (diff < -toleranceValue) return -1;\n      if (diff > toleranceValue) return 1;\n      return 0;\n    }\n  \n    if (scaledA < scaledB) return -1;\n    if (scaledA > scaledB) return 1;\n    return 0;\n  }\n  \n  /**\n   * Checks if two numbers are equal\n   */\n  export function equals(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return compare(a, b, options) === 0;\n  }\n  \n  /**\n   * Checks if first number is less than second\n   */\n  export function lessThan(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return compare(a, b, options) === -1;\n  }\n  \n  /**\n   * Checks if first number is less than or equal to second\n   */\n  export function lessThanOrEqual(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    const result = compare(a, b, options);\n    return result === -1 || result === 0;\n  }\n  \n  /**\n   * Checks if first number is greater than second\n   */\n  export function greaterThan(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return compare(a, b, options) === 1;\n  }\n  \n  /**\n   * Checks if first number is greater than or equal to second\n   */\n  export function greaterThanOrEqual(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    const result = compare(a, b, options);\n    return result === 1 || result === 0;\n  }\n  \n  /**\n   * Checks if a number is between two others (inclusive)\n   */\n  export function between(\n    value: bigint | string | number,\n    min: bigint | string | number,\n    max: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return greaterThanOrEqual(value, min, options) && lessThanOrEqual(value, max, options);\n  }\n  \n  /**\n   * Finds the maximum value in an array of numbers\n   */\n  export function max(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): bigint {\n    if (values.length === 0) {\n      throw new ValidationError('Cannot find maximum of empty array');\n    }\n  \n    return values.reduce<bigint>((max, current) => {\n      const bigMax = toBigInt(max);\n      const bigCurrent = toBigInt(current);\n      return greaterThan(bigCurrent, bigMax, options) ? bigCurrent : bigMax;\n    }, toBigInt(values[0]));\n  }\n  \n  /**\n   * Finds the minimum value in an array of numbers\n   */\n  export function min(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): bigint {\n    if (values.length === 0) {\n      throw new ValidationError('Cannot find minimum of empty array');\n    }\n  \n    return values.reduce<bigint>((min, current) => {\n      const bigMin = toBigInt(min);\n      const bigCurrent = toBigInt(current);\n      return lessThan(bigCurrent, bigMin, options) ? bigCurrent : bigMin;\n    }, toBigInt(values[0]));\n  }\n  \n  /**\n   * Clamps a value between minimum and maximum bounds\n   */\n  export function clamp(\n    value: bigint | string | number,\n    min: bigint | string | number,\n    max: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): bigint {\n    const bigValue = toBigInt(value);\n    const bigMin = toBigInt(min);\n    const bigMax = toBigInt(max);\n  \n    if (lessThan(bigMax, bigMin, options)) {\n      throw new ValidationError('Maximum bound must be greater than or equal to minimum bound');\n    }\n  \n    if (lessThan(bigValue, bigMin, options)) return bigMin;\n    if (greaterThan(bigValue, bigMax, options)) return bigMax;\n    return bigValue;\n  }\n  \n  /**\n   * Checks if all values in array are equal within tolerance\n   */\n  export function allEqual(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): boolean {\n    if (values.length <= 1) return true;\n  \n    const first = toBigInt(values[0]);\n    return values.every(value => equals(value, first, options));\n  }\n  \n  /**\n   * Checks if values are in ascending order\n   */\n  export function isAscending(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): boolean {\n    if (values.length <= 1) return true;\n  \n    for (let i = 1; i < values.length; i++) {\n      if (values[i] === undefined || values[i - 1] === undefined || !greaterThanOrEqual(values[i]!, values[i - 1]!, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Checks if values are in descending order\n   */\n  export function isDescending(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): boolean {\n    if (values.length <= 1) return true;\n  \n    for (let i = 1; i < values.length; i++) {\n      if (values[i] === undefined || values[i - 1] === undefined || !lessThanOrEqual(values[i]!, values[i - 1]!, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Creates a comparator function for sorting\n   */\n  export function createComparator(\n    options: ComparisonOptions = {}\n  ): (a: bigint | string | number, b: bigint | string | number) => number {\n    return (a, b) => compare(a, b, options);\n  }\n  \n  export default {\n    compare,\n    equals,\n    lessThan,\n    lessThanOrEqual,\n    greaterThan,\n    greaterThanOrEqual,\n    between,\n    max,\n    min,\n    clamp,\n    allEqual,\n    isAscending,\n    isDescending,\n    createComparator\n  };","/**\n * Conversion operations module for Hypernum library\n * Provides functions for converting numbers between different formats and bases\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n\n  } from '../utils/precision';\n  \n  /**\n   * Options for conversion operations\n   */\n  export interface ConversionOptions {\n    /** Precision for decimal operations */\n    precision?: number;\n    /** Rounding mode for decimal operations */\n    roundingMode?: RoundingMode;\n    /** Whether to use uppercase for hex/base-N output */\n    uppercase?: boolean;\n    /** Whether to add prefix for base-N output (0x, 0b, etc.) */\n    prefix?: boolean;\n    /** Minimum number of digits (pad with zeros) */\n    minDigits?: number;\n  }\n  \n  const DEFAULT_OPTIONS: Required<ConversionOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    uppercase: false,\n    prefix: false,\n    minDigits: 1\n  };\n  \n  /**\n   * Converts number to binary string representation\n   */\n  export function toBinary(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let binary = bigValue.toString(2);\n    \n    // Pad with zeros if needed\n    while (binary.length < opts.minDigits) {\n      binary = '0' + binary;\n    }\n    \n    return opts.prefix ? '0b' + binary : binary;\n  }\n  \n  /**\n   * Converts number to octal string representation\n   */\n  export function toOctal(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let octal = bigValue.toString(8);\n    \n    while (octal.length < opts.minDigits) {\n      octal = '0' + octal;\n    }\n    \n    return opts.prefix ? '0o' + octal : octal;\n  }\n  \n  /**\n   * Converts number to hexadecimal string representation\n   */\n  export function toHexadecimal(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let hex = bigValue.toString(16);\n    \n    if (opts.uppercase) {\n      hex = hex.toUpperCase();\n    }\n    \n    while (hex.length < opts.minDigits) {\n      hex = '0' + hex;\n    }\n    \n    return opts.prefix ? '0x' + hex : hex;\n  }\n  \n  /**\n   * Converts number to string in specified base\n   */\n  export function toBase(\n    value: bigint | string | number,\n    base: number,\n    options: ConversionOptions = {}\n  ): string {\n    if (base < 2 || base > 36) {\n      throw new ValidationError('Base must be between 2 and 36');\n    }\n    \n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let result = bigValue.toString(base);\n    \n    if (opts.uppercase) {\n      result = result.toUpperCase();\n    }\n    \n    while (result.length < opts.minDigits) {\n      result = '0' + result;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Converts string from specified base to bigint\n   */\n  export function fromBase(\n    value: string,\n    base: number\n  ): bigint {\n    if (base < 2 || base > 36) {\n      throw new ValidationError('Base must be between 2 and 36');\n    }\n    \n    // Remove base prefixes if present\n    const cleanValue = value.toLowerCase()\n      .replace(/^0x/, '')  // hex\n      .replace(/^0b/, '')  // binary\n      .replace(/^0o/, ''); // octal\n    \n    try {\n      return BigInt(`${base}n${cleanValue}`);\n    } catch (error) {\n      throw new ValidationError(`Invalid number format for base ${base}: ${value}`);\n    }\n  }\n  \n  /**\n   * Converts decimal string to fraction representation\n   */\n  export function toFraction(\n    value: string,\n  ): [bigint, bigint] {\n    \n    // Split into integer and decimal parts\n    const [intPart, decPart = ''] = value.split('.');\n    \n    if (!decPart) {\n      return [toBigInt(intPart), 1n];\n    }\n    \n    // Convert decimal to fraction\n    const numerator = toBigInt(intPart + decPart);\n    const denominator = 10n ** BigInt(decPart.length);\n    \n    // Simplify fraction\n    const gcd = calculateGCD(numerator, denominator);\n    \n    return [numerator / gcd, denominator / gcd];\n  }\n  \n  /**\n   * Converts fraction to decimal string with specified precision\n   */\n  export function fromFraction(\n    numerator: bigint | string | number,\n    denominator: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigNumerator = toBigInt(numerator);\n    const bigDenominator = toBigInt(denominator);\n    \n    if (bigDenominator === 0n) {\n      throw new ValidationError('Denominator cannot be zero');\n    }\n    \n    const quotient = bigNumerator / bigDenominator;\n    const remainder = bigNumerator % bigDenominator;\n    \n    if (remainder === 0n || opts.precision === 0) {\n      return quotient.toString();\n    }\n    \n    // Calculate decimal part\n    const scaleFactor = 10n ** BigInt(opts.precision);\n    const scaledRemainder = (remainder * scaleFactor) / bigDenominator;\n    \n    return `${quotient}.${scaledRemainder.toString().padStart(opts.precision, '0')}`;\n  }\n  \n  /**\n   * Converts scientific notation to decimal string\n   */\n  export function fromScientific(\n    value: string,\n  ): string {\n    \n    // Parse scientific notation format\n    const match = value.match(/^(-?\\d+\\.?\\d*)[eE]([+-]?\\d+)$/);\n    if (!match) {\n      throw new ValidationError('Invalid scientific notation format');\n    }\n    \n    const [, significand, exponent] = match;\n    const exp = parseInt(exponent || '0', 10);\n    \n    // Convert to regular decimal\n    if (exp >= 0) {\n      if (significand === undefined) {\n        throw new ValidationError('Invalid scientific notation format');\n      }\n      return (BigInt(significand.replace('.', '')) * (10n ** BigInt(exp))).toString();\n    } else {\n      const absExp = Math.abs(exp);\n      if (significand === undefined) {\n        throw new ValidationError('Invalid scientific notation format');\n      }\n      const scaledValue = BigInt(significand.replace('.', ''));\n      return (scaledValue / (10n ** BigInt(absExp))).toString();\n    }\n  }\n  \n  /**\n   * Converts decimal to scientific notation\n   */\n  export function toScientific(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    if (bigValue === 0n) {\n      return '0e0';\n    }\n    \n    const str = bigValue.toString();\n    const firstDigit = str[0] === '-' ? str[1] : str[0];\n    const exponent = str.length - (str[0] === '-' ? 2 : 1);\n    \n    let result = firstDigit;\n    if (str.length > 1) {\n      const restDigits = str.slice(str[0] === '-' ? 2 : 1);\n      if (opts.precision > 0) {\n        result += '.' + restDigits.slice(0, opts.precision);\n      }\n    }\n    \n    if (str[0] === '-') {\n      result = '-' + result;\n    }\n    \n    return `${result}e${exponent}`;\n  }\n  \n  /**\n   * Calculates Greatest Common Divisor (helper function)\n   */\n  function calculateGCD(a: bigint, b: bigint): bigint {\n    a = a < 0n ? -a : a;\n    b = b < 0n ? -b : b;\n    \n    while (b !== 0n) {\n      const temp = b;\n      b = a % b;\n      a = temp;\n    }\n    \n    return a;\n  }\n  \n\n  /**\n * Converts Roman numeral to number\n */\nexport function fromRoman(value: string): bigint {\n    const romanValues = new Map<string, number>([\n      ['I', 1],\n      ['V', 5],\n      ['X', 10],\n      ['L', 50],\n      ['C', 100],\n      ['D', 500],\n      ['M', 1000]\n    ]);\n  \n    let result = 0;\n    let prevValue = 0;\n  \n    // Process from right to left\n    for (let i = value.length - 1; i >= 0; i--) {\n      const char = value[i]?.toUpperCase() ?? '';\n      const current = romanValues.get(char);\n  \n      if (current === undefined) {\n        throw new ValidationError(`Invalid Roman numeral character: ${char}`);\n      }\n  \n      if (current >= prevValue) {\n        result += current;\n      } else {\n        result -= current;\n      }\n  \n      prevValue = current;\n    }\n  \n    return BigInt(result);\n  }\n  \n  /**\n   * Converts number to Roman numeral\n   */\n  export function toRoman(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const num = Number(toBigInt(value));\n  \n    if (num <= 0 || num > 3999) {\n      throw new ValidationError('Number must be between 1 and 3999 for Roman numerals');\n    }\n  \n    // Define symbol pairs with proper typing\n    type RomanPair = [string, string];\n    type RomanSingle = [string];\n    type RomanSymbol = RomanPair | RomanSingle;\n  \n    const romanSymbols: RomanSymbol[] = [\n      ['I', 'V'], // ones\n      ['X', 'L'], // tens\n      ['C', 'D'], // hundreds\n      ['M']       // thousands\n    ];\n  \n    let result = '';\n    let position = 0;\n    let remaining = num;\n  \n    while (remaining > 0) {\n      const digit = remaining % 10;\n      const symbols = romanSymbols[position];\n  \n      if (!symbols) {\n        break; // Safety check for position overflow\n      }\n  \n      const unit = symbols[0];\n      const five = symbols[1] ?? '';\n      const next = position < 3 ? romanSymbols[position + 1]?.[0] ?? '' : '';\n  \n      let digitStr = '';\n      if (digit === 9 && next) {\n        digitStr = unit + next;\n      } else if (digit >= 5 && five) {\n        digitStr = five + unit.repeat(digit - 5);\n      } else if (digit === 4 && five) {\n        digitStr = unit + five;\n      } else {\n        digitStr = unit.repeat(digit);\n      }\n  \n      result = digitStr + result;\n      remaining = Math.floor(remaining / 10);\n      position++;\n    }\n  \n    return opts.uppercase ? result : result.toLowerCase();\n  }\n  export default {\n    toBinary,\n    toOctal,\n    toHexadecimal,\n    toBase,\n    fromBase,\n    toFraction,\n    fromFraction,\n    fromScientific,\n    toScientific,\n    fromRoman,\n    toRoman\n  };","/**\n * Factorial operations module for Hypernum library\n * Provides efficient implementations for factorial and related computations\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n    OverflowError,\n    validateNonNegative\n  } from '../utils/validation';\n  \n  /**\n   * Options for factorial operations\n   */\n  export interface FactorialOptions {\n    /** Maximum allowed computation value */\n    maxValue?: number;\n    /** Whether to check for overflow */\n    checkOverflow?: boolean;\n    /** Cache computed values */\n    useCache?: boolean;\n  }\n  \n  const DEFAULT_OPTIONS: Required<FactorialOptions> = {\n    maxValue: 1000,\n    checkOverflow: true,\n    useCache: true\n  };\n  \n  // Cache for factorial values\n  const factorialCache = new Map<bigint, bigint>();\n  \n  /**\n   * Calculates factorial of a number (n!)\n   */\n  export function factorial(\n    value: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n  \n    validateNonNegative(n);\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Factorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    // Handle base cases\n    if (n <= 1n) {\n      return 1n;\n    }\n  \n    // Check cache\n    if (opts.useCache && factorialCache.has(n)) {\n      return factorialCache.get(n)!;\n    }\n  \n    // Calculate factorial\n    let result = 1n;\n    for (let i = 2n; i <= n; i++) {\n      result *= i;\n    }\n  \n    // Cache result\n    if (opts.useCache) {\n      factorialCache.set(n, result);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates binomial coefficient (n choose k)\n   */\n  export function binomial(\n    n: bigint | string | number,\n    k: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigN = toBigInt(n);\n    const bigK = toBigInt(k);\n  \n    validateNonNegative(bigN);\n    validateNonNegative(bigK);\n  \n    if (bigK > bigN) {\n      throw new ValidationError('K cannot be greater than N in binomial coefficient');\n    }\n  \n    // Optimize for k > n/2 by using symmetry\n    if (bigK > bigN / 2n) {\n      return binomial(bigN, bigN - bigK, opts);\n    }\n  \n    // Use multiplicative formula instead of factorial for efficiency\n    let result = 1n;\n    for (let i = 0n; i < bigK; i++) {\n      result = (result * (bigN - i)) / (i + 1n);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates subfactorial (derangement number)\n   * Number of permutations of n elements with no fixed points\n   */\n  export function subfactorial(\n    value: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n  \n    validateNonNegative(n);\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Subfactorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    // Handle base cases\n    if (n === 0n) return 1n;\n    if (n === 1n) return 0n;\n  \n    // Use recursive formula !n = n * !(n-1) + (-1)^n\n    let result = 0n;\n    const nFact = factorial(n, opts);\n  \n    for (let k = 0n; k <= n; k++) {\n      const term = factorial(n - k, opts) * (k % 2n === 0n ? 1n : -1n);\n      result += term;\n    }\n  \n    return nFact - result;\n  }\n  \n  /**\n   * Calculates rising factorial (Pochhammer symbol)\n   * x^(n) = x(x+1)(x+2)...(x+n-1)\n   */\n  export function risingFactorial(\n    x: bigint | string | number,\n    n: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigX = toBigInt(x);\n    const bigN = toBigInt(n);\n  \n    validateNonNegative(bigN);\n  \n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Rising factorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    let result = 1n;\n    for (let i = 0n; i < bigN; i++) {\n      result *= (bigX + i);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates falling factorial\n   * x_(n) = x(x-1)(x-2)...(x-n+1)\n   */\n  export function fallingFactorial(\n    x: bigint | string | number,\n    n: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigX = toBigInt(x);\n    const bigN = toBigInt(n);\n  \n    validateNonNegative(bigN);\n  \n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Falling factorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    let result = 1n;\n    for (let i = 0n; i < bigN; i++) {\n      result *= (bigX - i);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates multifactorial (n!!)\n   * Product of numbers from 1 to n that leave the same remainder as n when divided by k\n   */\n  export function multiFactorial(\n    value: bigint | string | number,\n    k: bigint | string | number = 2n,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n    const bigK = toBigInt(k);\n  \n    validateNonNegative(n);\n    if (bigK <= 0n) {\n      throw new ValidationError('K must be positive in multifactorial');\n    }\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Multifactorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    let result = 1n;\n    let current = n;\n  \n    while (current > 0n) {\n      result *= current;\n      current -= bigK;\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates primorial (product of primes up to n)\n   */\n  export function primorial(\n    value: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n  \n    validateNonNegative(n);\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Primorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    if (n <= 1n) return 1n;\n  \n    // Generate primes up to n using Sieve of Eratosthenes\n    const num = Number(n);\n    const sieve = new Array(num + 1).fill(true);\n    sieve[0] = sieve[1] = false;\n  \n    for (let i = 2; i * i <= num; i++) {\n      if (sieve[i]) {\n        for (let j = i * i; j <= num; j += i) {\n          sieve[j] = false;\n        }\n      }\n    }\n  \n    // Calculate product of all primes up to n\n    let result = 1n;\n    for (let i = 2; i <= num; i++) {\n      if (sieve[i]) {\n        result *= BigInt(i);\n      }\n    }\n  \n    return result;\n  }\n\n  \n  \n  export default {\n    factorial,\n    binomial,\n    subfactorial,\n    risingFactorial,\n    fallingFactorial,\n    multiFactorial,\n    primorial\n  };","/**\n * Hypernum - A TypeScript/JavaScript library for large number operations\n */\nimport { HypernumConfig, mergeConfig, validateConfig } from './core';\nimport { Hypernum } from './core/hypernum';\nimport { RoundingMode } from './utils/precision';\n\n// Version\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport fs from 'fs';\nconst packagePath = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../package.json');\nconst { version: VERSION } = JSON.parse(fs.readFileSync(packagePath, 'utf-8'));\n\n// Core exports\nexport { Hypernum } from './core/hypernum';\nexport * from './core/constants';\nexport * from './core/common';\nexport * from './core/config';\n\n// Re-export errors with explicit names to avoid conflicts\nexport { \n  HypernumError,\n  ComputationLimitError,\n  DataStructureError,\n  DivisionByZeroError,\n  FormatError,\n  HeapPropertyError,\n  IndexError,\n  PrecisionError,\n  RomanNumeralError,\n  TreeError,\n  UnderflowError\n} from './core/errors';\n\n// Data structures with explicit imports and exports\nexport { AckermannStructure } from './structures/ackermann';\nexport { BigArray, type BigArrayOptions } from './structures/big-array';\nexport { NumberTree } from './structures/number-tree';\nexport { PowerTower } from './structures/power-tower';\nexport { MinHeap, MaxHeap, type Comparator } from './storage/';\n\n// Operations with explicit exports\nexport {\n  add,\n  subtract,\n  multiply,\n  divide,\n  remainder,\n  abs,\n  sign,\n  gcd,\n  lcm\n} from './operations/arithmetic';\n\nexport {\n  and,\n  or,\n  xor,\n  not,\n  leftShift,\n  rightShift,\n  unsignedRightShift,\n  rotateLeft,\n  rotateRight,\n  popCount,\n  trailingZeros,\n  leadingZeros,\n  getBit,\n  setBit,\n  clearBit,\n  toggleBit\n} from './operations/bitwise';\n\nexport {\n  compare,\n  equals,\n  lessThan,\n  lessThanOrEqual,\n  greaterThan,\n  greaterThanOrEqual,\n  between,\n  max,\n  min,\n  clamp,\n  allEqual,\n  isAscending,\n  isDescending,\n  createComparator\n} from './operations/comparison';\n\nexport {\n  toBinary,\n  toOctal,\n  toHexadecimal,\n  toBase,\n  fromBase,\n  toFraction,\n  fromFraction,\n  fromScientific,\n  toScientific,\n  fromRoman,\n  toRoman\n} from './operations/conversion';\n\nexport {\n  factorial,\n  binomial,\n  subfactorial,\n  risingFactorial,\n  fallingFactorial,\n  multiFactorial,\n  primorial\n} from './operations/factorial';\n\nexport {\n  power,\n  sqrt,\n  nthRoot,\n  tetration,\n  superRoot\n} from './operations/power';\n\n// Utils with explicit exports\nexport {\n  toBigInt,\n  validateNonNegative,\n  validatePositive,\n  checkAdditionOverflow,\n  checkMultiplicationOverflow,\n  checkPowerOverflow\n} from './utils/validation';\n\nexport {\n  formatBigInt,\n  parseBigIntString,\n  normalizeNumberString\n} from './utils/formatting';\n\nexport {\n  RoundingMode,\n  round,\n  scaleByPowerOfTen,\n  scaledDivision,\n  normalizePrecision\n} from './utils/precision';\n\n/**\n * Creates a new Hypernum instance with custom configuration\n */\nexport function createHypernum(config?: Partial<HypernumConfig>): Hypernum {\n  const mergedConfig = mergeConfig(config || {});\n  validateConfig(mergedConfig);\n  \n  const instanceConfig = {\n    precision: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.defaultPrecision \n      : mergedConfig.precision ?? 0,\n    roundingMode: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.defaultRoundingMode \n      : (mergedConfig.roundingMode as RoundingMode) ?? RoundingMode.HALF_EVEN,\n    checkOverflow: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.checkOverflow \n      : mergedConfig.checkOverflow ?? true,\n    maxSteps: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.maxComputationSteps \n      : mergedConfig.maxSteps ?? 1000,\n    debug: 'debug' in mergedConfig && typeof mergedConfig.debug === 'object' \n      ? mergedConfig.debug.verbose \n      : false\n  };\n  \n  return new Hypernum(instanceConfig);\n}\n\n// Default instance\nexport const defaultHypernum = createHypernum();\n\n// Export version\nexport { VERSION };\n\n// Default export\nexport default Hypernum;"],"names":["Error","constructor","message","super","this","name","OverflowError","toBigInt","value","isBigInt","test","isValidNumberString","ValidationError","BigInt","isNaN","isFinite","isValidNumber","Number","isInteger","checkAdditionOverflow","a","b","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","checkMultiplicationOverflow","maxValue","minValue","checkPowerOverflow","base","exponent","validateNonNegative","RoundingMode","scaleByPowerOfTen","power","round","precision","mode","HALF_EVEN","scale","scaled","remainder","FLOOR","CEIL","DOWN","UP","HALF_UP","HALF_DOWN","normalizePrecision","precisionA","precisionB","targetPrecision","Math","max","scaledDivision","numerator","denominator","roundingMode","scaledNumerator","DEFAULT_BASIC_CONFIG","checkOverflow","maxSteps","debug","DEFAULT_FULL_CONFIG","arithmetic","defaultPrecision","defaultRoundingMode","maxComputationSteps","autoPrecision","enabled","maxPrecision","minPrecision","constants","cache","algorithm","dataStructures","array","initialCapacity","growthFactor","maxSize","tree","maxDepth","autoBalance","nodeLimit","heap","growthPolicy","validatePropertyOnOperation","ttl","evictionPolicy","persistToDisk","compressionEnabled","formatting","notation","grouping","groupSize","decimalSeparator","groupSeparator","uppercase","scientific","minExponent","maxSignificantDigits","exponentSeparator","engineering","useSIPrefixes","localization","locale","useLocaleGrouping","performance","enableTracking","samplingRate","thresholds","warnThresholdMs","errorThresholdMs","maxMemoryBytes","metrics","timing","memory","verbose","trackPerformance","logLevel","features","experimentalFeatures","useWasm","workerThreads","sharedArrayBuffer","bigIntTypedArrays","isFullConfig","config","isBasicConfig","validateConfig","validateFullConfig","undefined","validateBasicConfig","mergeConfig","custom","fullConfig","MAX_COMPUTATION_STEPS","ZERO","ONE","TWO","TEN","NEGATIVE_ONE","MAX_POWER_BASE","MAX_POWER_EXPONENT","MAX_TETRATION_HEIGHT","MAX_FACTORIAL_INPUT","ERROR_MESSAGES","OVERFLOW","UNDERFLOW","NEGATIVE_ROOT","NEGATIVE_EXPONENT","DIVISION_BY_ZERO","INVALID_PRECISION","INVALID_BASE","INVALID_ROMAN","COMPUTATION_LIMIT","NEGATIVE_INDEX","TREE_DEPTH_EXCEEDED","INVALID_HEAP_PROPERTY","FEATURES","OVERFLOW_CHECKING","AUTOMATIC_PRECISION","MEMOIZATION","TREE_BALANCING","DEBUG_MODE","DEFAULT_OPTIONS","HypernumError","Object","setPrototypeOf","prototype","UnderflowError","DivisionByZeroError","PrecisionError","ComputationLimitError","DataStructureError","HeapPropertyError","TreeError","IndexError","FormatError","RomanNumeralError","add","options","opts","bigA","bigB","scaledA","scaledB","subtract","multiply","result","divide","bigNumerator","bigDenominator","abs","bigValue","gcd","temp","lcm","maxBits","strict","validateShift","shift","and","or","xor","not","leftShift","bigShift","unsignedRightShift","baseValue","exponentValue","bigBase","bigExponent","steps","sqrt","lastGuess","guess","nthRoot","n","bigN","nMinus1","tetration","height","bigHeight","i","Heap","comparator","compare","size","length","isEmpty","peek","push","siftUp","pop","root","last","siftDown","clear","heapify","MinHeap","MaxHeap","forEach","item","getParentIndex","index","floor","getLeftChildIndex","getRightChildIndex","swap","j","parentIndex","smallest","left","right","largest","AckermannStructure","nodes","Map","maxComputedM","maxComputedN","getNodeKey","m","computeAckermann","key","existing","get","inner","innerNum","error","RangeError","addNode","has","node","set","prevMKey","prevNKey","prevM","nextM","prevN","nextN","buildRange","mRange","nRange","getComputationPath","path","current","nextValue","safeNextValue","reverse","analyzeGrowthRate","growth","prevValue","increase","multiplier","getLargestValue","getValue","BigArray","capacity","data","Array","segmentTree","fill","getSize","getCapacity","resize","newCapacity","newData","rebuildSegmentTree","updateSegmentTree","success","oldValue","buildSegmentTree","start","end","mid","leftNode","rightNode","currentNode","queryRange","querySegmentTree","queryStart","queryEnd","leftResult","rightResult","toHeap","isMin","sort","ascending","toArray","slice","NumberNode","parent","sum","updateStats","getBalance","getStats","min","findMin","findMax","NumberTree","getRoot","insert","newValue","insertNode","find","compareResult","balance","rotateLeft","rotateRight","rightChild","rightLeftChild","leftChild","leftRightChild","remove","searchValue","removeNode","successor","traverse","order","depth","skipSubtrees","getTreeStats","getNthValue","findNth","position","leftSize","getRange","startValue","endValue","collectRange","maxHeight","PowerTower","head","tail","createNode","evaluated","previous","next","validateHeight","validateValue","computePower","build","evaluate","targetHeight","currentHeight","getHeight","isComputable","safeOptions","safeTower","getState","state","getMaxFeasibleHeight","Infinity","toString","formatBigInt","isNegative","absValue","formatScientific","coefficient","formatEngineering","formatCompact","formatStandard","str","unshift","join","len","digitsBeforePoint","suffixes","suffixIndex","suffix","decimalPart","padStart","Hypernum","structures","arrays","trees","heaps","arithmetic.add","arithmetic.subtract","arithmetic.multiply","arithmetic.divide","mod","arithmetic.remainder","power.power","power.sqrt","power.nthRoot","bitwise.and","bitwise.or","bitwise.xor","bitwise.not","arithmetic.gcd","arithmetic.lcm","createArray","id","getArray","createTree","getTree","createHeap","isMinHeap","compareValues","getHeap","createAckermannStructure","format","validation.toBigInt","formatting.formatBigInt","validate","updateConfig","newConfig","assign","getConfig","dispose","tolerance","diff","toleranceValue","equals","lessThan","lessThanOrEqual","greaterThan","greaterThanOrEqual","prefix","minDigits","useCache","factorialCache","factorial","packagePath","resolve","dirname","fileURLToPath","document","location","require","pathToFileURL","__filename","href","_documentCurrentScript","tagName","toUpperCase","src","URL","baseURI","version","VERSION","JSON","parse","fs","readFileSync","createHypernum","mergedConfig","instanceConfig","defaultHypernum","symbol","WARN_THRESHOLD_MS","ERROR_THRESHOLD_MS","MAX_ARRAY_SIZE","MAX_TREE_SIZE","values","first","every","binomial","k","bigK","bigMin","bigMax","bigPosition","x","bigX","cleanValue","toLowerCase","replace","quotient","romanValues","char","match","significand","exp","parseInt","absExp","count","msb","reduce","bigCurrent","includes","split","parseFloat","pow","cleanStr","RegExp","suffixMap","num","sieve","rotation","bigRotation","rightPart","nFact","binary","intPart","decPart","calculateGCD","hex","octal","romanSymbols","remaining","digit","symbols","unit","five","digitStr","repeat","firstDigit","restDigits"],"mappings":"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"}