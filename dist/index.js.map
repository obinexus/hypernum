{"version":3,"file":"index.js","sources":["../src/utils/validation.ts","../src/utils/precision.ts","../src/core/config.ts","../src/core/constants.ts","../src/core/errors.ts","../src/operations/arithmetic.ts","../src/operations/bitwise.ts","../src/operations/power.ts","../src/storage/Heap.ts","../src/structures/ackermann.ts","../src/structures/big-array.ts","../src/structures/number-tree.ts","../src/structures/power-tower.ts","../src/utils/formatting.ts","../src/core/hypernum.ts","../src/operations/comparison.ts","../src/operations/conversion.ts","../src/operations/factorial.ts","../src/index.ts"],"sourcesContent":["/**\n * Validation utilities for Hypernum library\n * Provides type checking and validation functions for large number operations\n */\n\n// Custom error types for validation\nexport class ValidationError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'ValidationError';\n    }\n  }\n  \n  export class OverflowError extends Error {\n    constructor(message: string) {\n      super(message);\n      this.name = 'OverflowError';\n    }\n  }\n  \n  // Type guards\n  export const isBigInt = (value: unknown): value is bigint => {\n    return typeof value === 'bigint';\n  };\n  \n  export const isValidNumberString = (value: string): boolean => {\n    return /^-?\\d+$/.test(value);\n  };\n  \n  export const isValidNumber = (value: unknown): value is number => {\n    return typeof value === 'number' && !isNaN(value) && isFinite(value);\n  };\n  \n  // Type conversions with validation\n  export const toBigInt = (value: unknown): bigint => {\n    if (isBigInt(value)) {\n      return value;\n    }\n    \n    if (typeof value === 'string') {\n      if (!isValidNumberString(value)) {\n        throw new ValidationError(`Invalid number string: ${value}`);\n      }\n      return BigInt(value);\n    }\n    \n    if (isValidNumber(value)) {\n      if (!Number.isInteger(value)) {\n        throw new ValidationError('Cannot convert non-integer number to BigInt');\n      }\n      return BigInt(value);\n    }\n    \n    throw new ValidationError(`Cannot convert ${typeof value} to BigInt`);\n  };\n  \n  // Range validation\n  export const validateRange = (value: bigint, min?: bigint, max?: bigint): void => {\n    if (min !== undefined && value < min) {\n      throw new ValidationError(`Value ${value} is below minimum ${min}`);\n    }\n    if (max !== undefined && value > max) {\n      throw new ValidationError(`Value ${value} exceeds maximum ${max}`);\n    }\n  };\n  \n  // Operation safety checks\n  export const checkAdditionOverflow = (a: bigint, b: bigint): void => {\n    // Check if addition would overflow\n    if (b > 0 && a > BigInt(Number.MAX_SAFE_INTEGER) - b) {\n      throw new OverflowError('Addition would overflow');\n    }\n    if (b < 0 && a < BigInt(Number.MIN_SAFE_INTEGER) - b) {\n      throw new OverflowError('Addition would underflow');\n    }\n  };\n  \n  export const checkMultiplicationOverflow = (a: bigint, b: bigint): void => {\n    // Check if multiplication would overflow\n    if (a !== BigInt(0) && b !== BigInt(0)) {\n      const maxValue = BigInt(Number.MAX_SAFE_INTEGER);\n      const minValue = BigInt(Number.MIN_SAFE_INTEGER);\n      \n      if (a > maxValue / b || a < minValue / b) {\n        throw new OverflowError('Multiplication would overflow');\n      }\n    }\n  };\n  \n  export const checkPowerOverflow = (base: bigint, exponent: bigint): void => {\n    // Basic overflow checks for exponentiation\n    if (exponent < BigInt(0)) {\n      throw new ValidationError('Negative exponents not supported for integers');\n    }\n    \n    if (base === BigInt(0) && exponent === BigInt(0)) {\n      throw new ValidationError('Zero raised to zero is undefined');\n    }\n    \n    if (exponent > BigInt(1000)) {\n      throw new OverflowError('Exponent too large, computation would overflow');\n    }\n  };\n  \n  // Array and data structure validation\n  export const validateArrayLength = (length: number): void => {\n    if (!Number.isInteger(length) || length < 0) {\n      throw new ValidationError('Array length must be a non-negative integer');\n    }\n    if (length > Number.MAX_SAFE_INTEGER) {\n      throw new ValidationError('Array length exceeds maximum safe integer');\n    }\n  };\n  \n  export const validateArrayIndex = (index: number, length: number): void => {\n    if (!Number.isInteger(index)) {\n      throw new ValidationError('Array index must be an integer');\n    }\n    if (index < 0 || index >= length) {\n      throw new ValidationError('Array index out of bounds');\n    }\n  };\n  \n  // Tree validation\n  export const validateTreeNode = (value: unknown): void => {\n    try {\n      toBigInt(value);\n    } catch (error) {\n      throw new ValidationError('Invalid tree node value');\n    }\n  };\n  \n  // Heap validation\n  export const validateHeapProperty = <T>(\n    value: T,\n    parent: T | undefined,\n    comparator: (a: T, b: T) => -1 | 0 | 1,\n    isMinHeap: boolean\n  ): void => {\n    if (!parent) return;\n    \n    const comparison = comparator(value, parent);\n    if (isMinHeap && comparison < 0) {\n      throw new ValidationError('Min heap property violated');\n    }\n    if (!isMinHeap && comparison > 0) {\n      throw new ValidationError('Max heap property violated');\n    }\n  };\n  \n  // Ackermann function validation\n  export const validateAckermannInput = (m: number, n: number): void => {\n    if (!Number.isInteger(m) || !Number.isInteger(n)) {\n      throw new ValidationError('Ackermann inputs must be integers');\n    }\n    if (m < 0 || n < 0) {\n      throw new ValidationError('Ackermann inputs must be non-negative');\n    }\n    if (m > 4) {\n      throw new ValidationError('First Ackermann parameter too large for computation');\n    }\n  };\n  \n  // General numeric validation utilities\n  export const isInRange = (value: bigint, min: bigint, max: bigint): boolean => {\n    return value >= min && value <= max;\n  };\n  \n  export const isPowerOfTwo = (value: bigint): boolean => {\n    return value > BigInt(0) && (value & (value - BigInt(1))) === BigInt(0);\n  };\n  \n  export const validatePositive = (value: bigint): void => {\n    if (value <= BigInt(0)) {\n      throw new ValidationError('Value must be positive');\n    }\n  };\n  \n  export const validateNonNegative = (value: bigint): void => {\n    if (value < BigInt(0)) {\n      throw new ValidationError('Value must be non-negative');\n    }\n  };","/**\n * Precision utilities for Hypernum library\n * Provides functions for handling decimal precision and rounding operations\n */\n\nimport { ValidationError } from './validation';\n\n/**\n * Rounding modes for decimal operations\n */\nexport enum RoundingMode {\n  FLOOR = 'FLOOR',           // Round towards negative infinity\n  CEIL = 'CEIL',             // Round towards positive infinity\n  DOWN = 'DOWN',             // Round towards zero\n  UP = 'UP',                 // Round away from zero\n  HALF_EVEN = 'HALF_EVEN',   // Round to nearest even number when tied (Banker's rounding)\n  HALF_UP = 'HALF_UP',       // Round up when tied\n  HALF_DOWN = 'HALF_DOWN',   // Round down when tied\n}\n\n/**\n * Scale a bigint by a power of 10\n */\nexport const scaleByPowerOfTen = (value: bigint, power: number): bigint => {\n  if (power === 0) return value;\n  if (power > 0) {\n    return value * (BigInt(10) ** BigInt(power));\n  }\n  return value / (BigInt(10) ** BigInt(-power));\n};\n\n/**\n * Round a number according to specified mode and precision\n */\nexport const round = (\n  value: bigint,\n  precision: number = 0,\n  mode: RoundingMode = RoundingMode.HALF_EVEN\n): bigint => {\n  if (precision < 0) {\n    throw new ValidationError('Precision must be non-negative');\n  }\n\n  if (precision === 0) {\n    return value;\n  }\n\n  const scale = BigInt(10) ** BigInt(precision);\n  const scaled = value / scale;\n  const remainder = value % scale;\n\n  switch (mode) {\n    case RoundingMode.FLOOR:\n      return scaled * scale;\n\n    case RoundingMode.CEIL:\n      return remainder > 0n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.DOWN:\n      return value >= 0n ? scaled * scale : (scaled - 1n) * scale;\n\n    case RoundingMode.UP:\n      return value >= 0n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.HALF_UP:\n      return remainder >= scale / 2n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.HALF_DOWN:\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\n\n    case RoundingMode.HALF_EVEN:\n      if (remainder === scale / 2n) {\n        return scaled % 2n === 0n ? scaled * scale : (scaled + 1n) * scale;\n      }\n      return remainder > scale / 2n ? (scaled + 1n) * scale : scaled * scale;\n\n    default:\n      throw new ValidationError('Invalid rounding mode');\n  }\n};\n\n/**\n * Calculate precision required to represent a number without loss\n */\nexport const calculateRequiredPrecision = (value: bigint): number => {\n  if (value === 0n) return 0;\n  \n  const str = value.toString();\n  const nonZeroIndex = str.split('').reverse().findIndex(char => char !== '0');\n  return nonZeroIndex === -1 ? 0 : nonZeroIndex;\n};\n\n/**\n * Normalize two numbers to the same precision\n */\nexport const normalizePrecision = (\n  a: bigint,\n  b: bigint,\n  precisionA: number,\n  precisionB: number\n): [bigint, bigint] => {\n  const targetPrecision = Math.max(precisionA, precisionB);\n  \n  const scaledA = scaleByPowerOfTen(a, targetPrecision - precisionA);\n  const scaledB = scaleByPowerOfTen(b, targetPrecision - precisionB);\n  \n  return [scaledA, scaledB];\n};\n\n/**\n * Scale a division operation to achieve desired precision\n */\nexport const scaledDivision = (\n  numerator: bigint,\n  denominator: bigint,\n  precision: number,\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\n): bigint => {\n  if (denominator === 0n) {\n    throw new ValidationError('Division by zero');\n  }\n\n  if (precision < 0) {\n    throw new ValidationError('Precision must be non-negative');\n  }\n\n  // Scale up numerator to handle desired precision\n  const scaledNumerator = scaleByPowerOfTen(numerator, precision);\n  const quotient = scaledNumerator / denominator;\n  \n  return round(quotient, 0, roundingMode);\n};\n\n/**\n * Calculate the number of significant digits\n */\nexport const significantDigits = (value: bigint): number => {\n  const nonZeroPattern = /[1-9]/;\n  const str = value.toString();\n  const firstSignificant = str.search(nonZeroPattern);\n  if (firstSignificant === -1) return 0;\n  \n  const lastSignificant = str.split('').reverse().findIndex(char => char !== '0');\n  return str.length - firstSignificant - (lastSignificant === -1 ? 0 : lastSignificant);\n};\n\n/**\n * Truncate to specified number of significant digits\n */\nexport const truncateToSignificantDigits = (\n  value: bigint,\n  digits: number,\n  roundingMode: RoundingMode = RoundingMode.HALF_EVEN\n): bigint => {\n  if (digits <= 0) {\n    throw new ValidationError('Number of significant digits must be positive');\n  }\n\n  const currentDigits = significantDigits(value);\n  \n  if (currentDigits <= digits) {\n    return value;\n  }\n\n  const scale = currentDigits - digits;\n  return round(value, scale, roundingMode);\n};\n\n/**\n * Check if two numbers are equal within a specified precision\n */\nexport const equalWithinPrecision = (\n  a: bigint,\n  b: bigint,\n  precision: number\n): boolean => {\n  const diff = a - b;\n  const tolerance = BigInt(10) ** BigInt(precision);\n  return diff.toString().length <= tolerance.toString().length;\n};\n\n/**\n * Get the fractional part of a number at a given precision\n */\nexport const getFractionalPart = (\n  value: bigint,\n  precision: number\n): bigint => {\n  if (precision <= 0) return 0n;\n  \n  const scale = BigInt(10) ** BigInt(precision);\n  return value % scale;\n};\n\n/**\n * Format a number with exact precision (no rounding)\n */\nexport const toExactPrecision = (value: bigint, precision: number): string => {\n  if (precision < 0) {\n    throw new ValidationError('Precision must be non-negative');\n  }\n\n  let str = value.toString();\n  const isNegative = str.startsWith('-');\n  if (isNegative) {\n    str = str.slice(1);\n  }\n\n  while (str.length <= precision) {\n    str = '0' + str;\n  }\n\n  const integerPart = str.slice(0, -precision) || '0';\n  const fractionalPart = str.slice(-precision);\n\n  return `${isNegative ? '-' : ''}${integerPart}.${fractionalPart}`;\n};","/**\n * Configuration type definitions for Hypernum library\n * Defines all configuration options and their default values\n */\n\nimport { RoundingMode } from '../utils/precision';\nimport { \n  FormatOptions,\n  DebugConfig,\n  CacheConfig,\n  MathConstantsConfig\n} from './common';\n\n/**\n * Basic configuration options for simple usage\n */\nexport interface BasicConfig {\n  /** Decimal precision for operations */\n  precision?: number;\n  /** Rounding mode for decimal operations */\n  roundingMode?: RoundingMode;\n  /** Whether to check for overflow */\n  checkOverflow?: boolean;\n  /** Maximum allowed computation steps */\n  maxSteps?: number;\n  /** Enable debug mode */\n  debug?: boolean;\n}\n\n/**\n * Configuration for arithmetic operations\n */\nexport interface ArithmeticConfig {\n  /** Default precision for decimal operations */\n  defaultPrecision: number;\n  /** Default rounding mode */\n  defaultRoundingMode: RoundingMode;\n  /** Whether to check for overflow by default */\n  checkOverflow: boolean;\n  /** Maximum steps for iterative calculations */\n  maxComputationSteps: number;\n  /** Configure automatic precision adjustment */\n  autoPrecision: {\n    enabled: boolean;\n    maxPrecision: number;\n    minPrecision: number;\n  };\n  /** Constants calculation configuration */\n  constants: MathConstantsConfig;\n}\n\n/**\n * Configuration for data structures\n */\nexport interface DataStructuresConfig {\n  /** Array configuration */\n  array: {\n    initialCapacity: number;\n    growthFactor: number;\n    maxSize: number;\n  };\n  /** Tree configuration */\n  tree: {\n    maxDepth: number;\n    autoBalance: boolean;\n    nodeLimit: number;\n  };\n  /** Heap configuration */\n  heap: {\n    initialCapacity: number;\n    growthPolicy: 'double' | 'linear' | 'fibonacci';\n    validatePropertyOnOperation: boolean;\n  };\n  /** Cache configuration */\n  cache: CacheConfig & {\n    enabled: boolean;\n    persistToDisk: boolean;\n    compressionEnabled: boolean;\n  };\n}\n\n/**\n * Configuration for number formatting\n */\nexport interface FormattingConfig extends FormatOptions {\n  /** Scientific notation configuration */\n  scientific: {\n    /** Minimum exponent to trigger scientific notation */\n    minExponent: number;\n    /** Maximum significant digits */\n    maxSignificantDigits: number;\n    /** Exponent separator character */\n    exponentSeparator: string;\n  };\n  /** Engineering notation configuration */\n  engineering: {\n    /** Use SI prefixes */\n    useSIPrefixes: boolean;\n    /** Custom unit definitions */\n    customUnits?: Map<number, string>;\n  };\n  /** Localization settings */\n  localization: {\n    /** Locale identifier */\n    locale: string;\n    /** Custom number formatting */\n    numberFormat?: Intl.NumberFormatOptions;\n    /** Use locale-specific grouping */\n    useLocaleGrouping: boolean;\n  };\n}\n\n/**\n * Configuration for performance monitoring\n */\nexport interface PerformanceConfig {\n  /** Enable performance tracking */\n  enableTracking: boolean;\n  /** Sampling rate for metrics (0-1) */\n  samplingRate: number;\n  /** Performance thresholds */\n  thresholds: {\n    /** Warning threshold in milliseconds */\n    warnThresholdMs: number;\n    /** Error threshold in milliseconds */\n    errorThresholdMs: number;\n    /** Maximum allowed memory usage in bytes */\n    maxMemoryBytes: number;\n  };\n  /** Metrics collection configuration */\n  metrics: {\n    /** Enable detailed operation timing */\n    timing: boolean;\n    /** Track memory usage */\n    memory: boolean;\n    /** Track cache performance */\n    cache: boolean;\n    /** Custom metrics to track */\n    custom?: Map<string, (operation: any) => number>;\n  };\n}\n\n/**\n * Feature flags for optional functionality\n */\nexport interface FeatureFlags {\n  /** Enable experimental features */\n  experimentalFeatures: boolean;\n  /** Use WebAssembly implementations when available */\n  useWasm: boolean;\n  /** Enable worker thread support */\n  workerThreads: boolean;\n  /** Enable SharedArrayBuffer support */\n  sharedArrayBuffer: boolean;\n  /** Enable BigInt64Array support */\n  bigIntTypedArrays: boolean;\n}\n\n/**\n * Full configuration interface with all options\n */\nexport interface FullConfig {\n  /** Arithmetic operation configuration */\n  arithmetic: ArithmeticConfig;\n  /** Data structure configuration */\n  dataStructures: DataStructuresConfig;\n  /** Formatting configuration */\n  formatting: FormattingConfig;\n  /** Performance configuration */\n  performance: PerformanceConfig;\n  /** Debug configuration */\n  debug: DebugConfig;\n  /** Feature flags */\n  features: FeatureFlags;\n  /** Custom configuration options */\n  custom?: Map<string, any>;\n}\n\n/**\n * Converts FullConfig to BasicConfig if necessary\n */\nexport function convertToBasicConfig(config: HypernumConfig): BasicConfig {\n  if (isBasicConfig(config)) {\n    return config;\n  }\n  return {\n    precision: config.arithmetic.defaultPrecision,\n    roundingMode: config.arithmetic.defaultRoundingMode,\n    checkOverflow: config.arithmetic.checkOverflow,\n    maxSteps: config.arithmetic.maxComputationSteps,\n    debug: config.debug.verbose\n  };\n}\n\n/**\n * Combined configuration type that can be either basic or full\n */\nexport type HypernumConfig = BasicConfig | FullConfig;\n\n/**\n * Default configuration values for basic config\n */\nexport const DEFAULT_BASIC_CONFIG: Required<BasicConfig> = {\n  precision: 0,\n  roundingMode: RoundingMode.HALF_EVEN,\n  checkOverflow: true,\n  maxSteps: 1000,\n  debug: false\n};\n\n/**\n * Full default configuration values\n */\nexport const DEFAULT_FULL_CONFIG: FullConfig = {\n  arithmetic: {\n    defaultPrecision: 0,\n    defaultRoundingMode: RoundingMode.HALF_EVEN,\n    checkOverflow: true,\n    maxComputationSteps: 1000,\n    autoPrecision: {\n      enabled: true,\n      maxPrecision: 100,\n      minPrecision: 0\n    },\n    constants: {\n      precision: 50,\n      cache: true,\n      algorithm: 'series'\n    }\n  },\n  dataStructures: {\n    array: {\n      initialCapacity: 16,\n      growthFactor: 2,\n      maxSize: 1_000_000\n    },\n    tree: {\n      maxDepth: 1000,\n      autoBalance: true,\n      nodeLimit: 1_000_000\n    },\n    heap: {\n      initialCapacity: 16,\n      growthPolicy: 'double',\n      validatePropertyOnOperation: true\n    },\n    cache: {\n      enabled: true,\n      maxSize: 1000,\n      ttl: 3600000, // 1 hour\n      evictionPolicy: 'LRU',\n      persistToDisk: false,\n      compressionEnabled: false\n    }\n  },\n  formatting: {\n    notation: 'standard',\n    precision: 0,\n    grouping: true,\n    groupSize: 3,\n    decimalSeparator: '.',\n    groupSeparator: ',',\n    uppercase: false,\n    scientific: {\n      minExponent: 6,\n      maxSignificantDigits: 6,\n      exponentSeparator: 'e'\n    },\n    engineering: {\n      useSIPrefixes: true\n    },\n    localization: {\n      locale: 'en-US',\n      useLocaleGrouping: false\n    }\n  },\n  performance: {\n    enableTracking: false,\n    samplingRate: 0.1,\n    thresholds: {\n      warnThresholdMs: 100,\n      errorThresholdMs: 1000,\n      maxMemoryBytes: 1024 * 1024 * 1024 // 1GB\n    },\n    metrics: {\n      timing: true,\n      memory: true,\n      cache: true\n    }\n  },\n  debug: {\n    verbose: false,\n    trackPerformance: false,\n    logLevel: 'error'\n  },\n  features: {\n    experimentalFeatures: false,\n    useWasm: false,\n    workerThreads: false,\n    sharedArrayBuffer: false,\n    bigIntTypedArrays: true\n  }\n};\n\n/**\n * Type guard to check if config is a full configuration\n */\nexport function isFullConfig(config: HypernumConfig): config is FullConfig {\n  return 'arithmetic' in config && 'dataStructures' in config;\n}\n\n/**\n * Type guard to check if config is a basic configuration\n */\nexport function isBasicConfig(config: HypernumConfig): config is BasicConfig {\n  return !isFullConfig(config);\n}\n\n/**\n * Validates configuration values\n */\nexport function validateConfig(config: HypernumConfig): void {\n  if (isFullConfig(config)) {\n    validateFullConfig(config);\n  } else {\n    validateBasicConfig(config);\n  }\n}\n\n/**\n * Validates basic configuration values\n */\nfunction validateBasicConfig(config: BasicConfig): void {\n  if (config.precision !== undefined && config.precision < 0) {\n    throw new Error('Precision cannot be negative');\n  }\n  if (config.maxSteps !== undefined && config.maxSteps <= 0) {\n    throw new Error('Maximum steps must be positive');\n  }\n  if (config.debug !== undefined && typeof config.debug !== 'boolean') {\n    throw new Error('Debug flag must be a boolean');\n  }\n}\n\n/**\n * Validates full configuration values\n */\nfunction validateFullConfig(config: FullConfig): void {\n  if (config.arithmetic.defaultPrecision < 0) {\n    throw new Error('Default precision cannot be negative');\n  }\n  if (config.arithmetic.maxComputationSteps <= 0) {\n    throw new Error('Max computation steps must be positive');\n  }\n  if (config.dataStructures.array.initialCapacity <= 0) {\n    throw new Error('Initial capacity must be positive');\n  }\n  if (config.dataStructures.array.growthFactor <= 1) {\n    throw new Error('Growth factor must be greater than 1');\n  }\n  if (config.performance.samplingRate < 0 || config.performance.samplingRate > 1) {\n    throw new Error('Sampling rate must be between 0 and 1');\n  }\n}\n\n/**\n * Merges configuration with appropriate defaults\n */\nexport function mergeConfig(custom: Partial<HypernumConfig> = {}): HypernumConfig {\n  if (isFullConfig(custom  as FullConfig)) {\n    const fullConfig = custom as FullConfig;\n    return {\n      ...DEFAULT_FULL_CONFIG,\n      ...fullConfig,\n      arithmetic: { ...DEFAULT_FULL_CONFIG.arithmetic, ...fullConfig.arithmetic },\n      dataStructures: { ...DEFAULT_FULL_CONFIG.dataStructures, ...fullConfig.dataStructures },\n      formatting: { ...DEFAULT_FULL_CONFIG.formatting, ...fullConfig.formatting },\n      performance: { ...DEFAULT_FULL_CONFIG.performance, ...fullConfig.performance },\n      debug: { ...DEFAULT_FULL_CONFIG.debug, ...fullConfig.debug },\n      features: { ...DEFAULT_FULL_CONFIG.features, ...fullConfig.features }\n    };\n  }\n  \n  const basicConfig: BasicConfig = {\n    precision: (custom as Partial<BasicConfig>).precision ?? DEFAULT_BASIC_CONFIG.precision,\n    roundingMode: (custom as Partial<BasicConfig>).roundingMode ?? DEFAULT_BASIC_CONFIG.roundingMode,\n    checkOverflow: (custom as Partial<BasicConfig>).checkOverflow ?? DEFAULT_BASIC_CONFIG.checkOverflow,\n    maxSteps: (custom as Partial<BasicConfig>).maxSteps ?? DEFAULT_BASIC_CONFIG.maxSteps,\n    debug: (custom as Partial<BasicConfig>).debug ?? DEFAULT_BASIC_CONFIG.debug\n  };\n\n  return basicConfig;\n}","/**\n * Core constants for Hypernum library\n * Defines fundamental values and limits used across the library\n */\n\n// Numerical limits\nexport const MAX_SAFE_INTEGER = BigInt(Number.MAX_SAFE_INTEGER);\nexport const MIN_SAFE_INTEGER = BigInt(Number.MIN_SAFE_INTEGER);\nexport const MAX_PRECISION = 100;\nexport const MAX_COMPUTATION_STEPS = 1000;\nexport const MAX_BITS = 1024;\n\n// Commonly used values\nexport const ZERO = BigInt(0);\nexport const ONE = BigInt(1);\nexport const TWO = BigInt(2);\nexport const TEN = BigInt(10);\nexport const NEGATIVE_ONE = BigInt(-1);\n\n// Power operation limits\nexport const MAX_POWER_BASE = BigInt(2) ** BigInt(53);\nexport const MAX_POWER_EXPONENT = BigInt(1000);\nexport const MAX_TETRATION_HEIGHT = BigInt(4);\nexport const MAX_FACTORIAL_INPUT = BigInt(1000);\n\n// Tree and heap configuration\nexport const DEFAULT_TREE_MAX_DEPTH = 1000;\nexport const DEFAULT_HEAP_INITIAL_CAPACITY = 16;\nexport const DEFAULT_ARRAY_GROWTH_FACTOR = 2;\nexport const MIN_ARRAY_CAPACITY = 16;\n\n// Formatting configuration\nexport const DEFAULT_DECIMAL_SEPARATOR = '.';\nexport const DEFAULT_GROUP_SEPARATOR = ',';\nexport const DEFAULT_GROUP_SIZE = 3;\nexport const MAX_GROUP_SIZE = 10;\n\n// Roman numeral limits\nexport const MIN_ROMAN_VALUE = 1;\nexport const MAX_ROMAN_VALUE = 3999;\n\n// Ackermann function limits\nexport const MAX_ACKERMANN_M = 4;\nexport const MAX_ACKERMANN_N = 1000;\n\n// Cache configuration\nexport const DEFAULT_CACHE_SIZE = 1000;\nexport const MAX_CACHE_SIZE = 10000;\n\n// Error messages\nexport const ERROR_MESSAGES = {\n  OVERFLOW: 'Operation would result in overflow',\n  UNDERFLOW: 'Operation would result in underflow',\n  NEGATIVE_ROOT: 'Cannot compute root of negative number',\n  NEGATIVE_EXPONENT: 'Negative exponents not supported for integers',\n  DIVISION_BY_ZERO: 'Division by zero',\n  INVALID_PRECISION: 'Precision must be non-negative and not exceed MAX_PRECISION',\n  INVALID_BASE: 'Base must be a positive integer',\n  INVALID_ROMAN: 'Invalid Roman numeral',\n  COMPUTATION_LIMIT: 'Computation exceeded maximum allowed steps',\n  NEGATIVE_INDEX: 'Array index cannot be negative',\n  TREE_DEPTH_EXCEEDED: 'Maximum tree depth exceeded',\n  INVALID_HEAP_PROPERTY: 'Heap property violation detected'\n} as const;\n\n// Feature flags for optional functionality\nexport const FEATURES = {\n  OVERFLOW_CHECKING: true,\n  AUTOMATIC_PRECISION: true,\n  MEMOIZATION: true,\n  TREE_BALANCING: true,\n  DEBUG_MODE: false\n} as const;\n\n// Default options for various operations\nexport const DEFAULT_OPTIONS = {\n  precision: 0,\n  roundingMode: 'HALF_EVEN',\n  checkOverflow: true,\n  maxSteps: MAX_COMPUTATION_STEPS,\n  grouping: true,\n  uppercase: false,\n  cache: true\n} as const;\n\n// Units for number formatting (powers of 1000)\nexport const NUMBER_UNITS = [\n  { value: 1n, symbol: '' },\n  { value: 1000n, symbol: 'K' },\n  { value: 1000000n, symbol: 'M' },\n  { value: 1000000000n, symbol: 'B' },\n  { value: 1000000000000n, symbol: 'T' },\n  { value: 1000000000000000n, symbol: 'Q' }\n] as const;\n\n// Performance monitoring thresholds\nexport const PERFORMANCE = {\n  WARN_THRESHOLD_MS: 100,\n  ERROR_THRESHOLD_MS: 1000,\n  MAX_ARRAY_SIZE: 1000000,\n  MAX_TREE_SIZE: 1000000\n} as const;","/**\n * Custom error types for Hypernum library\n * Provides specific error classes for different types of errors that can occur\n * during mathematical operations and data structure manipulations\n */\n\nimport { ERROR_MESSAGES } from './constants';\n\n/**\n * Base error class for Hypernum library\n * All other error classes inherit from this\n */\nexport class HypernumError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'HypernumError';\n    Object.setPrototypeOf(this, HypernumError.prototype);\n  }\n}\n\n/**\n * Error for validation failures\n */\nexport class ValidationError extends HypernumError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ValidationError';\n    Object.setPrototypeOf(this, ValidationError.prototype);\n  }\n}\n\n/**\n * Error for arithmetic overflow conditions\n */\nexport class OverflowError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.OVERFLOW) {\n    super(message);\n    this.name = 'OverflowError';\n    Object.setPrototypeOf(this, OverflowError.prototype);\n  }\n}\n\n/**\n * Error for arithmetic underflow conditions\n */\nexport class UnderflowError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.UNDERFLOW) {\n    super(message);\n    this.name = 'UnderflowError';\n    Object.setPrototypeOf(this, UnderflowError.prototype);\n  }\n}\n\n/**\n * Error for division by zero\n */\nexport class DivisionByZeroError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.DIVISION_BY_ZERO) {\n    super(message);\n    this.name = 'DivisionByZeroError';\n    Object.setPrototypeOf(this, DivisionByZeroError.prototype);\n  }\n}\n\n/**\n * Error for precision-related issues\n */\nexport class PrecisionError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.INVALID_PRECISION) {\n    super(message);\n    this.name = 'PrecisionError';\n    Object.setPrototypeOf(this, PrecisionError.prototype);\n  }\n}\n\n/**\n * Error for computation limits exceeded\n */\nexport class ComputationLimitError extends HypernumError {\n  constructor(message: string = ERROR_MESSAGES.COMPUTATION_LIMIT) {\n    super(message);\n    this.name = 'ComputationLimitError';\n    Object.setPrototypeOf(this, ComputationLimitError.prototype);\n  }\n}\n\n/**\n * Error for invalid operations on data structures\n */\nexport class DataStructureError extends HypernumError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'DataStructureError';\n    Object.setPrototypeOf(this, DataStructureError.prototype);\n  }\n}\n\n/**\n * Error for heap property violations\n */\nexport class HeapPropertyError extends DataStructureError {\n  constructor(message: string = ERROR_MESSAGES.INVALID_HEAP_PROPERTY) {\n    super(message);\n    this.name = 'HeapPropertyError';\n    Object.setPrototypeOf(this, HeapPropertyError.prototype);\n  }\n}\n\n/**\n * Error for tree-related issues\n */\nexport class TreeError extends DataStructureError {\n  constructor(message: string = ERROR_MESSAGES.TREE_DEPTH_EXCEEDED) {\n    super(message);\n    this.name = 'TreeError';\n    Object.setPrototypeOf(this, TreeError.prototype);\n  }\n}\n\n/**\n * Error for array index out of bounds\n */\nexport class IndexError extends DataStructureError {\n  constructor(message: string = ERROR_MESSAGES.NEGATIVE_INDEX) {\n    super(message);\n    this.name = 'IndexError';\n    Object.setPrototypeOf(this, IndexError.prototype);\n  }\n}\n\n/**\n * Error for invalid number format or conversion\n */\nexport class FormatError extends HypernumError {\n  constructor(message: string) {\n    super(message);\n    this.name = 'FormatError';\n    Object.setPrototypeOf(this, FormatError.prototype);\n  }\n}\n\n/**\n * Error for invalid Roman numeral operations\n */\nexport class RomanNumeralError extends FormatError {\n  constructor(message: string = ERROR_MESSAGES.INVALID_ROMAN) {\n    super(message);\n    this.name = 'RomanNumeralError';\n    Object.setPrototypeOf(this, RomanNumeralError.prototype);\n  }\n}\n\n/**\n * Type guard to check if an error is a Hypernum error\n */\nexport function isHypernumError(error: unknown): error is HypernumError {\n  return error instanceof HypernumError;\n}\n\n/**\n * Helper function to wrap unknown errors into HypernumError\n */\nexport function wrapError(error: unknown): HypernumError {\n  if (isHypernumError(error)) {\n    return error;\n  }\n  if (error instanceof Error) {\n    return new HypernumError(error.message);\n  }\n  return new HypernumError('An unknown error occurred');\n}\n\n/**\n * Helper function to create an appropriate error from a message and optional type\n */\nexport function createError(message: string, type?: string): HypernumError {\n  switch (type) {\n    case 'validation':\n      return new ValidationError(message);\n    case 'overflow':\n      return new OverflowError(message);\n    case 'underflow':\n      return new UnderflowError(message);\n    case 'division':\n      return new DivisionByZeroError(message);\n    case 'precision':\n      return new PrecisionError(message);\n    case 'computation':\n      return new ComputationLimitError(message);\n    case 'heap':\n      return new HeapPropertyError(message);\n    case 'tree':\n      return new TreeError(message);\n    case 'index':\n      return new IndexError(message);\n    case 'format':\n      return new FormatError(message);\n    case 'roman':\n      return new RomanNumeralError(message);\n    default:\n      return new HypernumError(message);\n  }\n}","/**\n * Arithmetic operations module for Hypernum library\n * Provides high-precision arithmetic operations with BigInt support\n */\n\nimport {\n    validateNonNegative,\n    toBigInt,\n    checkAdditionOverflow,\n    checkMultiplicationOverflow,\n    checkPowerOverflow,\n    ValidationError,\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n    round,\n    scaledDivision,\n    normalizePrecision,\n  } from '../utils/precision';\n  \n  /**\n   * Options for arithmetic operations\n   */\n  export interface ArithmeticOptions {\n    precision?: number;\n    roundingMode?: RoundingMode;\n    checkOverflow?: boolean;\n  }\n  \n  const DEFAULT_OPTIONS: Required<ArithmeticOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    checkOverflow: true\n  };\n  \n  /**\n   * Adds two numbers with optional precision and overflow checking\n   */\n  export function add(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.checkOverflow) {\n      checkAdditionOverflow(bigA, bigB);\n    }\n  \n    if (opts.precision === 0) {\n      return bigA + bigB;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    const result = scaledA + scaledB;\n    \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Subtracts two numbers with optional precision and overflow checking\n   */\n  export function subtract(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.checkOverflow) {\n      checkAdditionOverflow(bigA, -bigB);\n    }\n  \n    if (opts.precision === 0) {\n      return bigA - bigB;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    const result = scaledA - scaledB;\n    \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Multiplies two numbers with optional precision and overflow checking\n   */\n  export function multiply(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.checkOverflow) {\n      checkMultiplicationOverflow(bigA, bigB);\n    }\n  \n    const result = bigA * bigB;\n    if (opts.precision === 0) {\n      return result;\n    }\n  \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Divides two numbers with specified precision and rounding\n   */\n  export function divide(\n    numerator: bigint | string | number,\n    denominator: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigNumerator = toBigInt(numerator);\n    const bigDenominator = toBigInt(denominator);\n  \n    if (bigDenominator === BigInt(0)) {\n      throw new ValidationError('Division by zero');\n    }\n  \n    return scaledDivision(\n      bigNumerator,\n      bigDenominator,\n      opts.precision,\n      opts.roundingMode\n    );\n  }\n  \n  /**\n   * Calculates remainder with optional precision\n   */\n  export function remainder(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (bigB === BigInt(0)) {\n      throw new ValidationError('Division by zero in remainder operation');\n    }\n  \n    if (opts.precision === 0) {\n      return bigA % bigB;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    const result = scaledA % scaledB;\n    \n    return round(result, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Raises a number to a power with optional precision\n   */\n  export function power(\n    base: bigint | string | number,\n    exponent: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigBase = toBigInt(base);\n    const bigExponent = toBigInt(exponent);\n  \n    if (opts.checkOverflow) {\n      checkPowerOverflow(bigBase, bigExponent);\n    }\n  \n    validateNonNegative(bigExponent);\n  \n    if (bigExponent === BigInt(0)) {\n      return BigInt(1);\n    }\n  \n    if (bigExponent === BigInt(1)) {\n      return bigBase;\n    }\n  \n    let result = bigBase;\n    let remaining = bigExponent - BigInt(1);\n  \n    while (remaining > BigInt(0)) {\n      if (opts.checkOverflow) {\n        checkMultiplicationOverflow(result, bigBase);\n      }\n      result *= bigBase;\n      remaining--;\n    }\n  \n    if (opts.precision > 0) {\n      return round(result, opts.precision, opts.roundingMode);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates the square root with specified precision\n   */\n  export function sqrt(\n    value: bigint | string | number,\n    options: ArithmeticOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    validateNonNegative(bigValue);\n  \n    if (bigValue === BigInt(0)) {\n      return BigInt(0);\n    }\n  \n    // Scale up for precision\n    const scaleFactor = BigInt(10) ** BigInt(opts.precision * 2);\n    const scaled = bigValue * scaleFactor;\n  \n    // Newton's method for square root\n    let x = scaled;\n    let y = (x + scaled / x) >> BigInt(1);\n  \n    while (y < x) {\n      x = y;\n      y = (x + scaled / x) >> BigInt(1);\n    }\n  \n    return round(x, opts.precision, opts.roundingMode);\n  }\n  \n  /**\n   * Calculates the absolute value\n   */\n  export function abs(value: bigint | string | number): bigint {\n    const bigValue = toBigInt(value);\n    return bigValue < BigInt(0) ? -bigValue : bigValue;\n  }\n  \n  /**\n   * Returns the sign of a number (-1, 0, or 1)\n   */\n  export function sign(value: bigint | string | number): bigint {\n    const bigValue = toBigInt(value);\n    if (bigValue < BigInt(0)) return BigInt(-1);\n    if (bigValue > BigInt(0)) return BigInt(1);\n    return BigInt(0);\n  }\n  \n  /**\n   * Calculates the greatest common divisor of two numbers\n   */\n  export function gcd(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    let bigA = abs(toBigInt(a));\n    let bigB = abs(toBigInt(b));\n  \n    while (bigB !== BigInt(0)) {\n      const temp = bigB;\n      bigB = bigA % bigB;\n      bigA = temp;\n    }\n  \n    return bigA;\n  }\n  \n  /**\n   * Calculates the least common multiple of two numbers\n   */\n  export function lcm(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = abs(toBigInt(a));\n    const bigB = abs(toBigInt(b));\n    \n    if (bigA === BigInt(0) || bigB === BigInt(0)) {\n      return BigInt(0);\n    }\n  \n    return abs(bigA * bigB) / gcd(bigA, bigB);\n  }\n  \n  // /**\n  //  * Calculates factorial of a number\n  //  */\n  // export function factorial(value: bigint | string | number): bigint {\n  //   const bigValue = toBigInt(value);\n  //   validateNonNegative(bigValue);\n  \n  //   if (bigValue > BigInt(1000)) {\n  //     throw new OverflowError('Factorial input too large');\n  //   }\n  \n  //   if (bigValue <= BigInt(1)) {\n  //     return BigInt(1);\n  //   }\n  \n  //   let result = BigInt(1);\n  //   let current = BigInt(2);\n  \n  //   while (current <= bigValue) {\n  //     result *= current;\n  //     current++;\n  //   }\n  \n  //   return result;\n  // }\n  \n  export default {\n    add,\n    subtract,\n    multiply,\n    divide,\n    remainder,\n    power,\n    sqrt,\n    abs,\n    sign,\n    gcd,\n    lcm, \n    // factorial\n    };\n\n  ","/**\n * Bitwise operations module for Hypernum library\n * Provides functions for bit-level manipulations of large numbers\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n    validateNonNegative\n  } from '../utils/validation';\n  \n  /**\n   * Options for bitwise operations\n   */\n  export interface BitwiseOptions {\n    /** Maximum bits to consider in operations */\n    maxBits?: number;\n    /** Whether to throw on overflow */\n    strict?: boolean;\n  }\n  \n  const DEFAULT_OPTIONS: Required<BitwiseOptions> = {\n    maxBits: 1024,\n    strict: true\n  };\n  \n  /**\n   * Validates shift amount is within reasonable bounds\n   */\n  function validateShift(shift: bigint, options: Required<BitwiseOptions>): void {\n    if (shift < 0n) {\n      throw new ValidationError('Shift amount cannot be negative');\n    }\n    if (options.strict && shift >= BigInt(options.maxBits)) {\n      throw new ValidationError(`Shift amount exceeds maximum of ${options.maxBits} bits`);\n    }\n  }\n  \n  /**\n   * Performs bitwise AND operation\n   */\n  export function and(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n\n    return bigA & bigB;\n  }\n  \n  /**\n   * Performs bitwise OR operation\n   */\n  export function or(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n    \n    return bigA | bigB;\n  }\n  \n  /**\n   * Performs bitwise XOR operation\n   */\n  export function xor(\n    a: bigint | string | number,\n    b: bigint | string | number\n  ): bigint {\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n    \n    return bigA ^ bigB;\n  }\n  \n  /**\n   * Performs bitwise NOT operation\n   */\n  export function not(\n    value: bigint | string | number\n  ): bigint {\n    const bigValue = toBigInt(value);\n    \n    return ~bigValue;\n  }\n  \n  /**\n   * Performs left shift operation\n   */\n  export function leftShift(\n    value: bigint | string | number,\n    shift: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigShift = toBigInt(shift);\n    \n    validateShift(bigShift, opts);\n    return bigValue << bigShift;\n  }\n  \n  /**\n   * Performs right shift operation\n   */\n  export function rightShift(\n    value: bigint | string | number,\n    shift: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigShift = toBigInt(shift);\n    \n    validateShift(bigShift, opts);\n    return bigValue >> bigShift;\n  }\n  \n  /**\n   * Performs unsigned right shift operation\n   * Note: BigInt doesn't have >>> operator, so we implement it manually\n   */\n  export function unsignedRightShift(\n    value: bigint | string | number,\n    shift: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigShift = toBigInt(shift);\n    \n    validateShift(bigShift, opts);\n    \n    if (bigValue >= 0n) {\n      return bigValue >> bigShift;\n    }\n    \n    // Handle negative numbers by first converting to positive\n    const mask = (1n << BigInt(opts.maxBits)) - 1n;\n    return (bigValue & mask) >> bigShift;\n  }\n  \n  /**\n   * Rotates bits left by specified amount\n   */\n  export function rotateLeft(\n    value: bigint | string | number,\n    rotation: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    let bigRotation = toBigInt(rotation);\n    \n    validateNonNegative(bigRotation);\n    \n    // Normalize rotation to be within maxBits\n    if (bigRotation >= BigInt(opts.maxBits)) {\n      bigRotation = bigRotation % BigInt(opts.maxBits);\n    }\n    \n    if (bigRotation === 0n) {\n      return bigValue;\n    }\n    \n    const leftPart = leftShift(bigValue, bigRotation, opts);\n    const rightPart = unsignedRightShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\n    \n    return leftPart | rightPart;\n  }\n  \n  /**\n   * Rotates bits right by specified amount\n   */\n  export function rotateRight(\n    value: bigint | string | number,\n    rotation: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    let bigRotation = toBigInt(rotation);\n    \n    validateNonNegative(bigRotation);\n    \n    // Normalize rotation to be within maxBits\n    if (bigRotation >= BigInt(opts.maxBits)) {\n      bigRotation = bigRotation % BigInt(opts.maxBits);\n    }\n    \n    if (bigRotation === 0n) {\n      return bigValue;\n    }\n    \n    const rightPart = unsignedRightShift(bigValue, bigRotation, opts);\n    const leftPart = leftShift(bigValue, BigInt(opts.maxBits) - bigRotation, opts);\n    \n    return leftPart | rightPart;\n  }\n  \n  /**\n   * Counts number of set bits (1s)\n   */\n  export function popCount(\n    value: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    let bigValue = toBigInt(value);\n    \n    let count = 0n;\n    while (bigValue !== 0n) {\n      count += bigValue & 1n;\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\n    }\n    \n    return count;\n  }\n  \n  /**\n   * Returns number of trailing zero bits\n   */\n  export function trailingZeros(\n    value: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    let bigValue = toBigInt(value);\n    \n    if (bigValue === 0n) {\n      return BigInt(opts.maxBits);\n    }\n    \n    let count = 0n;\n    while ((bigValue & 1n) === 0n) {\n      count++;\n      bigValue = unsignedRightShift(bigValue, 1n, opts);\n    }\n    \n    return count;\n  }\n  \n  /**\n   * Returns number of leading zero bits\n   */\n  export function leadingZeros(\n    value: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    let bigValue = toBigInt(value);\n    \n    if (bigValue === 0n) {\n      return BigInt(opts.maxBits);\n    }\n    \n    let count = 0n;\n    const msb = 1n << BigInt(opts.maxBits - 1);\n    \n    while ((bigValue & msb) === 0n && count < BigInt(opts.maxBits)) {\n      count++;\n      bigValue = leftShift(bigValue, 1n, opts);\n    }\n    \n    return count;\n  }\n  \n  /**\n   * Returns bit at specified position\n   */\n  export function getBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): boolean {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return (bigValue & (1n << bigPosition)) !== 0n;\n  }\n  \n  /**\n   * Sets bit at specified position\n   */\n  export function setBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return bigValue | (1n << bigPosition);\n  }\n  \n  /**\n   * Clears bit at specified position\n   */\n  export function clearBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return bigValue & ~(1n << bigPosition);\n  }\n  \n  /**\n   * Toggles bit at specified position\n   */\n  export function toggleBit(\n    value: bigint | string | number,\n    position: bigint | string | number,\n    options: BitwiseOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigPosition = toBigInt(position);\n    \n    validateNonNegative(bigPosition);\n    if (opts.strict && bigPosition >= BigInt(opts.maxBits)) {\n      throw new ValidationError(`Bit position exceeds maximum of ${opts.maxBits} bits`);\n    }\n    \n    return bigValue ^ (1n << bigPosition);\n  }\n  \n  export default {\n    and,\n    or,\n    xor,\n    not,\n    leftShift,\n    rightShift,\n    unsignedRightShift,\n    rotateLeft,\n    rotateRight,\n    popCount,\n    trailingZeros,\n    leadingZeros,\n    getBit,\n    setBit,\n    clearBit,\n    toggleBit\n  };","/**\n * Power operations module for Hypernum library\n * Provides efficient implementations for exponentiation and related operations\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n    OverflowError,\n    validateNonNegative,\n    checkPowerOverflow\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n    round,\n  } from '../utils/precision';\n  \n  /**\n   * Options for power operations\n   */\n  export interface PowerOptions {\n    /** Precision for decimal operations */\n    precision?: number;\n    /** Rounding mode for decimal operations */\n    roundingMode?: RoundingMode;\n    /** Whether to check for overflow */\n    checkOverflow?: boolean;\n    /** Maximum allowed computation steps */\n    maxSteps?: number;\n  }\n  \n  const DEFAULT_OPTIONS: Required<PowerOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    checkOverflow: true,\n    maxSteps: 1000\n  };\n  \n  /**\n   * Raises a number to an integer power using binary exponentiation\n   */\n  export function power(\n    baseValue: bigint | string | number,\n    exponentValue: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigBase = toBigInt(baseValue);\n    const bigExponent = toBigInt(exponentValue);\n  \n    // Handle special cases\n    if (bigExponent === 0n) {\n      return 1n;\n    }\n    if (bigExponent === 1n) {\n      return bigBase;\n    }\n    if (bigBase === 0n && bigExponent < 0n) {\n      throw new ValidationError('Zero cannot be raised to a negative power');\n    }\n    if (bigBase === 0n) {\n      return 0n;\n    }\n    if (bigBase === 1n) {\n      return 1n;\n    }\n    if (bigBase === -1n) {\n      return bigExponent % 2n === 0n ? 1n : -1n;\n    }\n  \n    // Validate inputs\n    if (bigExponent < 0n) {\n      throw new ValidationError('Negative exponents not supported for integer power');\n    }\n  \n    if (opts.checkOverflow) {\n      checkPowerOverflow(bigBase, bigExponent);\n    }\n  \n    // Binary exponentiation algorithm\n    let result = 1n;\n    let base = bigBase;\n    let exponent = bigExponent;\n    let steps = 0;\n  \n    while (exponent > 0n) {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Power operation exceeded maximum computation steps');\n      }\n  \n      if (exponent & 1n) {\n        result *= base;\n      }\n      base *= base;\n      exponent >>= 1n;\n    }\n  \n    if (opts.precision > 0) {\n      return round(result, opts.precision, opts.roundingMode);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates square root using Newton's method\n   */\n  export function sqrt(\n    value: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n  \n    validateNonNegative(bigValue);\n  \n    if (bigValue === 0n) {\n      return 0n;\n    }\n    if (bigValue === 1n) {\n      return 1n;\n    }\n  \n    // Newton's method for square root\n    let guess = bigValue >> 1n;\n    let lastGuess: bigint;\n    let steps = 0;\n  \n    do {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Square root operation exceeded maximum computation steps');\n      }\n  \n      lastGuess = guess;\n      guess = (guess + bigValue / guess) >> 1n;\n    } while (guess < lastGuess);\n  \n    if (opts.precision > 0) {\n      return round(lastGuess, opts.precision, opts.roundingMode);\n    }\n  \n    return lastGuess;\n  }\n  \n  /**\n   * Calculates nth root using Newton's method\n   */\n  export function nthRoot(\n    value: bigint | string | number,\n    n: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigN = toBigInt(n);\n  \n    validateNonNegative(bigValue);\n    if (bigN <= 0n) {\n      throw new ValidationError('Root index must be positive');\n    }\n  \n    if (bigValue === 0n) {\n      return 0n;\n    }\n    if (bigValue === 1n) {\n      return 1n;\n    }\n    if (bigN === 1n) {\n      return bigValue;\n    }\n    if (bigN === 2n) {\n      return sqrt(bigValue, opts);\n    }\n  \n    // Newton's method for nth root\n    let guess = bigValue >> 1n;\n    let lastGuess: bigint;\n    let steps = 0;\n  \n    const nMinus1 = bigN - 1n;\n  \n    do {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Nth root operation exceeded maximum computation steps');\n      }\n  \n      lastGuess = guess;\n      const powered = power(guess, nMinus1, opts);\n      guess = ((nMinus1 * guess) + (bigValue / powered)) / bigN;\n    } while (guess < lastGuess);\n  \n    if (opts.precision > 0) {\n      return round(lastGuess, opts.precision, opts.roundingMode);\n    }\n  \n    return lastGuess;\n  }\n  \n  /**\n   * Calculates tetration (repeated exponentiation)\n   * an = a^(a^(a^...)) (n times)\n   */\n  export function tetration(\n    base: bigint | string | number,\n    height: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigBase = toBigInt(base);\n    const bigHeight = toBigInt(height);\n  \n    validateNonNegative(bigHeight);\n  \n    if (bigHeight === 0n) {\n      return 1n;\n    }\n    if (bigHeight === 1n) {\n      return bigBase;\n    }\n    if (bigBase === 0n) {\n      return bigHeight % 2n === 0n ? 1n : 0n;\n    }\n    if (bigBase === 1n) {\n      return 1n;\n    }\n    if (bigBase === 2n && bigHeight > 4n) {\n      throw new OverflowError('Tetration would overflow for base 2 and height > 4');\n    }\n  \n    let result = bigBase;\n    let steps = 0;\n  \n    for (let i = 1n; i < bigHeight; i++) {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Tetration operation exceeded maximum computation steps');\n      }\n  \n      result = power(bigBase, result, opts);\n    }\n  \n    if (opts.precision > 0) {\n      return round(result, opts.precision, opts.roundingMode);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates super-root (inverse tetration)\n   * Finds x where xn = value\n   */\n  export function superRoot(\n    value: bigint | string | number,\n    height: bigint | string | number,\n    options: PowerOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    const bigHeight = toBigInt(height);\n  \n    validateNonNegative(bigHeight);\n    if (bigHeight === 0n) {\n      throw new ValidationError('Height cannot be zero for super-root');\n    }\n    if (bigValue < 1n) {\n      throw new ValidationError('Value must be at least 1 for super-root');\n    }\n  \n    if (bigValue === 1n) {\n      return 1n;\n    }\n    if (bigHeight === 1n) {\n      return bigValue;\n    }\n  \n    // Binary search for super-root\n    let left = 1n;\n    let right = bigValue;\n    let steps = 0;\n  \n    while (left <= right) {\n      if (steps++ > opts.maxSteps) {\n        throw new OverflowError('Super-root operation exceeded maximum computation steps');\n      }\n  \n      const mid = (left + right) >> 1n;\n      try {\n        const test = tetration(mid, bigHeight, opts);\n        if (test === bigValue) {\n          return mid;\n        }\n        if (test < bigValue) {\n          left = mid + 1n;\n        } else {\n          right = mid - 1n;\n        }\n      } catch (error) {\n        right = mid - 1n;\n      }\n    }\n  \n    if (opts.precision > 0) {\n      return round(right, opts.precision, opts.roundingMode);\n    }\n  \n    return right;\n  }\n  \n  export default {\n    power,\n    sqrt,\n    nthRoot,\n    tetration,\n    superRoot\n  };","\n/**\n * Represents the result of a comparison operation\n * -1: first value is less than second value\n *  0: values are equal\n *  1: first value is greater than second value\n */\nexport type ComparisonResult = -1 | 0 | 1;\n\n/**\n * Generic comparator function type for heap elements\n */\nexport type Comparator<T> = (a: T, b: T) => ComparisonResult;\n\n/**\n * Abstract base heap class implementing common heap operations\n */\nabstract class Heap<T> {\n  protected heap: T[];\n  protected readonly compare: Comparator<T>;\n\n  constructor(comparator: Comparator<T>) {\n    this.heap = [];\n    this.compare = comparator;\n  }\n\n  /**\n   * Gets the size of the heap\n   */\n  public size(): number {\n    return this.heap.length;\n  }\n\n  /**\n   * Checks if the heap is empty\n   */\n  public isEmpty(): boolean {\n    return this.heap.length === 0;\n  }\n\n  /**\n   * Peeks at the root element without removing it\n   */\n  public peek(): T | undefined {\n    return this.heap[0];\n  }\n\n  /**\n   * Inserts a new element into the heap\n   */\n  public push(value: T): void {\n    this.heap.push(value);\n    this.siftUp(this.heap.length - 1);\n  }\n\n  /**\n   * Removes and returns the root element\n   */\n  public pop(): T | undefined {\n    if (this.isEmpty()) {\n      return undefined;\n    }\n\n    const root = this.heap[0];\n    const last = this.heap.pop()!;\n\n    if (!this.isEmpty()) {\n      this.heap[0] = last;\n      this.siftDown(0);\n    }\n\n    return root;\n  }\n\n  /**\n   * Removes all elements from the heap\n   */\n  public clear(): void {\n    this.heap = [];\n  }\n\n  /**\n   * Creates a heap from an array of elements\n   */\n  public static heapify<T extends {}>(array: T[], comparator: Comparator<T>): Heap<T> {\n    const heap = this instanceof MinHeap ? new MinHeap(comparator) : new MaxHeap(comparator);\n    array.forEach(item => heap.push(item));\n    return heap;\n  }\n\n  /**\n   * Gets the parent index of a node\n   */\n  protected getParentIndex(index: number): number {\n    return Math.floor((index - 1) / 2);\n  }\n\n  /**\n   * Gets the left child index of a node\n   */\n  protected getLeftChildIndex(index: number): number {\n    return 2 * index + 1;\n  }\n\n  /**\n   * Gets the right child index of a node\n   */\n  protected getRightChildIndex(index: number): number {\n    return 2 * index + 2;\n  }\n\n  /**\n   * Swaps two elements in the heap\n   */\n  protected swap(i: number, j: number): void {\n    const temp = this.heap[i]!;\n    this.heap[i] = this.heap[j]!;\n    this.heap[j] = temp;\n  }\n\n  /**\n   * Moves an element up the heap until heap property is satisfied\n   */\n  protected abstract siftUp(index: number): void;\n\n  /**\n   * Moves an element down the heap until heap property is satisfied\n   */\n  protected abstract siftDown(index: number): void;\n}\n\n/**\n * MinHeap implementation where the root is the smallest element\n */\nexport class MinHeap<T> extends Heap<T> {\n  constructor(comparator: Comparator<T>) {\n    super(comparator);\n  }\n\n  protected siftUp(index: number): void {\n    while (index > 0) {\n      const parentIndex = this.getParentIndex(index);\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) >= 0) {\n        break;\n      }\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  protected siftDown(index: number): void {\n    const size = this.heap.length;\n    \n    while (true) {\n      let smallest = index;\n      const left = this.getLeftChildIndex(index);\n      const right = this.getRightChildIndex(index);\n\n      if (left < size && this.compare(this.heap[left]!, this.heap[smallest]!) < 0) {\n        smallest = left;\n      }\n\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right] as T, this.heap[smallest] as T) < 0) {\n        smallest = right;\n      }\n\n      if (smallest === index) {\n        break;\n      }\n\n      this.swap(index, smallest);\n      index = smallest;\n    }\n  }\n}\n\n/**\n * MaxHeap implementation where the root is the largest element\n */\nexport class MaxHeap<T> extends Heap<T> {\n  constructor(comparator: Comparator<T>) {\n    super(comparator);\n  }\n\n  protected siftUp(index: number): void {\n    while (index > 0) {\n      const parentIndex = this.getParentIndex(index);\n      if (this.compare(this.heap[index]!, this.heap[parentIndex]!) <= 0) {\n        break;\n      }\n      this.swap(index, parentIndex);\n      index = parentIndex;\n    }\n  }\n\n  protected siftDown(index: number): void {\n    const size = this.heap.length;\n    \n    while (true) {\n      let largest = index;\n      const left = this.getLeftChildIndex(index);\n      const right = this.getRightChildIndex(index);\n\n      if (left < size && this.heap[left] !== undefined && this.compare(this.heap[left]!, this.heap[largest]!) > 0) {\n        largest = left;\n      }\n\n      if (right < size && this.heap[right] !== undefined && this.compare(this.heap[right]!, this.heap[largest]!) > 0) {\n        largest = right;\n      }\n\n      if (largest === index) {\n        break;\n      }\n\n      this.swap(index, largest);\n      index = largest;\n    }\n  }\n}\n\n// Type Guards\nexport const isMinHeap = <T>(heap: Heap<T>): heap is MinHeap<T> => {\n  return heap instanceof MinHeap;\n};\n\nexport const isMaxHeap = <T>(heap: Heap<T>): heap is MaxHeap<T> => {\n  return heap instanceof MaxHeap;\n};\n\n/**\n * Custom comparator for large numbers\n */\nexport function createLargeNumberComparator(): (a: bigint, b: bigint) => number {\n  return (a, b) => {\n    return a > b ? 1 : a < b ? -1 : 0;\n  };\n}","import { Comparator } from \"..\";\nimport { MaxHeap, createLargeNumberComparator } from \"../storage/Heap\";\n\n  /**\n   * Interface representing an Ackermann node in the computation structure\n   */\n  interface IAckermannNode {\n    m: number;\n    n: number;\n    value: bigint;\n    prevM?: IAckermannNode;  // Link to A(m-1, n)\n    prevN?: IAckermannNode;  // Link to A(m, n-1)\n    nextM?: IAckermannNode;  // Link to A(m+1, n)\n    nextN?: IAckermannNode;  // Link to A(m, n+1)\n  }\n  \n  /**\n   * Type for Ackermann computation path step\n   */\n  type ComputationStep = {\n    m: number;\n    n: number;\n    value: bigint;\n  };\n  \n  /**\n   * Type for growth rate analysis\n   */\n  type GrowthAnalysis = {\n    value: bigint;\n    increase: bigint;\n    multiplier: bigint;\n  };\n  \n  /**\n   * Class representing the Ackermann function computation structure\n   * Implements caching and relationship tracking between values\n   */\n  export class AckermannStructure {\n    private nodes: Map<string, IAckermannNode>;\n    private maxComputedM: number;\n    private maxComputedN: number;\n    private heap: MaxHeap<bigint>;\n  \n    constructor() {\n      this.nodes = new Map();\n      this.maxComputedM = -1;\n      this.maxComputedN = -1;\n      this.heap = new MaxHeap<bigint>(createLargeNumberComparator() as Comparator<bigint>);\n    }\n  \n    /**\n     * Generates a unique key for node storage\n     */\n    private static getNodeKey(m: number, n: number): string {\n      return `${m},${n}`;\n    }\n  \n    /**\n     * Computes the Ackermann function value\n     * Uses recursion with memoization\n     */\n    private computeAckermann(m: number, n: number): bigint {\n      // Handle invalid inputs\n      if (m < 0 || n < 0) {\n        throw new Error('Ackermann function undefined for negative numbers');\n      }\n  \n      // Check if already computed\n      const key = AckermannStructure.getNodeKey(m, n);\n      const existing = this.nodes.get(key);\n      if (existing) {\n        return existing.value;\n      }\n  \n      // Compute based on Ackermann function definition\n      let value: bigint;\n      try {\n        if (m === 0) {\n          value = BigInt(n + 1);\n        } else if (n === 0) {\n          value = this.computeAckermann(m - 1, 1);\n        } else {\n          const inner = this.computeAckermann(m, n - 1);\n          // Convert bigint to number for recursion, being careful about size\n          const innerNum = inner <= BigInt(Number.MAX_SAFE_INTEGER) \n            ? Number(inner) \n            : Number.MAX_SAFE_INTEGER;\n          value = this.computeAckermann(m - 1, innerNum);\n        }\n      } catch (error) {\n        // Handle stack overflow or computation limits\n        if (error instanceof RangeError) {\n          return BigInt(Number.MAX_SAFE_INTEGER);\n        }\n        throw error;\n      }\n  \n      return value;\n    }\n  \n    /**\n     * Adds a new node to the structure\n     */\n    public addNode(m: number, n: number): IAckermannNode {\n      const key = AckermannStructure.getNodeKey(m, n);\n      if (this.nodes.has(key)) {\n        return this.nodes.get(key)!;\n      }\n  \n      // Create new node\n      const value = this.computeAckermann(m, n);\n      const node: IAckermannNode = { m, n, value };\n      this.nodes.set(key, node);\n  \n      // Link to existing nodes\n      const prevMKey = AckermannStructure.getNodeKey(m - 1, n);\n      const prevNKey = AckermannStructure.getNodeKey(m, n - 1);\n  \n      if (this.nodes.has(prevMKey)) {\n        const prevM = this.nodes.get(prevMKey)!;\n        node.prevM = prevM;\n        prevM.nextM = node;\n      }\n  \n      if (this.nodes.has(prevNKey)) {\n        const prevN = this.nodes.get(prevNKey)!;\n        node.prevN = prevN;\n        prevN.nextN = node;\n      }\n  \n      // Update tracking\n      this.maxComputedM = Math.max(this.maxComputedM, m);\n      this.maxComputedN = Math.max(this.maxComputedN, n);\n      this.heap.push(value);\n  \n      return node;\n    }\n  \n    /**\n     * Builds nodes for a range of m and n values\n     */\n    public buildRange(mRange: number, nRange: number): void {\n      for (let m = 0; m <= mRange; m++) {\n        for (let n = 0; n <= nRange; n++) {\n          this.addNode(m, n);\n        }\n      }\n    }\n  \n    /**\n     * Gets the computation path to reach A(m,n)\n     */\n    public getComputationPath(m: number, n: number): ComputationStep[] {\n      const path: ComputationStep[] = [];\n      const key = AckermannStructure.getNodeKey(m, n);\n      let current = this.nodes.get(key);\n  \n      while (current) {\n        path.push({\n          m: current.m,\n          n: current.n,\n          value: current.value\n        });\n  \n        // Follow computation path backwards\n        if (current.m === 0) {\n          break;\n        } else if (current.n === 0) {\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, 1));\n        } else {\n          const prevN = this.nodes.get(AckermannStructure.getNodeKey(current.m, current.n - 1));\n          if (prevN) {\n            path.push({\n              m: prevN.m,\n              n: prevN.n,\n              value: prevN.value\n            });\n          }\n          // Convert bigint to number safely for the next lookup\n          const nextValue = prevN?.value ?? BigInt(0);\n          const safeNextValue = nextValue <= BigInt(Number.MAX_SAFE_INTEGER)\n            ? Number(nextValue)\n            : Number.MAX_SAFE_INTEGER;\n          current = this.nodes.get(AckermannStructure.getNodeKey(current.m - 1, safeNextValue));\n        }\n      }\n  \n      return path.reverse();\n    }\n  \n    /**\n     * Analyzes growth rate for a fixed m value\n     */\n    public analyzeGrowthRate(m: number): Map<number, GrowthAnalysis> {\n      const growth = new Map<number, GrowthAnalysis>();\n      let prevValue = BigInt(1);\n  \n      for (let n = 0; n <= this.maxComputedN; n++) {\n        const key = AckermannStructure.getNodeKey(m, n);\n        const node = this.nodes.get(key);\n        if (!node || node.value >= BigInt(Number.MAX_SAFE_INTEGER)) {\n          break;\n        }\n  \n        growth.set(n, {\n          value: node.value,\n          increase: node.value - prevValue,\n          multiplier: prevValue === BigInt(0) ? BigInt(0) : node.value / prevValue\n        });\n  \n        prevValue = node.value;\n      }\n  \n      return growth;\n    }\n  \n    /**\n     * Gets the largest computed value\n     */\n    public getLargestValue(): bigint {\n      return this.heap.peek() ?? BigInt(0);\n    }\n  \n    /**\n     * Gets a specific Ackermann value if it exists\n     */\n    public getValue(m: number, n: number): bigint | undefined {\n      return this.nodes.get(AckermannStructure.getNodeKey(m, n))?.value;\n    }\n  }\n  \n  export default AckermannStructure;","import { Comparator } from '@/core';\nimport { MinHeap, MaxHeap } from '../storage/Heap';\n\n/**\n * Interface for segment tree node operations\n */\nexport interface SegmentTreeNode<T> {  value: T;\n  lazy?: T;\n  start: number;\n  end: number;\n}\n\n/**\n * Type for BigArray operation result\n */\nexport type OperationResult<T> = {\n  success: boolean;\n  value?: T;\n  error?: string;\n};\n\n/**\n * Options for BigArray initialization\n */\nexport interface BigArrayOptions<T> {\n  initialCapacity?: number;\n  growthFactor?: number;\n  comparator?: Comparator<T>;\n}\n\n/**\n * A specialized array implementation for handling large numbers and providing\n * efficient operations with segment tree support\n */\nexport class BigArray<T> {\n  private data: T[];\n  private segmentTree: Array<SegmentTreeNode<T> | null>;\n  private readonly growthFactor: number;\n  private readonly comparator: Comparator<T>;\n  private size: number;\n  private capacity: number;\n\n  constructor(options: BigArrayOptions<T> = {}) {\n    const {\n      initialCapacity = 16,\n      growthFactor = 2,\n      comparator = ((a: T, b: T): -1 | 0 | 1 => {\n        if (a < b) return -1;\n        if (a > b) return 1;\n        return 0;\n      }) as Comparator<T>\n    } = options;\n\n    this.capacity = initialCapacity;\n    this.growthFactor = growthFactor;\n    this.comparator = comparator;\n    this.size = 0;\n    this.data = new Array(this.capacity);\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\n  }\n\n  /**\n   * Gets the current size of the array\n   */\n  public getSize(): number {\n    return this.size;\n  }\n\n  /**\n   * Gets the current capacity of the array\n   */\n  public getCapacity(): number {\n    return this.capacity;\n  }\n\n  /**\n   * Resizes the internal array when needed\n   */\n  private resize(newCapacity: number): void {\n    const newData = new Array(newCapacity);\n    for (let i = 0; i < this.size; i++) {\n      newData[i] = this.data[i];\n    }\n    this.data = newData;\n    this.capacity = newCapacity;\n    this.rebuildSegmentTree();\n  }\n\n  /**\n   * Appends an element to the end of the array\n   */\n  public push(value: T): OperationResult<number> {\n    try {\n      if (this.size >= this.capacity) {\n        this.resize(this.capacity * this.growthFactor);\n      }\n      this.data[this.size] = value;\n      this.updateSegmentTree(0, this.size, value);\n      this.size++;\n      return { success: true, value: this.size - 1 };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error during push'\n      };\n    }\n  }\n\n  /**\n   * Removes and returns the last element\n   */\n  public pop(): OperationResult<T> {\n    if (this.size === 0) {\n      return { success: false, error: 'Array is empty' };\n    }\n\n    const value = this.data[this.size - 1];\n    this.size--;\n    \n    // Shrink array if it's too sparse\n    if (this.size < this.capacity / (this.growthFactor * 2)) {\n      this.resize(Math.max(16, Math.floor(this.capacity / this.growthFactor)));\n    }\n\n    return { success: true, value };\n  }\n\n  /**\n   * Gets element at specified index\n   */\n  public get(index: number): OperationResult<T> {\n    if (index < 0 || index >= this.size) {\n      return { success: false, error: 'Index out of bounds' };\n    }\n    return { success: true, value: this.data[index] };\n  }\n\n  /**\n   * Sets element at specified index\n   */\n  public set(index: number, value: T): OperationResult<T> {\n    if (index < 0 || index >= this.size) {\n      return { success: false, error: 'Index out of bounds' };\n    }\n    \n    const oldValue = this.data[index];\n    this.data[index] = value;\n    this.updateSegmentTree(0, index, value);\n    \n    return { success: true, value: oldValue };\n  }\n\n  /**\n   * Rebuilds the segment tree after major changes\n   */\n  private rebuildSegmentTree(): void {\n    this.segmentTree = new Array(4 * this.capacity).fill(null);\n    if (this.size > 0) {\n      this.buildSegmentTree(0, 0, this.size - 1);\n    }\n  }\n\n  /**\n   * Builds a segment tree node recursively\n   */\n  private buildSegmentTree(node: number, start: number, end: number): void {\n    if (start === end) {\n      this.segmentTree[node] = {\n        value: this.data[start] as T,\n        start,\n        end\n      };\n      return;\n    }\n\n    const mid = Math.floor((start + end) / 2);\n    this.buildSegmentTree(2 * node + 1, start, mid);\n    this.buildSegmentTree(2 * node + 2, mid + 1, end);\n\n    const leftNode = this.segmentTree[2 * node + 1];\n    const rightNode = this.segmentTree[2 * node + 2];\n\n    if (leftNode && rightNode) {\n      this.segmentTree[node] = {\n        value: this.comparator(leftNode.value, rightNode.value) >= 0 \n          ? leftNode.value \n          : rightNode.value,\n        start,\n        end\n      };\n    }\n  }\n\n  /**\n   * Updates the segment tree after a value change\n   */\n  private updateSegmentTree(node: number, index: number, value: T): void {\n    if (!this.segmentTree[node]) {\n      return;\n    }\n\n    const currentNode = this.segmentTree[node]!;\n    if (currentNode.start === currentNode.end) {\n      currentNode.value = value;\n      return;\n    }\n\n    const mid = Math.floor((currentNode.start + currentNode.end) / 2);\n    if (index <= mid) {\n      this.updateSegmentTree(2 * node + 1, index, value);\n    } else {\n      this.updateSegmentTree(2 * node + 2, index, value);\n    }\n\n    const leftNode = this.segmentTree[2 * node + 1];\n    const rightNode = this.segmentTree[2 * node + 2];\n\n    if (leftNode && rightNode) {\n      currentNode.value = this.comparator(leftNode.value, rightNode.value) >= 0 \n        ? leftNode.value \n        : rightNode.value;\n    }\n  }\n\n  /**\n   * Queries the maximum value in a range\n   */\n  public queryRange(start: number, end: number): OperationResult<T> {\n    if (start < 0 || end >= this.size || start > end) {\n      return { success: false, error: 'Invalid range' };\n    }\n\n    const result = this.querySegmentTree(0, start, end);\n    return result \n      ? { success: true, value: result }\n      : { success: false, error: 'Range query failed' };\n  }\n\n  /**\n   * Recursively queries the segment tree\n   */\n  private querySegmentTree(node: number, queryStart: number, queryEnd: number): T | null {\n    const currentNode = this.segmentTree[node];\n    if (!currentNode) {\n      return null;\n    }\n\n    if (queryStart <= currentNode.start && queryEnd >= currentNode.end) {\n      return currentNode.value;\n    }\n\n    if (queryEnd < currentNode.start || queryStart > currentNode.end) {\n      return null;\n    }\n\n    const leftResult = this.querySegmentTree(2 * node + 1, queryStart, queryEnd);\n    const rightResult = this.querySegmentTree(2 * node + 2, queryStart, queryEnd);\n\n    if (leftResult === null) return rightResult;\n    if (rightResult === null) return leftResult;\n\n    return this.comparator(leftResult, rightResult) >= 0 ? leftResult : rightResult;\n  }\n\n  /**\n   * Creates a heap from the current array\n   */\n  public toHeap(isMin: boolean = true): MinHeap<T> | MaxHeap<T> {\n    const heap = isMin \n      ? new MinHeap<T>(this.comparator)\n      : new MaxHeap<T>(this.comparator);\n      \n    for (let i = 0; i < this.size; i++) {\n      if (this.data[i] !== undefined) {\n        if (this.data[i] !== undefined) {\n          heap.push(this.data[i] as T);\n        }\n      }\n    }\n    \n    return heap;\n  }\n\n  /**\n   * Sorts the array in-place\n   */\n  public sort(ascending: boolean = true): void {\n    const heap = this.toHeap(!ascending);\n    for (let i = this.size - 1; i >= 0; i--) {\n      const value = heap.pop();\n      if (value !== undefined) {\n        this.data[i] = value;\n      }\n    }\n    this.rebuildSegmentTree();\n  }\n\n  /**\n   * Returns array as native array\n   */\n  public toArray(): T[] {\n    return this.data.slice(0, this.size);\n  }\n}\n\nexport default BigArray;","import { Comparator } from \"@/core\";\n\n/**\n * Interface for tree node statistics\n */\ninterface NodeStats {\n  height: number;\n  size: number;\n  sum: bigint;\n  min: bigint;\n  max: bigint;\n}\n\n/**\n * Interface for tree traversal configuration\n */\ninterface TraversalConfig {\n  includeStats?: boolean;\n  skipSubtrees?: boolean;\n  maxDepth?: number;\n}\n\n/**\n * Class representing a node in the number tree\n */\nclass NumberNode {\n  value: bigint;\n  left: NumberNode | null;\n  right: NumberNode | null;\n  parent: NumberNode | null;\n  height: number;\n  size: number;\n  sum: bigint;\n\n  constructor(value: bigint | string | number) {\n    this.value = typeof value === 'bigint' ? value : BigInt(value);\n    this.left = null;\n    this.right = null;\n    this.parent = null;\n    this.height = 1;\n    this.size = 1;\n    this.sum = this.value;\n  }\n\n  /**\n   * Updates node statistics based on children\n   */\n  updateStats(): void {\n    this.height = 1 + Math.max(\n      this.left?.height ?? 0,\n      this.right?.height ?? 0\n    );\n    this.size = 1 + (this.left?.size ?? 0) + (this.right?.size ?? 0);\n    this.sum = this.value + \n      (this.left?.sum ?? BigInt(0)) + \n      (this.right?.sum ?? BigInt(0));\n  }\n\n  /**\n   * Gets balance factor of the node\n   */\n  getBalance(): number {\n    return (this.left?.height ?? 0) - (this.right?.height ?? 0);\n  }\n\n  /**\n   * Gets complete statistics for the node and its subtree\n   */\n  getStats(): NodeStats {\n    return {\n      height: this.height,\n      size: this.size,\n      sum: this.sum,\n      min: this.findMin().value,\n      max: this.findMax().value\n    };\n  }\n\n  /**\n   * Finds minimum value node in the subtree\n   */\n  findMin(): NumberNode {\n    let current: NumberNode = this;\n    while (current.left) {\n      current = current.left;\n    }\n    return current;\n  }\n\n  /**\n   * Finds maximum value node in the subtree\n   */\n  findMax(): NumberNode {\n    let current: NumberNode = this;\n    while (current.right) {\n      current = current.right;\n    }\n    return current;\n  }\n}\n\n/**\n * AVL Tree implementation specialized for handling large numbers\n */\nexport class NumberTree {\n  private root: NumberNode | null;\n  private readonly comparator: Comparator<bigint>;\n\n  constructor(comparator?: Comparator<bigint>) {\n    this.root = null;\n    this.comparator = comparator ?? ((a: bigint, b: bigint): -1 | 0 | 1 => {\n      if (a < b) return -1;\n      if (a > b) return 1;\n      return 0;\n    });\n  }\n\n  /**\n   * Gets the root node if it exists\n   */\n  public getRoot(): NumberNode | null {\n    return this.root;\n  }\n\n  /**\n   * Inserts a new value into the tree\n   */\n  public insert(value: bigint | string | number): NumberNode {\n    const newValue = typeof value === 'bigint' ? value : BigInt(value);\n    this.root = this.insertNode(this.root, newValue);\n    return this.find(newValue)!;\n  }\n\n  /**\n   * Recursively inserts a new node\n   */\n  private insertNode(node: NumberNode | null, value: bigint): NumberNode {\n    if (!node) {\n      return new NumberNode(value);\n    }\n\n    const compareResult = this.comparator(value, node.value);\n    if (compareResult < 0) {\n      node.left = this.insertNode(node.left, value);\n      node.left.parent = node;\n    } else if (compareResult > 0) {\n      node.right = this.insertNode(node.right, value);\n      node.right.parent = node;\n    } else {\n      return node; // Duplicate value, return existing node\n    }\n\n    node.updateStats();\n    return this.balance(node);\n  }\n\n  /**\n   * Balances a node using AVL rotations\n   */\n  private balance(node: NumberNode): NumberNode {\n    const balance = node.getBalance();\n\n    // Left heavy\n    if (balance > 1) {\n      if (node.left && node.left.getBalance() < 0) {\n        node.left = this.rotateLeft(node.left);\n      }\n      return this.rotateRight(node);\n    }\n\n    // Right heavy\n    if (balance < -1) {\n      if (node.right && node.right.getBalance() > 0) {\n        node.right = this.rotateRight(node.right);\n      }\n      return this.rotateLeft(node);\n    }\n\n    return node;\n  }\n\n  /**\n   * Performs left rotation\n   */\n  private rotateLeft(node: NumberNode): NumberNode {\n    const rightChild = node.right!;\n    const rightLeftChild = rightChild.left;\n\n    rightChild.left = node;\n    node.right = rightLeftChild;\n\n    if (rightLeftChild) {\n      rightLeftChild.parent = node;\n    }\n    rightChild.parent = node.parent;\n    node.parent = rightChild;\n\n    node.updateStats();\n    rightChild.updateStats();\n\n    return rightChild;\n  }\n\n  /**\n   * Performs right rotation\n   */\n  private rotateRight(node: NumberNode): NumberNode {\n    const leftChild = node.left!;\n    const leftRightChild = leftChild.right;\n\n    leftChild.right = node;\n    node.left = leftRightChild;\n\n    if (leftRightChild) {\n      leftRightChild.parent = node;\n    }\n    leftChild.parent = node.parent;\n    node.parent = leftChild;\n\n    node.updateStats();\n    leftChild.updateStats();\n\n    return leftChild;\n  }\n\n  /**\n   * Removes a value from the tree\n   */\n  public remove(value: bigint | string | number): boolean {\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\n    const nodeToRemove = this.find(searchValue);\n    \n    if (!nodeToRemove) {\n      return false;\n    }\n\n    this.root = this.removeNode(this.root, searchValue);\n    return true;\n  }\n\n  /**\n   * Recursively removes a node\n   */\n  private removeNode(node: NumberNode | null, value: bigint): NumberNode | null {\n    if (!node) {\n      return null;\n    }\n\n    const compareResult = this.comparator(value, node.value);\n    if (compareResult < 0) {\n      node.left = this.removeNode(node.left, value);\n      if (node.left) {\n        node.left.parent = node;\n      }\n    } else if (compareResult > 0) {\n      node.right = this.removeNode(node.right, value);\n      if (node.right) {\n        node.right.parent = node;\n      }\n    } else {\n      // Node to delete found\n      if (!node.left) {\n        return node.right;\n      }\n      if (!node.right) {\n        return node.left;\n      }\n\n      // Node has two children\n      const successor = node.right.findMin();\n      node.value = successor.value;\n      node.right = this.removeNode(node.right, successor.value);\n      if (node.right) {\n        node.right.parent = node;\n      }\n    }\n\n    node.updateStats();\n    return this.balance(node);\n  }\n\n  /**\n   * Finds a node by value\n   */\n  public find(value: bigint | string | number): NumberNode | null {\n    const searchValue = typeof value === 'bigint' ? value : BigInt(value);\n    let current = this.root;\n\n    while (current) {\n      const compareResult = this.comparator(searchValue, current.value);\n      if (compareResult === 0) {\n        return current;\n      }\n      current = compareResult < 0 ? current.left : current.right;\n    }\n\n    return null;\n  }\n\n  /**\n   * Traverses the tree in specified order and returns values\n   */\n  public traverse(order: 'inOrder' | 'preOrder' | 'postOrder' = 'inOrder', \n                 config: TraversalConfig = {}): bigint[] {\n    const result: bigint[] = [];\n    \n    const traverse = (node: NumberNode | null, depth: number = 0): void => {\n      if (!node || (config.maxDepth !== undefined && depth >= config.maxDepth)) {\n        return;\n      }\n\n      if (order === 'preOrder') {\n        result.push(node.value);\n      }\n\n      if (!config.skipSubtrees) {\n        traverse(node.left, depth + 1);\n      }\n\n      if (order === 'inOrder') {\n        result.push(node.value);\n      }\n\n      if (!config.skipSubtrees) {\n        traverse(node.right, depth + 1);\n      }\n\n      if (order === 'postOrder') {\n        result.push(node.value);\n      }\n    };\n\n    traverse(this.root);\n    return result;\n  }\n\n  /**\n   * Gets overall tree statistics\n   */\n  public getTreeStats(): NodeStats | null {\n    return this.root?.getStats() ?? null;\n  }\n\n  /**\n   * Gets the nth smallest value in the tree\n   */\n  public getNthValue(n: number): bigint | null {\n    if (!this.root || n < 1 || n > this.root.size) {\n      return null;\n    }\n\n    const findNth = (node: NumberNode | null, position: number): bigint | null => {\n      if (!node) {\n        return null;\n      }\n\n      const leftSize = node.left?.size ?? 0;\n      \n      if (position === leftSize + 1) {\n        return node.value;\n      }\n      \n      if (position <= leftSize) {\n        return findNth(node.left, position);\n      }\n      \n      return findNth(node.right, position - leftSize - 1);\n    };\n\n    return findNth(this.root, n);\n  }\n\n  /**\n   * Gets a range of values between start and end (inclusive)\n   */\n  public getRange(start: bigint | string | number, \n                 end: bigint | string | number): bigint[] {\n    const startValue = typeof start === 'bigint' ? start : BigInt(start);\n    const endValue = typeof end === 'bigint' ? end : BigInt(end);\n    const result: bigint[] = [];\n\n    const collectRange = (node: NumberNode | null): void => {\n      if (!node) {\n        return;\n      }\n\n      if (this.comparator(node.value, startValue) >= 0 && \n          this.comparator(node.value, endValue) <= 0) {\n        collectRange(node.left);\n        result.push(node.value);\n        collectRange(node.right);\n      } else if (this.comparator(node.value, startValue) > 0) {\n        collectRange(node.left);\n      } else {\n        collectRange(node.right);\n      }\n    };\n\n    collectRange(this.root);\n    return result;\n  }\n}\n\nexport default NumberTree;","import { validateNonNegative, ValidationError, OverflowError } from '../utils/validation';\n\n/**\n * Interface for power tower computation options\n */\ninterface PowerTowerOptions {\n  maxHeight?: number;\n  maxValue?: bigint;\n  checkOverflow?: boolean;\n  precision?: number;\n}\n\n/**\n * Interface for power tower node to track computation state\n */\ninterface PowerTowerNode {\n  value: bigint;\n  height: number;\n  evaluated: boolean;\n  previous: PowerTowerNode | null;\n  next: PowerTowerNode | null;\n}\n\n/**\n * Default options for power tower computations\n */\nconst DEFAULT_OPTIONS: Required<PowerTowerOptions> = {\n  maxHeight: 100,\n  maxValue: BigInt(Number.MAX_SAFE_INTEGER),\n  checkOverflow: true,\n  precision: 0\n};\n\n/**\n * Class representing a power tower (tetration) computation structure\n * Handles expressions of the form: ab = a^(a^(a^...)) (b times)\n */\nexport class PowerTower {\n  private readonly options: Required<PowerTowerOptions>;\n  private head: PowerTowerNode | null;\n  private tail: PowerTowerNode | null;\n  private size: number;\n\n  constructor(options: PowerTowerOptions = {}) {\n    this.options = { ...DEFAULT_OPTIONS, ...options };\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  /**\n   * Creates a new power tower node\n   */\n  private createNode(value: bigint, height: number): PowerTowerNode {\n    return {\n      value,\n      height,\n      evaluated: false,\n      previous: null,\n      next: null\n    };\n  }\n\n  /**\n   * Validates power tower height\n   */\n  private validateHeight(height: number): void {\n    if (height < 0) {\n      throw new ValidationError('Height cannot be negative');\n    }\n    if (height > this.options.maxHeight) {\n      throw new ValidationError(`Height exceeds maximum of ${this.options.maxHeight}`);\n    }\n  }\n\n  /**\n   * Validates value for computation\n   */\n  private validateValue(value: bigint): void {\n    validateNonNegative(value);\n    if (this.options.checkOverflow && value > this.options.maxValue) {\n      throw new OverflowError(`Value exceeds maximum of ${this.options.maxValue}`);\n    }\n  }\n\n  /**\n   * Computes power with overflow checking\n   */\n  private computePower(base: bigint, exponent: bigint): bigint {\n    if (exponent === BigInt(0)) {\n      return BigInt(1);\n    }\n    if (exponent === BigInt(1)) {\n      return base;\n    }\n\n    let result = base;\n    for (let i = BigInt(1); i < exponent; i++) {\n      if (this.options.checkOverflow) {\n        // Check if next multiplication would overflow\n        const next = result * base;\n        if (next > this.options.maxValue) {\n          throw new OverflowError('Power computation would overflow');\n        }\n        result = next;\n      } else {\n        result *= base;\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Builds a power tower of specified height with given base\n   */\n  public build(base: bigint | number | string, height: number): void {\n    this.validateHeight(height);\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\n    this.validateValue(baseValue);\n\n    this.clear(); // Clear existing tower\n\n    for (let i = 0; i < height; i++) {\n      const node = this.createNode(baseValue, i + 1);\n      if (!this.head) {\n        this.head = node;\n        this.tail = node;\n      } else {\n        node.previous = this.tail;\n        this.tail!.next = node;\n        this.tail = node;\n      }\n      this.size++;\n    }\n  }\n\n  /**\n   * Evaluates the power tower up to specified height\n   */\n  public evaluate(height?: number): bigint {\n    if (!this.head) {\n      return BigInt(1); // Empty tower evaluates to 1\n    }\n\n    const targetHeight = height ?? this.size;\n    this.validateHeight(targetHeight);\n\n    let current = this.head;\n    let result = current.value;\n    let currentHeight = 1;\n\n    try {\n      while (current.next && currentHeight < targetHeight) {\n        result = this.computePower(current.next.value, result);\n        current.evaluated = true;\n        current = current.next;\n        currentHeight++;\n      }\n      current.evaluated = true;\n      return result;\n    } catch (error) {\n      if (error instanceof OverflowError) {\n        // Mark nodes up to current height as evaluated\n        let node = this.head;\n        while (node !== current) {\n          node.evaluated = true;\n          node = node.next!;\n        }\n        throw error;\n      }\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the current height of the power tower\n   */\n  public getHeight(): number {\n    return this.size;\n  }\n\n  /**\n   * Checks if the tower can be evaluated to a given height\n   */\n  public isComputable(height?: number): boolean {\n    try {\n      const targetHeight = height ?? this.size;\n      this.validateHeight(targetHeight);\n      \n      // Check first few levels without full computation\n      let current = this.head;\n      let currentHeight = 0;\n      \n      while (current && currentHeight < targetHeight) {\n        // Quick check for obvious overflow conditions\n        if (current.value > BigInt(4) && currentHeight > 3) {\n          return false;\n        }\n        current = current.next;\n        currentHeight++;\n      }\n      \n      // Try actual computation with a lower overflow threshold\n      const safeOptions = { ...this.options, maxValue: this.options.maxValue >> BigInt(1) };\n      const safeTower = new PowerTower(safeOptions);\n      safeTower.build(this.head!.value, targetHeight);\n      safeTower.evaluate();\n      \n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Gets the computation state at each level\n   */\n  public getState(): { height: number; value: bigint; evaluated: boolean }[] {\n    const state = [];\n    let current = this.head;\n    \n    while (current) {\n      state.push({\n        height: current.height,\n        value: current.value,\n        evaluated: current.evaluated\n      });\n      current = current.next;\n    }\n    \n    return state;\n  }\n\n  /**\n   * Clears the power tower\n   */\n  public clear(): void {\n    this.head = null;\n    this.tail = null;\n    this.size = 0;\n  }\n\n  /**\n   * Gets the maximum computationally feasible height for a given base\n   */\n  public static getMaxFeasibleHeight(base: bigint | number | string): number {\n    const baseValue = typeof base === 'bigint' ? base : BigInt(base);\n    validateNonNegative(baseValue);\n\n    if (baseValue === BigInt(0)) return 0;\n    if (baseValue === BigInt(1)) return Infinity;\n    if (baseValue === BigInt(2)) return 4; // 24 is already enormous\n    if (baseValue === BigInt(3)) return 3; // 33 is already astronomical\n    if (baseValue === BigInt(4)) return 2;\n    return 1; // For bases > 4, only height 1 is reliably computable\n  }\n\n  /**\n   * Creates a string representation of the power tower\n   */\n  public toString(): string {\n    if (!this.head) {\n      return \"Empty Tower\";\n    }\n\n    let result = this.head.value.toString();\n    let current = this.head;\n    \n    while (current.next) {\n      result = `${current.next.value}^(${result})`;\n      current = current.next;\n    }\n    \n    return result;\n  }\n}\n\nexport default PowerTower;","/**\n * Formatting utilities for Hypernum library\n * Provides functions for formatting large numbers and converting between different representations\n */\n\nimport { ValidationError } from './validation';\n\n// Types for formatting options\nexport interface FormatOptions {\n  notation?: 'standard' | 'scientific' | 'engineering' | 'compact';\n  precision?: number;\n  grouping?: boolean;\n  groupSize?: number;\n  decimalSeparator?: string;\n  groupSeparator?: string;\n}\n\nexport interface ScientificNotation {\n  coefficient: string;\n  exponent: number;\n}\n\nexport interface ScientificNotation {\n  coefficient: string;\n  exponent: number;\n}\n\n// Default formatting options\nconst DEFAULT_OPTIONS: Required<FormatOptions> = {\n  notation: 'standard',\n  precision: 0,\n  grouping: true,\n  groupSize: 3,\n  decimalSeparator: '.',\n  groupSeparator: ',',\n};\n\n/**\n * Formats a BigInt value according to specified options\n */\nexport const formatBigInt = (value: bigint, options: FormatOptions = {}): string => {\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\n  \n  // Handle negative numbers\n  const isNegative = value < BigInt(0);\n  const absValue = isNegative ? -value : value;\n  \n  let result: string;\n  switch (opts.notation) {\n    case 'scientific':\n      result = formatScientific(absValue, opts).coefficient + 'e' + \n               formatScientific(absValue, opts).exponent;\n      break;\n    case 'engineering':\n      result = formatEngineering(absValue, opts);\n      break;\n    case 'compact':\n      result = formatCompact(absValue, opts);\n      break;\n    default:\n      result = formatStandard(absValue, opts);\n  }\n  \n  return isNegative ? '-' + result : result;\n};\n\n/**\n * Formats a number in standard notation with grouping\n */\nconst formatStandard = (value: bigint, options: Required<FormatOptions>): string => {\n  let str = value.toString();\n  \n  if (!options.grouping) {\n    return str;\n  }\n  \n  // Apply grouping from the right\n  const result: string[] = [];\n  let position = str.length;\n  \n  while (position > 0) {\n    const start = Math.max(0, position - options.groupSize);\n    result.unshift(str.slice(start, position));\n    position = start;\n  }\n  \n  return result.join(options.groupSeparator);\n};\n\n/**\n * Converts a number to scientific notation\n */\nconst formatScientific = (value: bigint, options: Required<FormatOptions>): ScientificNotation => {\n  if (value === BigInt(0)) {\n    return { coefficient: '0', exponent: 0 };\n  }\n  \n  const str = value.toString();\n  const exponent = str.length - 1;\n  \n  let coefficient = str[0] || '';\n  coefficient += options.decimalSeparator + str.slice(1, options.precision + 1);\n  \n  return {\n    coefficient: coefficient,\n    exponent: exponent,\n  };\n};\n\n/**\n * Formats a number in engineering notation (exponents divisible by 3)\n */\nconst formatEngineering = (value: bigint, options: Required<FormatOptions>): string => {\n  if (value === BigInt(0)) {\n    return '0';\n  }\n  \n  const str = value.toString();\n  const len = str.length;\n  const exponent = Math.floor((len - 1) / 3) * 3;\n  \n  let coefficient = '';\n  const digitsBeforePoint = len - exponent;\n  \n  for (let i = 0; i < Math.min(len, digitsBeforePoint + options.precision); i++) {\n    if (i === digitsBeforePoint && i < len) {\n      coefficient += options.decimalSeparator;\n    }\n    coefficient += str[i];\n  }\n  \n  return `${coefficient}e${exponent}`;\n};\n\n/**\n * Formats a number in compact notation (K, M, B, T)\n */\nconst formatCompact = (value: bigint, options: Required<FormatOptions>): string => {\n  const suffixes = ['', 'K', 'M', 'B', 'T', 'Q'];\n  const str = value.toString();\n  const len = str.length;\n  \n  if (len <= 3) {\n    return formatStandard(value, options);\n  }\n  \n  const suffixIndex = Math.min(Math.floor((len - 1) / 3), suffixes.length - 1);\n  const suffix = suffixes[suffixIndex];\n  \n  const scale = BigInt(10) ** BigInt(suffixIndex * 3);\n  const scaledValue = value / scale;\n  \n  let result = scaledValue.toString();\n  if (options.precision > 0) {\n    const remainder = value % scale;\n    if (remainder > BigInt(0)) {\n      const decimalPart = remainder.toString().padStart(3, '0').slice(0, options.precision);\n      result += options.decimalSeparator + decimalPart;\n    }\n  }\n  \n  return result + suffix;\n};\n\n/**\n * Parses a formatted string back to BigInt\n */\nexport const parseBigIntString = (str: string, options: FormatOptions = {}): bigint => {\n  const opts: Required<FormatOptions> = { ...DEFAULT_OPTIONS, ...options };\n  \n  // Remove grouping separators\n  let cleanStr = str.replace(new RegExp(`\\\\${opts.groupSeparator}`, 'g'), '');\n  \n  // Handle scientific notation\n  if (cleanStr.toLowerCase().includes('e')) {\n    const [coefficient, exponent] = cleanStr.toLowerCase().split('e');\n    const base = BigInt(10);\n    const exp = BigInt(exponent || '0');\n    return BigInt(Math.floor(Number(coefficient))) * (base ** exp);\n  }\n  \n  // Handle suffixes\n  const suffixMap = new Map([\n    ['k', BigInt(1000)],\n    ['m', BigInt(1000000)],\n    ['b', BigInt(1000000000)],\n    ['t', BigInt(1000000000000)],\n    ['q', BigInt(1000000000000000)],\n  ]);\n  \n  const suffix = cleanStr.slice(-1).toLowerCase();\n  const multiplier = suffixMap.get(suffix);\n  if (multiplier) {\n    cleanStr = cleanStr.slice(0, -1);\n    const value = BigInt(Math.floor(Number(cleanStr)));\n    return value * multiplier;\n  }\n  \n  // Handle regular numbers\n  return BigInt(cleanStr);\n};\n\n/**\n * Normalizes a string representation for comparison\n */\nexport const normalizeNumberString = (str: string): string => {\n  // Remove all spaces and separators\n  str = str.replace(/[\\s,]/g, '');\n  \n  // Handle scientific notation\n  if (str.toLowerCase().includes('e')) {\n    const [coefficient, exponent] = str.toLowerCase().split('e');\n    const exp = parseInt(exponent || '0');\n    const coef = parseFloat(coefficient || '0');\n    return (coef * Math.pow(10, exp)).toString();\n  }\n  \n  return str;\n};\n\n/**\n * Formats a number for display in a tree structure\n */\nexport const formatTreeValue = (value: bigint, depth: number = 0): string => {\n  const indent = '  '.repeat(depth);\n  return `${indent}${formatBigInt(value, { notation: 'compact' })}`;\n};\n\n/**\n * Formats a range of numbers for display\n */\nexport const formatRange = (start: bigint, end: bigint, options: FormatOptions = {}): string => {\n  return `[${formatBigInt(start, options)} ... ${formatBigInt(end, options)}]`;\n};\n\n/**\n * Formats a percentage\n */\nexport const formatPercentage = (value: bigint, total: bigint, precision: number = 2): string => {\n  if (total === BigInt(0)) {\n    throw new ValidationError('Cannot calculate percentage with zero total');\n  }\n  \n  const percentage = (Number(value) * 100) / Number(total);\n  return `${percentage.toFixed(precision)}%`;\n};","/**\n * Main Hypernum class that provides a high-level interface to all library functionality\n */\n\n\nimport {\n  DEFAULT_OPTIONS,\n  FEATURES,\n  MAX_PRECISION,\n  MAX_COMPUTATION_STEPS\n} from './constants';\nimport { \n  HypernumError, \n  ValidationError, \n  OverflowError \n} from './errors';\n\n\n// Import all operations and structures\nimport * as arithmetic from '../operations/arithmetic';\nimport * as bitwise from '../operations/bitwise';\nimport * as power from '../operations/power';\nimport { BigArray, NumberTree, AckermannStructure } from '../structures';\nimport * as formatting from '../utils/formatting';\nimport * as validation from '../utils/validation';\nimport * as precision from '../utils/precision';\nimport { MinHeap, MaxHeap } from '@/storage';\n/**\n * Configuration options for Hypernum instance\n */\nexport interface HypernumConfig {\n  precision?: number;\n  roundingMode?: precision.RoundingMode;\n  checkOverflow?: boolean;\n  maxSteps?: number;\n  debug?: boolean;\n}\n\nexport class Hypernum {\n  private readonly config: Required<HypernumConfig>;\n  private readonly structures: {\n    arrays: Map<string, BigArray<bigint>>;\n    trees: Map<string, NumberTree>;\n    heaps: Map<string, MinHeap<bigint> | MaxHeap<bigint>>;\n  };\n\n  constructor(config: HypernumConfig = {}) {\n    this.config = {\n      precision: config.precision ?? DEFAULT_OPTIONS.precision,\n      roundingMode: config.roundingMode ?? DEFAULT_OPTIONS.roundingMode as precision.RoundingMode,\n      checkOverflow: config.checkOverflow ?? DEFAULT_OPTIONS.checkOverflow,\n      maxSteps: config.maxSteps ?? DEFAULT_OPTIONS.maxSteps,\n      debug: config.debug ?? FEATURES.DEBUG_MODE\n    };\n\n    // Validate configuration\n    if (this.config.precision < 0 || this.config.precision > MAX_PRECISION) {\n      throw new ValidationError(`Precision must be between 0 and ${MAX_PRECISION}`);\n    }\n    if (this.config.maxSteps < 1 || this.config.maxSteps > MAX_COMPUTATION_STEPS) {\n      throw new ValidationError(`Max steps must be between 1 and ${MAX_COMPUTATION_STEPS}`);\n    }\n\n    // Initialize data structure storage\n    this.structures = {\n      arrays: new Map(),\n      trees: new Map(),\n      heaps: new Map()\n    };\n  }\n\n  // Arithmetic Operations\n  public add(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.add(a, b, this.config);\n  }\n\n  public subtract(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.subtract(a, b, this.config);\n  }\n\n  public multiply(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.multiply(a, b, this.config);\n  }\n\n  public divide(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.divide(a, b, this.config);\n  }\n\n  public mod(a: bigint | string | number, b: bigint | string | number): bigint {\n    return arithmetic.remainder(a, b, this.config);\n  }\n\n  // Power Operations\n  public power(base: bigint | string | number, exponent: bigint | string | number): bigint {\n    return power.power(base, exponent, this.config);\n  }\n\n  public sqrt(value: bigint | string | number): bigint {\n    return power.sqrt(value, this.config);\n  }\n\n  public nthRoot(value: bigint | string | number, n: bigint | string | number): bigint {\n    return power.nthRoot(value, n, this.config);\n  }\n\n  // Bitwise Operations\n  public and(a: bigint | string | number, b: bigint | string | number): bigint {\n    return bitwise.and(a, b);\n  }\n\n  public or(a: bigint | string | number, b: bigint | string | number): bigint {\n    return bitwise.or(a, b);\n  }\n\n  public xor(a: bigint | string | number, b: bigint | string | number): bigint {\n    return bitwise.xor(a, b);\n  }\n\n  public not(value: bigint | string | number): bigint {\n    return bitwise.not(value);\n  }\n /**\n   * Calculates the greatest common divisor of two numbers\n   */\n public gcd(a: bigint | string | number, b: bigint | string | number): bigint {\n  return arithmetic.gcd(a, b);\n}\n\n/**\n * Calculates the least common multiple of two numbers\n */\npublic lcm(a: bigint | string | number, b: bigint | string | number): bigint {\n  return arithmetic.lcm(a, b);\n}\n  // Data Structure Management\n  public createArray(id: string): BigArray<bigint> {\n    if (this.structures.arrays.has(id)) {\n      throw new ValidationError(`Array with id '${id}' already exists`);\n    }\n    const array = new BigArray<bigint>();\n    this.structures.arrays.set(id, array);\n    return array;\n  }\n\n  public getArray(id: string): BigArray<bigint> {\n    const array = this.structures.arrays.get(id);\n    if (!array) {\n      throw new ValidationError(`Array with id '${id}' not found`);\n    }\n    return array;\n  }\n\n  public createTree(id: string): NumberTree {\n    if (this.structures.trees.has(id)) {\n      throw new ValidationError(`Tree with id '${id}' already exists`);\n    }\n    const tree = new NumberTree();\n    this.structures.trees.set(id, tree);\n    return tree;\n  }\n\n  public getTree(id: string): NumberTree {\n    const tree = this.structures.trees.get(id);\n    if (!tree) {\n      throw new ValidationError(`Tree with id '${id}' not found`);\n    }\n    return tree;\n  }\n\n  public createHeap(id: string, isMinHeap: boolean = true): MinHeap<bigint> | MaxHeap<bigint> {\n    if (this.structures.heaps.has(id)) {\n      throw new ValidationError(`Heap with id '${id}' already exists`);\n    }\n    const heap = isMinHeap ? new MinHeap<bigint>(this.compareValues) : new MaxHeap<bigint>(this.compareValues);\n    this.structures.heaps.set(id, heap);\n    return heap;\n  }\n\n  public getHeap(id: string): MinHeap<bigint> | MaxHeap<bigint> {\n    const heap = this.structures.heaps.get(id);\n    if (!heap) {\n      throw new ValidationError(`Heap with id '${id}' not found`);\n    }\n    return heap;\n  }\n\n  // Special Functions\n  public createAckermannStructure(): AckermannStructure {\n    return new AckermannStructure();\n  }\n\n  // Formatting and Validation\n  public format(value: bigint | string | number, options?: formatting.FormatOptions): string {\n    const bigValue = validation.toBigInt(value);\n    return formatting.formatBigInt(bigValue, options);\n  }\n\n  public validate(value: unknown): boolean {\n    try {\n      validation.toBigInt(value);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  // Configuration Management\n  public updateConfig(newConfig: Partial<HypernumConfig>): void {\n    Object.assign(this.config, newConfig);\n  }\n\n  public getConfig(): Readonly<Required<HypernumConfig>> {\n    return { ...this.config };\n  }\n\n  // Utility Functions\n  private compareValues(a: bigint, b: bigint): -1 | 0 | 1 {\n    if (a < b) return -1;\n    if (a > b) return 1;\n    return 0;\n  }\n\n  // Cleanup\n  public dispose(): void {\n    this.structures.arrays.clear();\n    this.structures.trees.clear();\n    this.structures.heaps.clear();\n  }\n}\n\n// Export additional types and utilities\nexport {\n  HypernumError,\n  ValidationError,\n  OverflowError,\n  precision,\n  formatting,\n  validation\n};\n\nexport default Hypernum;","/**\n * Comparison operations module for Hypernum library\n * Provides functions for comparing large numbers with precision support\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n    normalizePrecision,\n  } from '../utils/precision';\n  \n  /**\n   * Options for comparison operations\n   */\n  export interface ComparisonOptions {\n    precision?: number;\n    roundingMode?: RoundingMode;\n    tolerance?: number;\n  }\n  \n  const DEFAULT_OPTIONS: Required<ComparisonOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    tolerance: 0\n  };\n  \n  /**\n   * Result type for comparison operations\n   * -1: first value is less than second value\n   *  0: values are equal\n   *  1: first value is greater than second value\n   */\n  export type ComparisonResult = -1 | 0 | 1;\n  \n  /**\n   * Compares two numbers with optional precision\n   */\n  export function compare(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): ComparisonResult {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigA = toBigInt(a);\n    const bigB = toBigInt(b);\n  \n    if (opts.precision === 0 && opts.tolerance === 0) {\n      if (bigA < bigB) return -1;\n      if (bigA > bigB) return 1;\n      return 0;\n    }\n  \n    const [scaledA, scaledB] = normalizePrecision(bigA, bigB, opts.precision, opts.precision);\n    \n    if (opts.tolerance > 0) {\n      const diff = scaledA - scaledB;\n      const toleranceValue = BigInt(10) ** BigInt(opts.tolerance);\n      \n      if (diff < -toleranceValue) return -1;\n      if (diff > toleranceValue) return 1;\n      return 0;\n    }\n  \n    if (scaledA < scaledB) return -1;\n    if (scaledA > scaledB) return 1;\n    return 0;\n  }\n  \n  /**\n   * Checks if two numbers are equal\n   */\n  export function equals(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return compare(a, b, options) === 0;\n  }\n  \n  /**\n   * Checks if first number is less than second\n   */\n  export function lessThan(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return compare(a, b, options) === -1;\n  }\n  \n  /**\n   * Checks if first number is less than or equal to second\n   */\n  export function lessThanOrEqual(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    const result = compare(a, b, options);\n    return result === -1 || result === 0;\n  }\n  \n  /**\n   * Checks if first number is greater than second\n   */\n  export function greaterThan(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return compare(a, b, options) === 1;\n  }\n  \n  /**\n   * Checks if first number is greater than or equal to second\n   */\n  export function greaterThanOrEqual(\n    a: bigint | string | number,\n    b: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    const result = compare(a, b, options);\n    return result === 1 || result === 0;\n  }\n  \n  /**\n   * Checks if a number is between two others (inclusive)\n   */\n  export function between(\n    value: bigint | string | number,\n    min: bigint | string | number,\n    max: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): boolean {\n    return greaterThanOrEqual(value, min, options) && lessThanOrEqual(value, max, options);\n  }\n  \n  /**\n   * Finds the maximum value in an array of numbers\n   */\n  export function max(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): bigint {\n    if (values.length === 0) {\n      throw new ValidationError('Cannot find maximum of empty array');\n    }\n  \n    return values.reduce<bigint>((max, current) => {\n      const bigMax = toBigInt(max);\n      const bigCurrent = toBigInt(current);\n      return greaterThan(bigCurrent, bigMax, options) ? bigCurrent : bigMax;\n    }, toBigInt(values[0]));\n  }\n  \n  /**\n   * Finds the minimum value in an array of numbers\n   */\n  export function min(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): bigint {\n    if (values.length === 0) {\n      throw new ValidationError('Cannot find minimum of empty array');\n    }\n  \n    return values.reduce<bigint>((min, current) => {\n      const bigMin = toBigInt(min);\n      const bigCurrent = toBigInt(current);\n      return lessThan(bigCurrent, bigMin, options) ? bigCurrent : bigMin;\n    }, toBigInt(values[0]));\n  }\n  \n  /**\n   * Clamps a value between minimum and maximum bounds\n   */\n  export function clamp(\n    value: bigint | string | number,\n    min: bigint | string | number,\n    max: bigint | string | number,\n    options: ComparisonOptions = {}\n  ): bigint {\n    const bigValue = toBigInt(value);\n    const bigMin = toBigInt(min);\n    const bigMax = toBigInt(max);\n  \n    if (lessThan(bigMax, bigMin, options)) {\n      throw new ValidationError('Maximum bound must be greater than or equal to minimum bound');\n    }\n  \n    if (lessThan(bigValue, bigMin, options)) return bigMin;\n    if (greaterThan(bigValue, bigMax, options)) return bigMax;\n    return bigValue;\n  }\n  \n  /**\n   * Checks if all values in array are equal within tolerance\n   */\n  export function allEqual(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): boolean {\n    if (values.length <= 1) return true;\n  \n    const first = toBigInt(values[0]);\n    return values.every(value => equals(value, first, options));\n  }\n  \n  /**\n   * Checks if values are in ascending order\n   */\n  export function isAscending(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): boolean {\n    if (values.length <= 1) return true;\n  \n    for (let i = 1; i < values.length; i++) {\n      if (values[i] === undefined || values[i - 1] === undefined || !greaterThanOrEqual(values[i]!, values[i - 1]!, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Checks if values are in descending order\n   */\n  export function isDescending(\n    values: Array<bigint | string | number>,\n    options: ComparisonOptions = {}\n  ): boolean {\n    if (values.length <= 1) return true;\n  \n    for (let i = 1; i < values.length; i++) {\n      if (values[i] === undefined || values[i - 1] === undefined || !lessThanOrEqual(values[i]!, values[i - 1]!, options)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  \n  /**\n   * Creates a comparator function for sorting\n   */\n  export function createComparator(\n    options: ComparisonOptions = {}\n  ): (a: bigint | string | number, b: bigint | string | number) => number {\n    return (a, b) => compare(a, b, options);\n  }\n  \n  export default {\n    compare,\n    equals,\n    lessThan,\n    lessThanOrEqual,\n    greaterThan,\n    greaterThanOrEqual,\n    between,\n    max,\n    min,\n    clamp,\n    allEqual,\n    isAscending,\n    isDescending,\n    createComparator\n  };","/**\n * Conversion operations module for Hypernum library\n * Provides functions for converting numbers between different formats and bases\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n  } from '../utils/validation';\n  \n  import {\n    RoundingMode,\n\n  } from '../utils/precision';\n  \n  /**\n   * Options for conversion operations\n   */\n  export interface ConversionOptions {\n    /** Precision for decimal operations */\n    precision?: number;\n    /** Rounding mode for decimal operations */\n    roundingMode?: RoundingMode;\n    /** Whether to use uppercase for hex/base-N output */\n    uppercase?: boolean;\n    /** Whether to add prefix for base-N output (0x, 0b, etc.) */\n    prefix?: boolean;\n    /** Minimum number of digits (pad with zeros) */\n    minDigits?: number;\n  }\n  \n  const DEFAULT_OPTIONS: Required<ConversionOptions> = {\n    precision: 0,\n    roundingMode: RoundingMode.HALF_EVEN,\n    uppercase: false,\n    prefix: false,\n    minDigits: 1\n  };\n  \n  /**\n   * Converts number to binary string representation\n   */\n  export function toBinary(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let binary = bigValue.toString(2);\n    \n    // Pad with zeros if needed\n    while (binary.length < opts.minDigits) {\n      binary = '0' + binary;\n    }\n    \n    return opts.prefix ? '0b' + binary : binary;\n  }\n  \n  /**\n   * Converts number to octal string representation\n   */\n  export function toOctal(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let octal = bigValue.toString(8);\n    \n    while (octal.length < opts.minDigits) {\n      octal = '0' + octal;\n    }\n    \n    return opts.prefix ? '0o' + octal : octal;\n  }\n  \n  /**\n   * Converts number to hexadecimal string representation\n   */\n  export function toHexadecimal(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let hex = bigValue.toString(16);\n    \n    if (opts.uppercase) {\n      hex = hex.toUpperCase();\n    }\n    \n    while (hex.length < opts.minDigits) {\n      hex = '0' + hex;\n    }\n    \n    return opts.prefix ? '0x' + hex : hex;\n  }\n  \n  /**\n   * Converts number to string in specified base\n   */\n  export function toBase(\n    value: bigint | string | number,\n    base: number,\n    options: ConversionOptions = {}\n  ): string {\n    if (base < 2 || base > 36) {\n      throw new ValidationError('Base must be between 2 and 36');\n    }\n    \n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    let result = bigValue.toString(base);\n    \n    if (opts.uppercase) {\n      result = result.toUpperCase();\n    }\n    \n    while (result.length < opts.minDigits) {\n      result = '0' + result;\n    }\n    \n    return result;\n  }\n  \n  /**\n   * Converts string from specified base to bigint\n   */\n  export function fromBase(\n    value: string,\n    base: number\n  ): bigint {\n    if (base < 2 || base > 36) {\n      throw new ValidationError('Base must be between 2 and 36');\n    }\n    \n    // Remove base prefixes if present\n    const cleanValue = value.toLowerCase()\n      .replace(/^0x/, '')  // hex\n      .replace(/^0b/, '')  // binary\n      .replace(/^0o/, ''); // octal\n    \n    try {\n      return BigInt(`${base}n${cleanValue}`);\n    } catch (error) {\n      throw new ValidationError(`Invalid number format for base ${base}: ${value}`);\n    }\n  }\n  \n  /**\n   * Converts decimal string to fraction representation\n   */\n  export function toFraction(\n    value: string,\n  ): [bigint, bigint] {\n    \n    // Split into integer and decimal parts\n    const [intPart, decPart = ''] = value.split('.');\n    \n    if (!decPart) {\n      return [toBigInt(intPart), 1n];\n    }\n    \n    // Convert decimal to fraction\n    const numerator = toBigInt(intPart + decPart);\n    const denominator = 10n ** BigInt(decPart.length);\n    \n    // Simplify fraction\n    const gcd = calculateGCD(numerator, denominator);\n    \n    return [numerator / gcd, denominator / gcd];\n  }\n  \n  /**\n   * Converts fraction to decimal string with specified precision\n   */\n  export function fromFraction(\n    numerator: bigint | string | number,\n    denominator: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigNumerator = toBigInt(numerator);\n    const bigDenominator = toBigInt(denominator);\n    \n    if (bigDenominator === 0n) {\n      throw new ValidationError('Denominator cannot be zero');\n    }\n    \n    const quotient = bigNumerator / bigDenominator;\n    const remainder = bigNumerator % bigDenominator;\n    \n    if (remainder === 0n || opts.precision === 0) {\n      return quotient.toString();\n    }\n    \n    // Calculate decimal part\n    const scaleFactor = 10n ** BigInt(opts.precision);\n    const scaledRemainder = (remainder * scaleFactor) / bigDenominator;\n    \n    return `${quotient}.${scaledRemainder.toString().padStart(opts.precision, '0')}`;\n  }\n  \n  /**\n   * Converts scientific notation to decimal string\n   */\n  export function fromScientific(\n    value: string,\n  ): string {\n    \n    // Parse scientific notation format\n    const match = value.match(/^(-?\\d+\\.?\\d*)[eE]([+-]?\\d+)$/);\n    if (!match) {\n      throw new ValidationError('Invalid scientific notation format');\n    }\n    \n    const [, significand, exponent] = match;\n    const exp = parseInt(exponent || '0', 10);\n    \n    // Convert to regular decimal\n    if (exp >= 0) {\n      if (significand === undefined) {\n        throw new ValidationError('Invalid scientific notation format');\n      }\n      return (BigInt(significand.replace('.', '')) * (10n ** BigInt(exp))).toString();\n    } else {\n      const absExp = Math.abs(exp);\n      if (significand === undefined) {\n        throw new ValidationError('Invalid scientific notation format');\n      }\n      const scaledValue = BigInt(significand.replace('.', ''));\n      return (scaledValue / (10n ** BigInt(absExp))).toString();\n    }\n  }\n  \n  /**\n   * Converts decimal to scientific notation\n   */\n  export function toScientific(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigValue = toBigInt(value);\n    \n    if (bigValue === 0n) {\n      return '0e0';\n    }\n    \n    const str = bigValue.toString();\n    const firstDigit = str[0] === '-' ? str[1] : str[0];\n    const exponent = str.length - (str[0] === '-' ? 2 : 1);\n    \n    let result = firstDigit;\n    if (str.length > 1) {\n      const restDigits = str.slice(str[0] === '-' ? 2 : 1);\n      if (opts.precision > 0) {\n        result += '.' + restDigits.slice(0, opts.precision);\n      }\n    }\n    \n    if (str[0] === '-') {\n      result = '-' + result;\n    }\n    \n    return `${result}e${exponent}`;\n  }\n  \n  /**\n   * Calculates Greatest Common Divisor (helper function)\n   */\n  function calculateGCD(a: bigint, b: bigint): bigint {\n    a = a < 0n ? -a : a;\n    b = b < 0n ? -b : b;\n    \n    while (b !== 0n) {\n      const temp = b;\n      b = a % b;\n      a = temp;\n    }\n    \n    return a;\n  }\n  \n\n  /**\n * Converts Roman numeral to number\n */\nexport function fromRoman(value: string): bigint {\n    const romanValues = new Map<string, number>([\n      ['I', 1],\n      ['V', 5],\n      ['X', 10],\n      ['L', 50],\n      ['C', 100],\n      ['D', 500],\n      ['M', 1000]\n    ]);\n  \n    let result = 0;\n    let prevValue = 0;\n  \n    // Process from right to left\n    for (let i = value.length - 1; i >= 0; i--) {\n      const char = value[i]?.toUpperCase() ?? '';\n      const current = romanValues.get(char);\n  \n      if (current === undefined) {\n        throw new ValidationError(`Invalid Roman numeral character: ${char}`);\n      }\n  \n      if (current >= prevValue) {\n        result += current;\n      } else {\n        result -= current;\n      }\n  \n      prevValue = current;\n    }\n  \n    return BigInt(result);\n  }\n  \n  /**\n   * Converts number to Roman numeral\n   */\n  export function toRoman(\n    value: bigint | string | number,\n    options: ConversionOptions = {}\n  ): string {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const num = Number(toBigInt(value));\n  \n    if (num <= 0 || num > 3999) {\n      throw new ValidationError('Number must be between 1 and 3999 for Roman numerals');\n    }\n  \n    // Define symbol pairs with proper typing\n    type RomanPair = [string, string];\n    type RomanSingle = [string];\n    type RomanSymbol = RomanPair | RomanSingle;\n  \n    const romanSymbols: RomanSymbol[] = [\n      ['I', 'V'], // ones\n      ['X', 'L'], // tens\n      ['C', 'D'], // hundreds\n      ['M']       // thousands\n    ];\n  \n    let result = '';\n    let position = 0;\n    let remaining = num;\n  \n    while (remaining > 0) {\n      const digit = remaining % 10;\n      const symbols = romanSymbols[position];\n  \n      if (!symbols) {\n        break; // Safety check for position overflow\n      }\n  \n      const unit = symbols[0];\n      const five = symbols[1] ?? '';\n      const next = position < 3 ? romanSymbols[position + 1]?.[0] ?? '' : '';\n  \n      let digitStr = '';\n      if (digit === 9 && next) {\n        digitStr = unit + next;\n      } else if (digit >= 5 && five) {\n        digitStr = five + unit.repeat(digit - 5);\n      } else if (digit === 4 && five) {\n        digitStr = unit + five;\n      } else {\n        digitStr = unit.repeat(digit);\n      }\n  \n      result = digitStr + result;\n      remaining = Math.floor(remaining / 10);\n      position++;\n    }\n  \n    return opts.uppercase ? result : result.toLowerCase();\n  }\n  export default {\n    toBinary,\n    toOctal,\n    toHexadecimal,\n    toBase,\n    fromBase,\n    toFraction,\n    fromFraction,\n    fromScientific,\n    toScientific,\n    fromRoman,\n    toRoman\n  };","/**\n * Factorial operations module for Hypernum library\n * Provides efficient implementations for factorial and related computations\n */\n\nimport {\n    toBigInt,\n    ValidationError,\n    OverflowError,\n    validateNonNegative\n  } from '../utils/validation';\n  \n  /**\n   * Options for factorial operations\n   */\n  export interface FactorialOptions {\n    /** Maximum allowed computation value */\n    maxValue?: number;\n    /** Whether to check for overflow */\n    checkOverflow?: boolean;\n    /** Cache computed values */\n    useCache?: boolean;\n  }\n  \n  const DEFAULT_OPTIONS: Required<FactorialOptions> = {\n    maxValue: 1000,\n    checkOverflow: true,\n    useCache: true\n  };\n  \n  // Cache for factorial values\n  const factorialCache = new Map<bigint, bigint>();\n  \n  /**\n   * Calculates factorial of a number (n!)\n   */\n  export function factorial(\n    value: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n  \n    validateNonNegative(n);\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Factorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    // Handle base cases\n    if (n <= 1n) {\n      return 1n;\n    }\n  \n    // Check cache\n    if (opts.useCache && factorialCache.has(n)) {\n      return factorialCache.get(n)!;\n    }\n  \n    // Calculate factorial\n    let result = 1n;\n    for (let i = 2n; i <= n; i++) {\n      result *= i;\n    }\n  \n    // Cache result\n    if (opts.useCache) {\n      factorialCache.set(n, result);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates binomial coefficient (n choose k)\n   */\n  export function binomial(\n    n: bigint | string | number,\n    k: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigN = toBigInt(n);\n    const bigK = toBigInt(k);\n  \n    validateNonNegative(bigN);\n    validateNonNegative(bigK);\n  \n    if (bigK > bigN) {\n      throw new ValidationError('K cannot be greater than N in binomial coefficient');\n    }\n  \n    // Optimize for k > n/2 by using symmetry\n    if (bigK > bigN / 2n) {\n      return binomial(bigN, bigN - bigK, opts);\n    }\n  \n    // Use multiplicative formula instead of factorial for efficiency\n    let result = 1n;\n    for (let i = 0n; i < bigK; i++) {\n      result = (result * (bigN - i)) / (i + 1n);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates subfactorial (derangement number)\n   * Number of permutations of n elements with no fixed points\n   */\n  export function subfactorial(\n    value: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n  \n    validateNonNegative(n);\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Subfactorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    // Handle base cases\n    if (n === 0n) return 1n;\n    if (n === 1n) return 0n;\n  \n    // Use recursive formula !n = n * !(n-1) + (-1)^n\n    let result = 0n;\n    const nFact = factorial(n, opts);\n  \n    for (let k = 0n; k <= n; k++) {\n      const term = factorial(n - k, opts) * (k % 2n === 0n ? 1n : -1n);\n      result += term;\n    }\n  \n    return nFact - result;\n  }\n  \n  /**\n   * Calculates rising factorial (Pochhammer symbol)\n   * x^(n) = x(x+1)(x+2)...(x+n-1)\n   */\n  export function risingFactorial(\n    x: bigint | string | number,\n    n: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigX = toBigInt(x);\n    const bigN = toBigInt(n);\n  \n    validateNonNegative(bigN);\n  \n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Rising factorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    let result = 1n;\n    for (let i = 0n; i < bigN; i++) {\n      result *= (bigX + i);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates falling factorial\n   * x_(n) = x(x-1)(x-2)...(x-n+1)\n   */\n  export function fallingFactorial(\n    x: bigint | string | number,\n    n: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const bigX = toBigInt(x);\n    const bigN = toBigInt(n);\n  \n    validateNonNegative(bigN);\n  \n    if (opts.checkOverflow && bigN > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Falling factorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    let result = 1n;\n    for (let i = 0n; i < bigN; i++) {\n      result *= (bigX - i);\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates multifactorial (n!!)\n   * Product of numbers from 1 to n that leave the same remainder as n when divided by k\n   */\n  export function multiFactorial(\n    value: bigint | string | number,\n    k: bigint | string | number = 2n,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n    const bigK = toBigInt(k);\n  \n    validateNonNegative(n);\n    if (bigK <= 0n) {\n      throw new ValidationError('K must be positive in multifactorial');\n    }\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Multifactorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    let result = 1n;\n    let current = n;\n  \n    while (current > 0n) {\n      result *= current;\n      current -= bigK;\n    }\n  \n    return result;\n  }\n  \n  /**\n   * Calculates primorial (product of primes up to n)\n   */\n  export function primorial(\n    value: bigint | string | number,\n    options: FactorialOptions = {}\n  ): bigint {\n    const opts = { ...DEFAULT_OPTIONS, ...options };\n    const n = toBigInt(value);\n  \n    validateNonNegative(n);\n  \n    if (opts.checkOverflow && n > BigInt(opts.maxValue)) {\n      throw new OverflowError(`Primorial input too large: maximum allowed is ${opts.maxValue}`);\n    }\n  \n    if (n <= 1n) return 1n;\n  \n    // Generate primes up to n using Sieve of Eratosthenes\n    const num = Number(n);\n    const sieve = new Array(num + 1).fill(true);\n    sieve[0] = sieve[1] = false;\n  \n    for (let i = 2; i * i <= num; i++) {\n      if (sieve[i]) {\n        for (let j = i * i; j <= num; j += i) {\n          sieve[j] = false;\n        }\n      }\n    }\n  \n    // Calculate product of all primes up to n\n    let result = 1n;\n    for (let i = 2; i <= num; i++) {\n      if (sieve[i]) {\n        result *= BigInt(i);\n      }\n    }\n  \n    return result;\n  }\n\n  \n  \n  export default {\n    factorial,\n    binomial,\n    subfactorial,\n    risingFactorial,\n    fallingFactorial,\n    multiFactorial,\n    primorial\n  };","/**\n * Hypernum - A TypeScript/JavaScript library for large number operations\n */\nimport { HypernumConfig, mergeConfig, validateConfig } from './core';\nimport { Hypernum } from './core/hypernum';\nimport { RoundingMode } from './utils/precision';\n\n// Version\nimport path from 'path';\nimport { fileURLToPath } from 'url';\nimport fs from 'fs';\nconst packagePath = path.resolve(path.dirname(fileURLToPath(import.meta.url)), '../package.json');\nconst { version: VERSION } = JSON.parse(fs.readFileSync(packagePath, 'utf-8'));\n\n// Core exports\nexport { Hypernum } from './core/hypernum';\nexport * from './core/constants';\nexport * from './core/common';\nexport * from './core/config';\n\n// Re-export errors with explicit names to avoid conflicts\nexport { \n  HypernumError,\n  ComputationLimitError,\n  DataStructureError,\n  DivisionByZeroError,\n  FormatError,\n  HeapPropertyError,\n  IndexError,\n  PrecisionError,\n  RomanNumeralError,\n  TreeError,\n  UnderflowError\n} from './core/errors';\n\n// Data structures with explicit imports and exports\nexport { AckermannStructure } from './structures/ackermann';\nexport { BigArray, type BigArrayOptions } from './structures/big-array';\nexport { NumberTree } from './structures/number-tree';\nexport { PowerTower } from './structures/power-tower';\nexport { MinHeap, MaxHeap, type Comparator } from './storage/';\n\n// Operations with explicit exports\nexport {\n  add,\n  subtract,\n  multiply,\n  divide,\n  remainder,\n  abs,\n  sign,\n  gcd,\n  lcm\n} from './operations/arithmetic';\n\nexport {\n  and,\n  or,\n  xor,\n  not,\n  leftShift,\n  rightShift,\n  unsignedRightShift,\n  rotateLeft,\n  rotateRight,\n  popCount,\n  trailingZeros,\n  leadingZeros,\n  getBit,\n  setBit,\n  clearBit,\n  toggleBit\n} from './operations/bitwise';\n\nexport {\n  compare,\n  equals,\n  lessThan,\n  lessThanOrEqual,\n  greaterThan,\n  greaterThanOrEqual,\n  between,\n  max,\n  min,\n  clamp,\n  allEqual,\n  isAscending,\n  isDescending,\n  createComparator\n} from './operations/comparison';\n\nexport {\n  toBinary,\n  toOctal,\n  toHexadecimal,\n  toBase,\n  fromBase,\n  toFraction,\n  fromFraction,\n  fromScientific,\n  toScientific,\n  fromRoman,\n  toRoman\n} from './operations/conversion';\n\nexport {\n  factorial,\n  binomial,\n  subfactorial,\n  risingFactorial,\n  fallingFactorial,\n  multiFactorial,\n  primorial\n} from './operations/factorial';\n\nexport {\n  power,\n  sqrt,\n  nthRoot,\n  tetration,\n  superRoot\n} from './operations/power';\n\n// Utils with explicit exports\nexport {\n  toBigInt,\n  validateNonNegative,\n  validatePositive,\n  checkAdditionOverflow,\n  checkMultiplicationOverflow,\n  checkPowerOverflow\n} from './utils/validation';\n\nexport {\n  formatBigInt,\n  parseBigIntString,\n  normalizeNumberString\n} from './utils/formatting';\n\nexport {\n  RoundingMode,\n  round,\n  scaleByPowerOfTen,\n  scaledDivision,\n  normalizePrecision\n} from './utils/precision';\n\n/**\n * Creates a new Hypernum instance with custom configuration\n */\nexport function createHypernum(config?: Partial<HypernumConfig>): Hypernum {\n  const mergedConfig = mergeConfig(config || {});\n  validateConfig(mergedConfig);\n  \n  const instanceConfig = {\n    precision: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.defaultPrecision \n      : mergedConfig.precision ?? 0,\n    roundingMode: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.defaultRoundingMode \n      : (mergedConfig.roundingMode as RoundingMode) ?? RoundingMode.HALF_EVEN,\n    checkOverflow: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.checkOverflow \n      : mergedConfig.checkOverflow ?? true,\n    maxSteps: 'arithmetic' in mergedConfig \n      ? mergedConfig.arithmetic.maxComputationSteps \n      : mergedConfig.maxSteps ?? 1000,\n    debug: 'debug' in mergedConfig && typeof mergedConfig.debug === 'object' \n      ? mergedConfig.debug.verbose \n      : false\n  };\n  \n  return new Hypernum(instanceConfig);\n}\n\n// Default instance\nexport const defaultHypernum = createHypernum();\n\n// Export version\nexport { VERSION };\n\n// Default export\nexport default Hypernum;"],"names":["ValidationError","DEFAULT_OPTIONS","arithmetic.add","arithmetic.subtract","arithmetic.multiply","arithmetic.divide","arithmetic.remainder","power.power","power.sqrt","power.nthRoot","bitwise.and","bitwise.or","bitwise.xor","bitwise.not","arithmetic.gcd","arithmetic.lcm","validation.toBigInt","formatting.formatBigInt"],"mappings":"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"}