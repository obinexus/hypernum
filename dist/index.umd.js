/**
 * @obinexuscomputing/hypernum v0.1.0
*  Precison at Scale
 *A high-precision mathematics library for large number operations with BigInt support, custom data structures, and comprehensive type safety 
 * @license ISC
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("path"),require("url"),require("fs")):"function"==typeof define&&define.amd?define(["exports","path","url","fs"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).Hypernum={},t.path,t.url,t.fs)}(this,(function(t,e,n,r){"use strict";var i="undefined"!=typeof document?document.currentScript:null;let o=class extends Error{constructor(t){super(t),this.name="ValidationError"}};class s extends Error{constructor(t){super(t),this.name="OverflowError"}}const a=t=>{if((t=>"bigint"==typeof t)(t))return t;if("string"==typeof t){if(!(t=>/^-?\d+$/.test(t))(t))throw new o(`Invalid number string: ${t}`);return BigInt(t)}if((t=>"number"==typeof t&&!isNaN(t)&&isFinite(t))(t)){if(!Number.isInteger(t))throw new o("Cannot convert non-integer number to BigInt");return BigInt(t)}throw new o(`Cannot convert ${typeof t} to BigInt`)},u=(t,e)=>{if(e>0&&t>BigInt(Number.MAX_SAFE_INTEGER)-e)throw new s("Addition would overflow");if(e<0&&t<BigInt(Number.MIN_SAFE_INTEGER)-e)throw new s("Addition would underflow")},c=(t,e)=>{if(t!==BigInt(0)&&e!==BigInt(0)){const n=BigInt(Number.MAX_SAFE_INTEGER),r=BigInt(Number.MIN_SAFE_INTEGER);if(t>n/e||t<r/e)throw new s("Multiplication would overflow")}},h=(t,e)=>{if(e<BigInt(0))throw new o("Negative exponents not supported for integers");if(t===BigInt(0)&&e===BigInt(0))throw new o("Zero raised to zero is undefined");if(e>BigInt(1e3))throw new s("Exponent too large, computation would overflow")},l=t=>{if(t<BigInt(0))throw new o("Value must be non-negative")};var f;t.RoundingMode=void 0,(f=t.RoundingMode||(t.RoundingMode={})).FLOOR="FLOOR",f.CEIL="CEIL",f.DOWN="DOWN",f.UP="UP",f.HALF_EVEN="HALF_EVEN",f.HALF_UP="HALF_UP",f.HALF_DOWN="HALF_DOWN";const p=(t,e)=>0===e?t:e>0?t*BigInt(10)**BigInt(e):t/BigInt(10)**BigInt(-e),g=(e,n=0,r=t.RoundingMode.HALF_EVEN)=>{if(n<0)throw new o("Precision must be non-negative");if(0===n)return e;const i=BigInt(10)**BigInt(n),s=e/i,a=e%i;switch(r){case t.RoundingMode.FLOOR:return s*i;case t.RoundingMode.CEIL:return a>0n?(s+1n)*i:s*i;case t.RoundingMode.DOWN:return e>=0n?s*i:(s-1n)*i;case t.RoundingMode.UP:return e>=0n?(s+1n)*i:s*i;case t.RoundingMode.HALF_UP:return a>=i/2n?(s+1n)*i:s*i;case t.RoundingMode.HALF_DOWN:return a>i/2n?(s+1n)*i:s*i;case t.RoundingMode.HALF_EVEN:return a===i/2n?s%2n===0n?s*i:(s+1n)*i:a>i/2n?(s+1n)*i:s*i;default:throw new o("Invalid rounding mode")}},d=(t,e,n,r)=>{const i=Math.max(n,r);return[p(t,i-n),p(e,i-r)]},m=(e,n,r,i=t.RoundingMode.HALF_EVEN)=>{if(0n===n)throw new o("Division by zero");if(r<0)throw new o("Precision must be non-negative");const s=p(e,r);return g(s/n,0,i)};const w={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxSteps:1e3,debug:!1},I={arithmetic:{defaultPrecision:0,defaultRoundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxComputationSteps:1e3,autoPrecision:{enabled:!0,maxPrecision:100,minPrecision:0},constants:{precision:50,cache:!0,algorithm:"series"}},dataStructures:{array:{initialCapacity:16,growthFactor:2,maxSize:1e6},tree:{maxDepth:1e3,autoBalance:!0,nodeLimit:1e6},heap:{initialCapacity:16,growthPolicy:"double",validatePropertyOnOperation:!0},cache:{enabled:!0,maxSize:1e3,ttl:36e5,evictionPolicy:"LRU",persistToDisk:!1,compressionEnabled:!1}},formatting:{notation:"standard",precision:0,grouping:!0,groupSize:3,decimalSeparator:".",groupSeparator:",",uppercase:!1,scientific:{minExponent:6,maxSignificantDigits:6,exponentSeparator:"e"},engineering:{useSIPrefixes:!0},localization:{locale:"en-US",useLocaleGrouping:!1}},performance:{enableTracking:!1,samplingRate:.1,thresholds:{warnThresholdMs:100,errorThresholdMs:1e3,maxMemoryBytes:1073741824},metrics:{timing:!0,memory:!0,cache:!0}},debug:{verbose:!1,trackPerformance:!1,logLevel:"error"},features:{experimentalFeatures:!1,useWasm:!1,workerThreads:!1,sharedArrayBuffer:!1,bigIntTypedArrays:!0}};function E(t){return"arithmetic"in t&&"dataStructures"in t}function v(t){return!E(t)}function x(t){E(t)?function(t){if(t.arithmetic.defaultPrecision<0)throw new Error("Default precision cannot be negative");if(t.arithmetic.maxComputationSteps<=0)throw new Error("Max computation steps must be positive");if(t.dataStructures.array.initialCapacity<=0)throw new Error("Initial capacity must be positive");if(t.dataStructures.array.growthFactor<=1)throw new Error("Growth factor must be greater than 1");if(t.performance.samplingRate<0||t.performance.samplingRate>1)throw new Error("Sampling rate must be between 0 and 1")}(t):function(t){if(void 0!==t.precision&&t.precision<0)throw new Error("Precision cannot be negative");if(void 0!==t.maxSteps&&t.maxSteps<=0)throw new Error("Maximum steps must be positive");if(void 0!==t.debug&&"boolean"!=typeof t.debug)throw new Error("Debug flag must be a boolean")}(t)}function B(t={}){if(E(t)){const e=t;return{...I,...e,arithmetic:{...I.arithmetic,...e.arithmetic},dataStructures:{...I.dataStructures,...e.dataStructures},formatting:{...I.formatting,...e.formatting},performance:{...I.performance,...e.performance},debug:{...I.debug,...e.debug},features:{...I.features,...e.features}}}return{precision:t.precision??w.precision,roundingMode:t.roundingMode??w.roundingMode,checkOverflow:t.checkOverflow??w.checkOverflow,maxSteps:t.maxSteps??w.maxSteps,debug:t.debug??w.debug}}const b=BigInt(Number.MAX_SAFE_INTEGER),S=BigInt(Number.MIN_SAFE_INTEGER),N=1e3,A=BigInt(0),M=BigInt(1),y=BigInt(2),O=BigInt(10),_=BigInt(-1),R=BigInt(2)**BigInt(53),T=BigInt(1e3),C=BigInt(4),P=BigInt(1e3),L={OVERFLOW:"Operation would result in overflow",UNDERFLOW:"Operation would result in underflow",NEGATIVE_ROOT:"Cannot compute root of negative number",NEGATIVE_EXPONENT:"Negative exponents not supported for integers",DIVISION_BY_ZERO:"Division by zero",INVALID_PRECISION:"Precision must be non-negative and not exceed MAX_PRECISION",INVALID_BASE:"Base must be a positive integer",INVALID_ROMAN:"Invalid Roman numeral",COMPUTATION_LIMIT:"Computation exceeded maximum allowed steps",NEGATIVE_INDEX:"Array index cannot be negative",TREE_DEPTH_EXCEEDED:"Maximum tree depth exceeded",INVALID_HEAP_PROPERTY:"Heap property violation detected"},F={OVERFLOW_CHECKING:!0,AUTOMATIC_PRECISION:!0,MEMOIZATION:!0,TREE_BALANCING:!0,DEBUG_MODE:!1},D={precision:0,roundingMode:"HALF_EVEN",checkOverflow:!0,maxSteps:N,grouping:!0,uppercase:!1,cache:!0};class V extends Error{constructor(t){super(t),this.name="HypernumError",Object.setPrototypeOf(this,V.prototype)}}class H extends V{constructor(t){super(t),this.name="ValidationError",Object.setPrototypeOf(this,H.prototype)}}class k extends V{constructor(t=L.UNDERFLOW){super(t),this.name="UnderflowError",Object.setPrototypeOf(this,k.prototype)}}class z extends V{constructor(t=L.DIVISION_BY_ZERO){super(t),this.name="DivisionByZeroError",Object.setPrototypeOf(this,z.prototype)}}class U extends V{constructor(t=L.INVALID_PRECISION){super(t),this.name="PrecisionError",Object.setPrototypeOf(this,U.prototype)}}class $ extends V{constructor(t=L.COMPUTATION_LIMIT){super(t),this.name="ComputationLimitError",Object.setPrototypeOf(this,$.prototype)}}class G extends V{constructor(t){super(t),this.name="DataStructureError",Object.setPrototypeOf(this,G.prototype)}}class X extends G{constructor(t=L.INVALID_HEAP_PROPERTY){super(t),this.name="HeapPropertyError",Object.setPrototypeOf(this,X.prototype)}}class j extends G{constructor(t=L.TREE_DEPTH_EXCEEDED){super(t),this.name="TreeError",Object.setPrototypeOf(this,j.prototype)}}class q extends G{constructor(t=L.NEGATIVE_INDEX){super(t),this.name="IndexError",Object.setPrototypeOf(this,q.prototype)}}class K extends V{constructor(t){super(t),this.name="FormatError",Object.setPrototypeOf(this,K.prototype)}}class W extends K{constructor(t=L.INVALID_ROMAN){super(t),this.name="RomanNumeralError",Object.setPrototypeOf(this,W.prototype)}}const Z={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0};function Y(t,e,n={}){const r={...Z,...n},i=a(t),o=a(e);if(r.checkOverflow&&u(i,o),0===r.precision)return i+o;const[s,c]=d(i,o,r.precision,r.precision);return g(s+c,r.precision,r.roundingMode)}function Q(t,e,n={}){const r={...Z,...n},i=a(t),o=a(e);if(r.checkOverflow&&u(i,-o),0===r.precision)return i-o;const[s,c]=d(i,o,r.precision,r.precision);return g(s-c,r.precision,r.roundingMode)}function J(t,e,n={}){const r={...Z,...n},i=a(t),o=a(e);r.checkOverflow&&c(i,o);const s=i*o;return 0===r.precision?s:g(s,r.precision,r.roundingMode)}function tt(t,e,n={}){const r={...Z,...n},i=a(t),s=a(e);if(s===BigInt(0))throw new o("Division by zero");return m(i,s,r.precision,r.roundingMode)}function et(t,e,n={}){const r={...Z,...n},i=a(t),s=a(e);if(s===BigInt(0))throw new o("Division by zero in remainder operation");if(0===r.precision)return i%s;const[u,c]=d(i,s,r.precision,r.precision);return g(u%c,r.precision,r.roundingMode)}function nt(t){const e=a(t);return e<BigInt(0)?-e:e}function rt(t,e){let n=nt(a(t)),r=nt(a(e));for(;r!==BigInt(0);){const t=r;r=n%r,n=t}return n}function it(t,e){const n=nt(a(t)),r=nt(a(e));return n===BigInt(0)||r===BigInt(0)?BigInt(0):nt(n*r)/rt(n,r)}const ot={maxBits:1024,strict:!0};function st(t,e){if(t<0n)throw new o("Shift amount cannot be negative");if(e.strict&&t>=BigInt(e.maxBits))throw new o(`Shift amount exceeds maximum of ${e.maxBits} bits`)}function at(t,e){return a(t)&a(e)}function ut(t,e){return a(t)|a(e)}function ct(t,e){return a(t)^a(e)}function ht(t){return~a(t)}function lt(t,e,n={}){const r={...ot,...n},i=a(t),o=a(e);return st(o,r),i<<o}function ft(t,e,n={}){const r={...ot,...n},i=a(t),o=a(e);if(st(o,r),i>=0n)return i>>o;return(i&(1n<<BigInt(r.maxBits))-1n)>>o}const pt={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,checkOverflow:!0,maxSteps:1e3};function gt(t,e,n={}){const r={...pt,...n},i=a(t),u=a(e);if(0n===u)return 1n;if(1n===u)return i;if(0n===i&&u<0n)throw new o("Zero cannot be raised to a negative power");if(0n===i)return 0n;if(1n===i)return 1n;if(-1n===i)return u%2n===0n?1n:-1n;if(u<0n)throw new o("Negative exponents not supported for integer power");r.checkOverflow&&h(i,u);let c=1n,l=i,f=u,p=0;for(;f>0n;){if(p++>r.maxSteps)throw new s("Power operation exceeded maximum computation steps");1n&f&&(c*=l),l*=l,f>>=1n}return r.precision>0?g(c,r.precision,r.roundingMode):c}function dt(t,e={}){const n={...pt,...e},r=a(t);if(l(r),0n===r)return 0n;if(1n===r)return 1n;let i,o=r>>1n,u=0;do{if(u++>n.maxSteps)throw new s("Square root operation exceeded maximum computation steps");i=o,o=o+r/o>>1n}while(o<i);return n.precision>0?g(i,n.precision,n.roundingMode):i}function mt(t,e,n={}){const r={...pt,...n},i=a(t),u=a(e);if(l(i),u<=0n)throw new o("Root index must be positive");if(0n===i)return 0n;if(1n===i)return 1n;if(1n===u)return i;if(2n===u)return dt(i,r);let c,h=i>>1n,f=0;const p=u-1n;do{if(f++>r.maxSteps)throw new s("Nth root operation exceeded maximum computation steps");c=h;h=(p*h+i/gt(h,p,r))/u}while(h<c);return r.precision>0?g(c,r.precision,r.roundingMode):c}function wt(t,e,n={}){const r={...pt,...n},i=a(t),o=a(e);if(l(o),0n===o)return 1n;if(1n===o)return i;if(0n===i)return o%2n===0n?1n:0n;if(1n===i)return 1n;if(2n===i&&o>4n)throw new s("Tetration would overflow for base 2 and height > 4");let u=i,c=0;for(let t=1n;t<o;t++){if(c++>r.maxSteps)throw new s("Tetration operation exceeded maximum computation steps");u=gt(i,u,r)}return r.precision>0?g(u,r.precision,r.roundingMode):u}class It{constructor(t){this.heap=[],this.compare=t}size(){return this.heap.length}isEmpty(){return 0===this.heap.length}peek(){return this.heap[0]}push(t){this.heap.push(t),this.siftUp(this.heap.length-1)}pop(){if(this.isEmpty())return;const t=this.heap[0],e=this.heap.pop();return this.isEmpty()||(this.heap[0]=e,this.siftDown(0)),t}clear(){this.heap=[]}static heapify(t,e){const n=this instanceof Et?new Et(e):new vt(e);return t.forEach((t=>n.push(t))),n}getParentIndex(t){return Math.floor((t-1)/2)}getLeftChildIndex(t){return 2*t+1}getRightChildIndex(t){return 2*t+2}swap(t,e){const n=this.heap[t];this.heap[t]=this.heap[e],this.heap[e]=n}}class Et extends It{constructor(t){super(t)}siftUp(t){for(;t>0;){const e=this.getParentIndex(t);if(this.compare(this.heap[t],this.heap[e])>=0)break;this.swap(t,e),t=e}}siftDown(t){const e=this.heap.length;for(;;){let n=t;const r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t);if(r<e&&this.compare(this.heap[r],this.heap[n])<0&&(n=r),i<e&&void 0!==this.heap[i]&&this.compare(this.heap[i],this.heap[n])<0&&(n=i),n===t)break;this.swap(t,n),t=n}}}class vt extends It{constructor(t){super(t)}siftUp(t){for(;t>0;){const e=this.getParentIndex(t);if(this.compare(this.heap[t],this.heap[e])<=0)break;this.swap(t,e),t=e}}siftDown(t){const e=this.heap.length;for(;;){let n=t;const r=this.getLeftChildIndex(t),i=this.getRightChildIndex(t);if(r<e&&void 0!==this.heap[r]&&this.compare(this.heap[r],this.heap[n])>0&&(n=r),i<e&&void 0!==this.heap[i]&&this.compare(this.heap[i],this.heap[n])>0&&(n=i),n===t)break;this.swap(t,n),t=n}}}class xt{constructor(){this.nodes=new Map,this.maxComputedM=-1,this.maxComputedN=-1,this.heap=new vt(((t,e)=>t>e?1:t<e?-1:0))}static getNodeKey(t,e){return`${t},${e}`}computeAckermann(t,e){if(t<0||e<0)throw new Error("Ackermann function undefined for negative numbers");const n=xt.getNodeKey(t,e),r=this.nodes.get(n);if(r)return r.value;let i;try{if(0===t)i=BigInt(e+1);else if(0===e)i=this.computeAckermann(t-1,1);else{const n=this.computeAckermann(t,e-1),r=n<=BigInt(Number.MAX_SAFE_INTEGER)?Number(n):Number.MAX_SAFE_INTEGER;i=this.computeAckermann(t-1,r)}}catch(t){if(t instanceof RangeError)return BigInt(Number.MAX_SAFE_INTEGER);throw t}return i}addNode(t,e){const n=xt.getNodeKey(t,e);if(this.nodes.has(n))return this.nodes.get(n);const r=this.computeAckermann(t,e),i={m:t,n:e,value:r};this.nodes.set(n,i);const o=xt.getNodeKey(t-1,e),s=xt.getNodeKey(t,e-1);if(this.nodes.has(o)){const t=this.nodes.get(o);i.prevM=t,t.nextM=i}if(this.nodes.has(s)){const t=this.nodes.get(s);i.prevN=t,t.nextN=i}return this.maxComputedM=Math.max(this.maxComputedM,t),this.maxComputedN=Math.max(this.maxComputedN,e),this.heap.push(r),i}buildRange(t,e){for(let n=0;n<=t;n++)for(let t=0;t<=e;t++)this.addNode(n,t)}getComputationPath(t,e){const n=[],r=xt.getNodeKey(t,e);let i=this.nodes.get(r);for(;i&&(n.push({m:i.m,n:i.n,value:i.value}),0!==i.m);)if(0===i.n)i=this.nodes.get(xt.getNodeKey(i.m-1,1));else{const t=this.nodes.get(xt.getNodeKey(i.m,i.n-1));t&&n.push({m:t.m,n:t.n,value:t.value});const e=t?.value??BigInt(0),r=e<=BigInt(Number.MAX_SAFE_INTEGER)?Number(e):Number.MAX_SAFE_INTEGER;i=this.nodes.get(xt.getNodeKey(i.m-1,r))}return n.reverse()}analyzeGrowthRate(t){const e=new Map;let n=BigInt(1);for(let r=0;r<=this.maxComputedN;r++){const i=xt.getNodeKey(t,r),o=this.nodes.get(i);if(!o||o.value>=BigInt(Number.MAX_SAFE_INTEGER))break;e.set(r,{value:o.value,increase:o.value-n,multiplier:n===BigInt(0)?BigInt(0):o.value/n}),n=o.value}return e}getLargestValue(){return this.heap.peek()??BigInt(0)}getValue(t,e){return this.nodes.get(xt.getNodeKey(t,e))?.value}}class Bt{constructor(t={}){const{initialCapacity:e=16,growthFactor:n=2,comparator:r=(t,e)=>t<e?-1:t>e?1:0}=t;this.capacity=e,this.growthFactor=n,this.comparator=r,this.size=0,this.data=new Array(this.capacity),this.segmentTree=new Array(4*this.capacity).fill(null)}getSize(){return this.size}getCapacity(){return this.capacity}resize(t){const e=new Array(t);for(let t=0;t<this.size;t++)e[t]=this.data[t];this.data=e,this.capacity=t,this.rebuildSegmentTree()}push(t){try{return this.size>=this.capacity&&this.resize(this.capacity*this.growthFactor),this.data[this.size]=t,this.updateSegmentTree(0,this.size,t),this.size++,{success:!0,value:this.size-1}}catch(t){return{success:!1,error:t instanceof Error?t.message:"Unknown error during push"}}}pop(){if(0===this.size)return{success:!1,error:"Array is empty"};const t=this.data[this.size-1];return this.size--,this.size<this.capacity/(2*this.growthFactor)&&this.resize(Math.max(16,Math.floor(this.capacity/this.growthFactor))),{success:!0,value:t}}get(t){return t<0||t>=this.size?{success:!1,error:"Index out of bounds"}:{success:!0,value:this.data[t]}}set(t,e){if(t<0||t>=this.size)return{success:!1,error:"Index out of bounds"};const n=this.data[t];return this.data[t]=e,this.updateSegmentTree(0,t,e),{success:!0,value:n}}rebuildSegmentTree(){this.segmentTree=new Array(4*this.capacity).fill(null),this.size>0&&this.buildSegmentTree(0,0,this.size-1)}buildSegmentTree(t,e,n){if(e===n)return void(this.segmentTree[t]={value:this.data[e],start:e,end:n});const r=Math.floor((e+n)/2);this.buildSegmentTree(2*t+1,e,r),this.buildSegmentTree(2*t+2,r+1,n);const i=this.segmentTree[2*t+1],o=this.segmentTree[2*t+2];i&&o&&(this.segmentTree[t]={value:this.comparator(i.value,o.value)>=0?i.value:o.value,start:e,end:n})}updateSegmentTree(t,e,n){if(!this.segmentTree[t])return;const r=this.segmentTree[t];if(r.start===r.end)return void(r.value=n);e<=Math.floor((r.start+r.end)/2)?this.updateSegmentTree(2*t+1,e,n):this.updateSegmentTree(2*t+2,e,n);const i=this.segmentTree[2*t+1],o=this.segmentTree[2*t+2];i&&o&&(r.value=this.comparator(i.value,o.value)>=0?i.value:o.value)}queryRange(t,e){if(t<0||e>=this.size||t>e)return{success:!1,error:"Invalid range"};const n=this.querySegmentTree(0,t,e);return n?{success:!0,value:n}:{success:!1,error:"Range query failed"}}querySegmentTree(t,e,n){const r=this.segmentTree[t];if(!r)return null;if(e<=r.start&&n>=r.end)return r.value;if(n<r.start||e>r.end)return null;const i=this.querySegmentTree(2*t+1,e,n),o=this.querySegmentTree(2*t+2,e,n);return null===i?o:null===o||this.comparator(i,o)>=0?i:o}toHeap(t=!0){const e=t?new Et(this.comparator):new vt(this.comparator);for(let t=0;t<this.size;t++)void 0!==this.data[t]&&void 0!==this.data[t]&&e.push(this.data[t]);return e}sort(t=!0){const e=this.toHeap(!t);for(let t=this.size-1;t>=0;t--){const n=e.pop();void 0!==n&&(this.data[t]=n)}this.rebuildSegmentTree()}toArray(){return this.data.slice(0,this.size)}}class bt{constructor(t){this.value="bigint"==typeof t?t:BigInt(t),this.left=null,this.right=null,this.parent=null,this.height=1,this.size=1,this.sum=this.value}updateStats(){this.height=1+Math.max(this.left?.height??0,this.right?.height??0),this.size=1+(this.left?.size??0)+(this.right?.size??0),this.sum=this.value+(this.left?.sum??BigInt(0))+(this.right?.sum??BigInt(0))}getBalance(){return(this.left?.height??0)-(this.right?.height??0)}getStats(){return{height:this.height,size:this.size,sum:this.sum,min:this.findMin().value,max:this.findMax().value}}findMin(){let t=this;for(;t.left;)t=t.left;return t}findMax(){let t=this;for(;t.right;)t=t.right;return t}}class St{constructor(t){this.root=null,this.comparator=t??((t,e)=>t<e?-1:t>e?1:0)}getRoot(){return this.root}insert(t){const e="bigint"==typeof t?t:BigInt(t);return this.root=this.insertNode(this.root,e),this.find(e)}insertNode(t,e){if(!t)return new bt(e);const n=this.comparator(e,t.value);if(n<0)t.left=this.insertNode(t.left,e),t.left.parent=t;else{if(!(n>0))return t;t.right=this.insertNode(t.right,e),t.right.parent=t}return t.updateStats(),this.balance(t)}balance(t){const e=t.getBalance();return e>1?(t.left&&t.left.getBalance()<0&&(t.left=this.rotateLeft(t.left)),this.rotateRight(t)):e<-1?(t.right&&t.right.getBalance()>0&&(t.right=this.rotateRight(t.right)),this.rotateLeft(t)):t}rotateLeft(t){const e=t.right,n=e.left;return e.left=t,t.right=n,n&&(n.parent=t),e.parent=t.parent,t.parent=e,t.updateStats(),e.updateStats(),e}rotateRight(t){const e=t.left,n=e.right;return e.right=t,t.left=n,n&&(n.parent=t),e.parent=t.parent,t.parent=e,t.updateStats(),e.updateStats(),e}remove(t){const e="bigint"==typeof t?t:BigInt(t);return!!this.find(e)&&(this.root=this.removeNode(this.root,e),!0)}removeNode(t,e){if(!t)return null;const n=this.comparator(e,t.value);if(n<0)t.left=this.removeNode(t.left,e),t.left&&(t.left.parent=t);else if(n>0)t.right=this.removeNode(t.right,e),t.right&&(t.right.parent=t);else{if(!t.left)return t.right;if(!t.right)return t.left;const e=t.right.findMin();t.value=e.value,t.right=this.removeNode(t.right,e.value),t.right&&(t.right.parent=t)}return t.updateStats(),this.balance(t)}find(t){const e="bigint"==typeof t?t:BigInt(t);let n=this.root;for(;n;){const t=this.comparator(e,n.value);if(0===t)return n;n=t<0?n.left:n.right}return null}traverse(t="inOrder",e={}){const n=[],r=(i,o=0)=>{!i||void 0!==e.maxDepth&&o>=e.maxDepth||("preOrder"===t&&n.push(i.value),e.skipSubtrees||r(i.left,o+1),"inOrder"===t&&n.push(i.value),e.skipSubtrees||r(i.right,o+1),"postOrder"===t&&n.push(i.value))};return r(this.root),n}getTreeStats(){return this.root?.getStats()??null}getNthValue(t){if(!this.root||t<1||t>this.root.size)return null;const e=(t,n)=>{if(!t)return null;const r=t.left?.size??0;return n===r+1?t.value:n<=r?e(t.left,n):e(t.right,n-r-1)};return e(this.root,t)}getRange(t,e){const n="bigint"==typeof t?t:BigInt(t),r="bigint"==typeof e?e:BigInt(e),i=[],o=t=>{t&&(this.comparator(t.value,n)>=0&&this.comparator(t.value,r)<=0?(o(t.left),i.push(t.value),o(t.right)):this.comparator(t.value,n)>0?o(t.left):o(t.right))};return o(this.root),i}}const Nt={maxHeight:100,maxValue:BigInt(Number.MAX_SAFE_INTEGER),checkOverflow:!0,precision:0};class At{constructor(t={}){this.options={...Nt,...t},this.head=null,this.tail=null,this.size=0}createNode(t,e){return{value:t,height:e,evaluated:!1,previous:null,next:null}}validateHeight(t){if(t<0)throw new o("Height cannot be negative");if(t>this.options.maxHeight)throw new o(`Height exceeds maximum of ${this.options.maxHeight}`)}validateValue(t){if(l(t),this.options.checkOverflow&&t>this.options.maxValue)throw new s(`Value exceeds maximum of ${this.options.maxValue}`)}computePower(t,e){if(e===BigInt(0))return BigInt(1);if(e===BigInt(1))return t;let n=t;for(let r=BigInt(1);r<e;r++)if(this.options.checkOverflow){const e=n*t;if(e>this.options.maxValue)throw new s("Power computation would overflow");n=e}else n*=t;return n}build(t,e){this.validateHeight(e);const n="bigint"==typeof t?t:BigInt(t);this.validateValue(n),this.clear();for(let t=0;t<e;t++){const e=this.createNode(n,t+1);this.head?(e.previous=this.tail,this.tail.next=e,this.tail=e):(this.head=e,this.tail=e),this.size++}}evaluate(t){if(!this.head)return BigInt(1);const e=t??this.size;this.validateHeight(e);let n=this.head,r=n.value,i=1;try{for(;n.next&&i<e;)r=this.computePower(n.next.value,r),n.evaluated=!0,n=n.next,i++;return n.evaluated=!0,r}catch(t){if(t instanceof s){let e=this.head;for(;e!==n;)e.evaluated=!0,e=e.next;throw t}throw t}}getHeight(){return this.size}isComputable(t){try{const e=t??this.size;this.validateHeight(e);let n=this.head,r=0;for(;n&&r<e;){if(n.value>BigInt(4)&&r>3)return!1;n=n.next,r++}const i={...this.options,maxValue:this.options.maxValue>>BigInt(1)},o=new At(i);return o.build(this.head.value,e),o.evaluate(),!0}catch{return!1}}getState(){const t=[];let e=this.head;for(;e;)t.push({height:e.height,value:e.value,evaluated:e.evaluated}),e=e.next;return t}clear(){this.head=null,this.tail=null,this.size=0}static getMaxFeasibleHeight(t){const e="bigint"==typeof t?t:BigInt(t);return l(e),e===BigInt(0)?0:e===BigInt(1)?1/0:e===BigInt(2)?4:e===BigInt(3)?3:e===BigInt(4)?2:1}toString(){if(!this.head)return"Empty Tower";let t=this.head.value.toString(),e=this.head;for(;e.next;)t=`${e.next.value}^(${t})`,e=e.next;return t}}const Mt={notation:"standard",precision:0,grouping:!0,groupSize:3,decimalSeparator:".",groupSeparator:","},yt=(t,e={})=>{const n={...Mt,...e},r=t<BigInt(0),i=r?-t:t;let o;switch(n.notation){case"scientific":o=_t(i,n).coefficient+"e"+_t(i,n).exponent;break;case"engineering":o=Rt(i,n);break;case"compact":o=Tt(i,n);break;default:o=Ot(i,n)}return r?"-"+o:o},Ot=(t,e)=>{let n=t.toString();if(!e.grouping)return n;const r=[];let i=n.length;for(;i>0;){const t=Math.max(0,i-e.groupSize);r.unshift(n.slice(t,i)),i=t}return r.join(e.groupSeparator)},_t=(t,e)=>{if(t===BigInt(0))return{coefficient:"0",exponent:0};const n=t.toString(),r=n.length-1;let i=n[0]||"";return i+=e.decimalSeparator+n.slice(1,e.precision+1),{coefficient:i,exponent:r}},Rt=(t,e)=>{if(t===BigInt(0))return"0";const n=t.toString(),r=n.length,i=3*Math.floor((r-1)/3);let o="";const s=r-i;for(let t=0;t<Math.min(r,s+e.precision);t++)t===s&&t<r&&(o+=e.decimalSeparator),o+=n[t];return`${o}e${i}`},Tt=(t,e)=>{const n=["","K","M","B","T","Q"],r=t.toString().length;if(r<=3)return Ot(t,e);const i=Math.min(Math.floor((r-1)/3),n.length-1),o=n[i],s=BigInt(10)**BigInt(3*i);let a=(t/s).toString();if(e.precision>0){const n=t%s;if(n>BigInt(0)){const t=n.toString().padStart(3,"0").slice(0,e.precision);a+=e.decimalSeparator+t}}return a+o};class Ct{constructor(t={}){if(this.config={precision:t.precision??D.precision,roundingMode:t.roundingMode??D.roundingMode,checkOverflow:t.checkOverflow??D.checkOverflow,maxSteps:t.maxSteps??D.maxSteps,debug:t.debug??F.DEBUG_MODE},this.config.precision<0||this.config.precision>100)throw new H("Precision must be between 0 and 100");if(this.config.maxSteps<1||this.config.maxSteps>N)throw new H("Max steps must be between 1 and 1000");this.structures={arrays:new Map,trees:new Map,heaps:new Map}}add(t,e){return Y(t,e,this.config)}subtract(t,e){return Q(t,e,this.config)}multiply(t,e){return J(t,e,this.config)}divide(t,e){return tt(t,e,this.config)}mod(t,e){return et(t,e,this.config)}power(t,e){return gt(t,e,this.config)}sqrt(t){return dt(t,this.config)}nthRoot(t,e){return mt(t,e,this.config)}and(t,e){return at(t,e)}or(t,e){return ut(t,e)}xor(t,e){return ct(t,e)}not(t){return ht(t)}gcd(t,e){return rt(t,e)}lcm(t,e){return it(t,e)}createArray(t){if(this.structures.arrays.has(t))throw new H(`Array with id '${t}' already exists`);const e=new Bt;return this.structures.arrays.set(t,e),e}getArray(t){const e=this.structures.arrays.get(t);if(!e)throw new H(`Array with id '${t}' not found`);return e}createTree(t){if(this.structures.trees.has(t))throw new H(`Tree with id '${t}' already exists`);const e=new St;return this.structures.trees.set(t,e),e}getTree(t){const e=this.structures.trees.get(t);if(!e)throw new H(`Tree with id '${t}' not found`);return e}createHeap(t,e=!0){if(this.structures.heaps.has(t))throw new H(`Heap with id '${t}' already exists`);const n=e?new Et(this.compareValues):new vt(this.compareValues);return this.structures.heaps.set(t,n),n}getHeap(t){const e=this.structures.heaps.get(t);if(!e)throw new H(`Heap with id '${t}' not found`);return e}createAckermannStructure(){return new xt}format(t,e){const n=a(t);return yt(n,e)}validate(t){try{return a(t),!0}catch{return!1}}updateConfig(t){Object.assign(this.config,t)}getConfig(){return{...this.config}}compareValues(t,e){return t<e?-1:t>e?1:0}dispose(){this.structures.arrays.clear(),this.structures.trees.clear(),this.structures.heaps.clear()}}const Pt={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,tolerance:0};function Lt(t,e,n={}){const r={...Pt,...n},i=a(t),o=a(e);if(0===r.precision&&0===r.tolerance)return i<o?-1:i>o?1:0;const[s,u]=d(i,o,r.precision,r.precision);if(r.tolerance>0){const t=s-u,e=BigInt(10)**BigInt(r.tolerance);return t<-e?-1:t>e?1:0}return s<u?-1:s>u?1:0}function Ft(t,e,n={}){return 0===Lt(t,e,n)}function Dt(t,e,n={}){return-1===Lt(t,e,n)}function Vt(t,e,n={}){const r=Lt(t,e,n);return-1===r||0===r}function Ht(t,e,n={}){return 1===Lt(t,e,n)}function kt(t,e,n={}){const r=Lt(t,e,n);return 1===r||0===r}const zt={precision:0,roundingMode:t.RoundingMode.HALF_EVEN,uppercase:!1,prefix:!1,minDigits:1};const Ut={maxValue:1e3,checkOverflow:!0,useCache:!0},$t=new Map;function Gt(t,e={}){const n={...Ut,...e},r=a(t);if(l(r),n.checkOverflow&&r>BigInt(n.maxValue))throw new s(`Factorial input too large: maximum allowed is ${n.maxValue}`);if(r<=1n)return 1n;if(n.useCache&&$t.has(r))return $t.get(r);let i=1n;for(let t=2n;t<=r;t++)i*=t;return n.useCache&&$t.set(r,i),i}const Xt=e.resolve(e.dirname(n.fileURLToPath("undefined"==typeof document&&"undefined"==typeof location?require("url").pathToFileURL(__filename).href:"undefined"==typeof document?location.href:i&&"SCRIPT"===i.tagName.toUpperCase()&&i.src||new URL("index.umd.js",document.baseURI).href)),"../package.json"),{version:jt}=JSON.parse(r.readFileSync(Xt,"utf-8"));function qt(e){const n=B(e||{});x(n);const r={precision:"arithmetic"in n?n.arithmetic.defaultPrecision:n.precision??0,roundingMode:"arithmetic"in n?n.arithmetic.defaultRoundingMode:n.roundingMode??t.RoundingMode.HALF_EVEN,checkOverflow:"arithmetic"in n?n.arithmetic.checkOverflow:n.checkOverflow??!0,maxSteps:"arithmetic"in n?n.arithmetic.maxComputationSteps:n.maxSteps??1e3,debug:"debug"in n&&"object"==typeof n.debug&&n.debug.verbose};return new Ct(r)}const Kt=qt();t.AckermannStructure=xt,t.BigArray=Bt,t.ComputationLimitError=$,t.DEFAULT_ARRAY_GROWTH_FACTOR=2,t.DEFAULT_BASIC_CONFIG=w,t.DEFAULT_CACHE_SIZE=1e3,t.DEFAULT_DECIMAL_SEPARATOR=".",t.DEFAULT_FULL_CONFIG=I,t.DEFAULT_GROUP_SEPARATOR=",",t.DEFAULT_GROUP_SIZE=3,t.DEFAULT_HEAP_INITIAL_CAPACITY=16,t.DEFAULT_OPTIONS=D,t.DEFAULT_TREE_MAX_DEPTH=1e3,t.DataStructureError=G,t.DivisionByZeroError=z,t.ERROR_MESSAGES=L,t.FEATURES=F,t.FormatError=K,t.HeapPropertyError=X,t.Hypernum=Ct,t.HypernumError=V,t.IndexError=q,t.MAX_ACKERMANN_M=4,t.MAX_ACKERMANN_N=1e3,t.MAX_BITS=1024,t.MAX_CACHE_SIZE=1e4,t.MAX_COMPUTATION_STEPS=N,t.MAX_FACTORIAL_INPUT=P,t.MAX_GROUP_SIZE=10,t.MAX_POWER_BASE=R,t.MAX_POWER_EXPONENT=T,t.MAX_PRECISION=100,t.MAX_ROMAN_VALUE=3999,t.MAX_SAFE_INTEGER=b,t.MAX_TETRATION_HEIGHT=C,t.MIN_ARRAY_CAPACITY=16,t.MIN_ROMAN_VALUE=1,t.MIN_SAFE_INTEGER=S,t.MaxHeap=vt,t.MinHeap=Et,t.NEGATIVE_ONE=_,t.NUMBER_UNITS=[{value:1n,symbol:""},{value:1000n,symbol:"K"},{value:1000000n,symbol:"M"},{value:1000000000n,symbol:"B"},{value:1000000000000n,symbol:"T"},{value:1000000000000000n,symbol:"Q"}],t.NumberTree=St,t.ONE=M,t.PERFORMANCE={WARN_THRESHOLD_MS:100,ERROR_THRESHOLD_MS:1e3,MAX_ARRAY_SIZE:1e6,MAX_TREE_SIZE:1e6},t.PowerTower=At,t.PrecisionError=U,t.RomanNumeralError=W,t.TEN=O,t.TWO=y,t.TreeError=j,t.UnderflowError=k,t.VERSION=jt,t.ZERO=A,t.abs=nt,t.add=Y,t.allEqual=function(t,e={}){if(t.length<=1)return!0;const n=a(t[0]);return t.every((t=>Ft(t,n,e)))},t.and=at,t.between=function(t,e,n,r={}){return kt(t,e,r)&&Vt(t,n,r)},t.binomial=function t(e,n,r={}){const i={...Ut,...r},s=a(e),u=a(n);if(l(s),l(u),u>s)throw new o("K cannot be greater than N in binomial coefficient");if(u>s/2n)return t(s,s-u,i);let c=1n;for(let t=0n;t<u;t++)c=c*(s-t)/(t+1n);return c},t.checkAdditionOverflow=u,t.checkMultiplicationOverflow=c,t.checkPowerOverflow=h,t.clamp=function(t,e,n,r={}){const i=a(t),s=a(e),u=a(n);if(Dt(u,s,r))throw new o("Maximum bound must be greater than or equal to minimum bound");return Dt(i,s,r)?s:Ht(i,u,r)?u:i},t.clearBit=function(t,e,n={}){const r={...ot,...n},i=a(t),s=a(e);if(l(s),r.strict&&s>=BigInt(r.maxBits))throw new o(`Bit position exceeds maximum of ${r.maxBits} bits`);return i&~(1n<<s)},t.compare=Lt,t.convertToBasicConfig=function(t){return v(t)?t:{precision:t.arithmetic.defaultPrecision,roundingMode:t.arithmetic.defaultRoundingMode,checkOverflow:t.arithmetic.checkOverflow,maxSteps:t.arithmetic.maxComputationSteps,debug:t.debug.verbose}},t.createComparator=function(t={}){return(e,n)=>Lt(e,n,t)},t.createHypernum=qt,t.default=Ct,t.defaultHypernum=Kt,t.divide=tt,t.equals=Ft,t.factorial=Gt,t.fallingFactorial=function(t,e,n={}){const r={...Ut,...n},i=a(t),o=a(e);if(l(o),r.checkOverflow&&o>BigInt(r.maxValue))throw new s(`Falling factorial input too large: maximum allowed is ${r.maxValue}`);let u=1n;for(let t=0n;t<o;t++)u*=i-t;return u},t.formatBigInt=yt,t.fromBase=function(t,e){if(e<2||e>36)throw new o("Base must be between 2 and 36");const n=t.toLowerCase().replace(/^0x/,"").replace(/^0b/,"").replace(/^0o/,"");try{return BigInt(`${e}n${n}`)}catch(n){throw new o(`Invalid number format for base ${e}: ${t}`)}},t.fromFraction=function(t,e,n={}){const r={...zt,...n},i=a(t),s=a(e);if(0n===s)throw new o("Denominator cannot be zero");const u=i/s,c=i%s;return 0n===c||0===r.precision?u.toString():`${u}.${(c*10n**BigInt(r.precision)/s).toString().padStart(r.precision,"0")}`},t.fromRoman=function(t){const e=new Map([["I",1],["V",5],["X",10],["L",50],["C",100],["D",500],["M",1e3]]);let n=0,r=0;for(let i=t.length-1;i>=0;i--){const s=t[i]?.toUpperCase()??"",a=e.get(s);if(void 0===a)throw new o(`Invalid Roman numeral character: ${s}`);a>=r?n+=a:n-=a,r=a}return BigInt(n)},t.fromScientific=function(t){const e=t.match(/^(-?\d+\.?\d*)[eE]([+-]?\d+)$/);if(!e)throw new o("Invalid scientific notation format");const[,n,r]=e,i=parseInt(r||"0",10);if(i>=0){if(void 0===n)throw new o("Invalid scientific notation format");return(BigInt(n.replace(".",""))*10n**BigInt(i)).toString()}{const t=Math.abs(i);if(void 0===n)throw new o("Invalid scientific notation format");return(BigInt(n.replace(".",""))/10n**BigInt(t)).toString()}},t.gcd=rt,t.getBit=function(t,e,n={}){const r={...ot,...n},i=a(t),s=a(e);if(l(s),r.strict&&s>=BigInt(r.maxBits))throw new o(`Bit position exceeds maximum of ${r.maxBits} bits`);return 0n!==(i&1n<<s)},t.greaterThan=Ht,t.greaterThanOrEqual=kt,t.isAscending=function(t,e={}){if(t.length<=1)return!0;for(let n=1;n<t.length;n++)if(void 0===t[n]||void 0===t[n-1]||!kt(t[n],t[n-1],e))return!1;return!0},t.isBasicConfig=v,t.isDescending=function(t,e={}){if(t.length<=1)return!0;for(let n=1;n<t.length;n++)if(void 0===t[n]||void 0===t[n-1]||!Vt(t[n],t[n-1],e))return!1;return!0},t.isFullConfig=E,t.lcm=it,t.leadingZeros=function(t,e={}){const n={...ot,...e};let r=a(t);if(0n===r)return BigInt(n.maxBits);let i=0n;const o=1n<<BigInt(n.maxBits-1);for(;0n===(r&o)&&i<BigInt(n.maxBits);)i++,r=lt(r,1n,n);return i},t.leftShift=lt,t.lessThan=Dt,t.lessThanOrEqual=Vt,t.max=function(t,e={}){if(0===t.length)throw new o("Cannot find maximum of empty array");return t.reduce(((t,n)=>{const r=a(t),i=a(n);return Ht(i,r,e)?i:r}),a(t[0]))},t.mergeConfig=B,t.min=function(t,e={}){if(0===t.length)throw new o("Cannot find minimum of empty array");return t.reduce(((t,n)=>{const r=a(t),i=a(n);return Dt(i,r,e)?i:r}),a(t[0]))},t.multiFactorial=function(t,e=2n,n={}){const r={...Ut,...n},i=a(t),u=a(e);if(l(i),u<=0n)throw new o("K must be positive in multifactorial");if(r.checkOverflow&&i>BigInt(r.maxValue))throw new s(`Multifactorial input too large: maximum allowed is ${r.maxValue}`);let c=1n,h=i;for(;h>0n;)c*=h,h-=u;return c},t.multiply=J,t.normalizeNumberString=t=>{if((t=t.replace(/[\s,]/g,"")).toLowerCase().includes("e")){const[e,n]=t.toLowerCase().split("e"),r=parseInt(n||"0");return(parseFloat(e||"0")*Math.pow(10,r)).toString()}return t},t.normalizePrecision=d,t.not=ht,t.nthRoot=mt,t.or=ut,t.parseBigIntString=(t,e={})=>{const n={...Mt,...e};let r=t.replace(new RegExp(`\\${n.groupSeparator}`,"g"),"");if(r.toLowerCase().includes("e")){const[t,e]=r.toLowerCase().split("e"),n=BigInt(10),i=BigInt(e||"0");return BigInt(Math.floor(Number(t)))*n**i}const i=new Map([["k",BigInt(1e3)],["m",BigInt(1e6)],["b",BigInt(1e9)],["t",BigInt(1e12)],["q",BigInt(1e15)]]),o=r.slice(-1).toLowerCase(),s=i.get(o);if(s){r=r.slice(0,-1);return BigInt(Math.floor(Number(r)))*s}return BigInt(r)},t.popCount=function(t,e={}){const n={...ot,...e};let r=a(t),i=0n;for(;0n!==r;)i+=1n&r,r=ft(r,1n,n);return i},t.power=gt,t.primorial=function(t,e={}){const n={...Ut,...e},r=a(t);if(l(r),n.checkOverflow&&r>BigInt(n.maxValue))throw new s(`Primorial input too large: maximum allowed is ${n.maxValue}`);if(r<=1n)return 1n;const i=Number(r),o=new Array(i+1).fill(!0);o[0]=o[1]=!1;for(let t=2;t*t<=i;t++)if(o[t])for(let e=t*t;e<=i;e+=t)o[e]=!1;let u=1n;for(let t=2;t<=i;t++)o[t]&&(u*=BigInt(t));return u},t.remainder=et,t.rightShift=function(t,e,n={}){const r={...ot,...n},i=a(t),o=a(e);return st(o,r),i>>o},t.risingFactorial=function(t,e,n={}){const r={...Ut,...n},i=a(t),o=a(e);if(l(o),r.checkOverflow&&o>BigInt(r.maxValue))throw new s(`Rising factorial input too large: maximum allowed is ${r.maxValue}`);let u=1n;for(let t=0n;t<o;t++)u*=i+t;return u},t.rotateLeft=function(t,e,n={}){const r={...ot,...n},i=a(t);let o=a(e);return l(o),o>=BigInt(r.maxBits)&&(o%=BigInt(r.maxBits)),0n===o?i:lt(i,o,r)|ft(i,BigInt(r.maxBits)-o,r)},t.rotateRight=function(t,e,n={}){const r={...ot,...n},i=a(t);let o=a(e);if(l(o),o>=BigInt(r.maxBits)&&(o%=BigInt(r.maxBits)),0n===o)return i;const s=ft(i,o,r);return lt(i,BigInt(r.maxBits)-o,r)|s},t.round=g,t.scaleByPowerOfTen=p,t.scaledDivision=m,t.setBit=function(t,e,n={}){const r={...ot,...n},i=a(t),s=a(e);if(l(s),r.strict&&s>=BigInt(r.maxBits))throw new o(`Bit position exceeds maximum of ${r.maxBits} bits`);return i|1n<<s},t.sign=function(t){const e=a(t);return e<BigInt(0)?BigInt(-1):e>BigInt(0)?BigInt(1):BigInt(0)},t.sqrt=dt,t.subfactorial=function(t,e={}){const n={...Ut,...e},r=a(t);if(l(r),n.checkOverflow&&r>BigInt(n.maxValue))throw new s(`Subfactorial input too large: maximum allowed is ${n.maxValue}`);if(0n===r)return 1n;if(1n===r)return 0n;let i=0n;const o=Gt(r,n);for(let t=0n;t<=r;t++){i+=Gt(r-t,n)*(t%2n===0n?1n:-1n)}return o-i},t.subtract=Q,t.superRoot=function(t,e,n={}){const r={...pt,...n},i=a(t),u=a(e);if(l(u),0n===u)throw new o("Height cannot be zero for super-root");if(i<1n)throw new o("Value must be at least 1 for super-root");if(1n===i)return 1n;if(1n===u)return i;let c=1n,h=i,f=0;for(;c<=h;){if(f++>r.maxSteps)throw new s("Super-root operation exceeded maximum computation steps");const t=c+h>>1n;try{const e=wt(t,u,r);if(e===i)return t;e<i?c=t+1n:h=t-1n}catch(e){h=t-1n}}return r.precision>0?g(h,r.precision,r.roundingMode):h},t.tetration=wt,t.toBase=function(t,e,n={}){if(e<2||e>36)throw new o("Base must be between 2 and 36");const r={...zt,...n};let i=a(t).toString(e);for(r.uppercase&&(i=i.toUpperCase());i.length<r.minDigits;)i="0"+i;return i},t.toBigInt=a,t.toBinary=function(t,e={}){const n={...zt,...e};let r=a(t).toString(2);for(;r.length<n.minDigits;)r="0"+r;return n.prefix?"0b"+r:r},t.toFraction=function(t){const[e,n=""]=t.split(".");if(!n)return[a(e),1n];const r=a(e+n),i=10n**BigInt(n.length),o=function(t,e){t=t<0n?-t:t,e=e<0n?-e:e;for(;0n!==e;){const n=e;e=t%e,t=n}return t}(r,i);return[r/o,i/o]},t.toHexadecimal=function(t,e={}){const n={...zt,...e};let r=a(t).toString(16);for(n.uppercase&&(r=r.toUpperCase());r.length<n.minDigits;)r="0"+r;return n.prefix?"0x"+r:r},t.toOctal=function(t,e={}){const n={...zt,...e};let r=a(t).toString(8);for(;r.length<n.minDigits;)r="0"+r;return n.prefix?"0o"+r:r},t.toRoman=function(t,e={}){const n={...zt,...e},r=Number(a(t));if(r<=0||r>3999)throw new o("Number must be between 1 and 3999 for Roman numerals");const i=[["I","V"],["X","L"],["C","D"],["M"]];let s="",u=0,c=r;for(;c>0;){const t=c%10,e=i[u];if(!e)break;const n=e[0],r=e[1]??"",o=u<3?i[u+1]?.[0]??"":"";let a="";a=9===t&&o?n+o:t>=5&&r?r+n.repeat(t-5):4===t&&r?n+r:n.repeat(t),s=a+s,c=Math.floor(c/10),u++}return n.uppercase?s:s.toLowerCase()},t.toScientific=function(t,e={}){const n={...zt,...e},r=a(t);if(0n===r)return"0e0";const i=r.toString(),o="-"===i[0]?i[1]:i[0],s=i.length-("-"===i[0]?2:1);let u=o;if(i.length>1){const t=i.slice("-"===i[0]?2:1);n.precision>0&&(u+="."+t.slice(0,n.precision))}return"-"===i[0]&&(u="-"+u),`${u}e${s}`},t.toggleBit=function(t,e,n={}){const r={...ot,...n},i=a(t),s=a(e);if(l(s),r.strict&&s>=BigInt(r.maxBits))throw new o(`Bit position exceeds maximum of ${r.maxBits} bits`);return i^1n<<s},t.trailingZeros=function(t,e={}){const n={...ot,...e};let r=a(t);if(0n===r)return BigInt(n.maxBits);let i=0n;for(;0n===(1n&r);)i++,r=ft(r,1n,n);return i},t.unsignedRightShift=ft,t.validateConfig=x,t.validateNonNegative=l,t.validatePositive=t=>{if(t<=BigInt(0))throw new o("Value must be positive")},t.xor=ct,Object.defineProperty(t,"__esModule",{value:!0})}));
//# sourceMappingURL=index.umd.js.map
